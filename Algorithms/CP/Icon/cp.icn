# Constraint Propagation (CP) Sudoku Solver - Icon Implementation
# Mechanical translation from Python reference to preserve algorithm correctness.
#
# Algorithm: Constraint propagation with MRV (Minimum Remaining Values) heuristic
# - Uses bitsets to track candidate values (bits 1-9)
# - Propagates constraints: singleton elimination, hidden singles
# - Search with MRV cell selection for efficiency

global cp_iterations

# Bitset operations for candidate tracking
procedure has_candidate(candidate_set, digit)
    return iand(candidate_set, ishift(1, digit)) ~= 0
end

procedure add_candidate(candidate_set, digit)
    return ior(candidate_set, ishift(1, digit))
end

procedure remove_candidate(candidate_set, digit)
    return iand(candidate_set, ixor(-1, ishift(1, digit)))
end

procedure count_candidates(candidate_set)
    local count, i
    count := 0
    every i := 1 to 9 do {
        if has_candidate(candidate_set, i) then
            count +:= 1
    }
    return count
end

procedure get_first_candidate(candidate_set)
    local digit
    every digit := 1 to 9 do {
        if has_candidate(candidate_set, digit) then
            return digit
    }
    return 0
end

# Grid structure
record CPGrid(values, candidates)

procedure new_cpgrid()
    local g, r, c
    g := CPGrid([], [])
    every r := 1 to 9 do {
        put(g.values, list(9, 0))
        put(g.candidates, list(9, 0))
    }
    return g
end

procedure copy_grid(g)
    local new_g, r, c
    new_g := CPGrid([], [])
    every r := 1 to 9 do {
        put(new_g.values, copy(g.values[r]))
        put(new_g.candidates, copy(g.candidates[r]))
    }
    return new_g
end

procedure get_peers(row, col)
    local peers, r, c, box_row, box_col
    peers := []

    # Same row (8 cells excluding self)
    every c := 1 to 9 do {
        if c ~= col then
            put(peers, [row, c])
    }

    # Same column (8 cells excluding self)
    every r := 1 to 9 do {
        if r ~= row then
            put(peers, [r, col])
    }

    # Same 3x3 box (4 cells excluding self and already counted)
    box_row := ((row - 1) / 3) * 3 + 1
    box_col := ((col - 1) / 3) * 3 + 1
    every r := box_row to box_row + 2 do {
        every c := box_col to box_col + 2 do {
            if r ~= row & c ~= col then
                put(peers, [r, c])
        }
    }

    return peers
end

procedure init_grid(grid, puzzle)
    local row, col, digit
    every row := 1 to 9 do {
        every col := 1 to 9 do {
            if puzzle[row][col] = 0 then {
                # Empty cell: set all candidates 1-9 (bits 1-9 set)
                grid.values[row][col] := 0
                grid.candidates[row][col] := 16r3FE  # 0x3FE = 0011 1111 1110
            } else {
                # Given clue: set single value
                digit := puzzle[row][col]
                grid.values[row][col] := digit
                grid.candidates[row][col] := ishift(1, digit)
            }
        }
    }
end

procedure eliminate(grid, row, col, digit)
    local remaining, last_digit

    # Check if digit is already eliminated
    if not has_candidate(grid.candidates[row][col], digit) then
        return 1  # Already eliminated, no change

    # Remove digit from candidates
    grid.candidates[row][col] := remove_candidate(grid.candidates[row][col], digit)

    # Check for contradiction (no candidates left)
    remaining := count_candidates(grid.candidates[row][col])
    if remaining = 0 then
        return 0  # Contradiction

    # If only one candidate left, assign it (singleton elimination)
    if remaining = 1 & grid.values[row][col] = 0 then {
        last_digit := get_first_candidate(grid.candidates[row][col])
        if not assign(grid, row, col, last_digit) then
            return 0  # Assignment caused contradiction
    }

    return 1
end

procedure assign(grid, row, col, digit)
    local peers, peer

    # Increment iteration counter (this is our benchmark metric)
    cp_iterations +:= 1

    # Set value
    grid.values[row][col] := digit
    grid.candidates[row][col] := ishift(1, digit)

    # Eliminate digit from all peers
    peers := get_peers(row, col)
    every peer := !peers do {
        if not eliminate(grid, peer[1], peer[2], digit) then
            return 0  # Contradiction in peer elimination
    }

    return 1
end

procedure propagate(grid)
    local changed, row, col, num_candidates, digit
    local count, last_col, already_assigned, last_row
    local box, box_row, box_col, last_r, last_c, r, c

    changed := 1

    while changed do {
        changed := 0

        # Strategy 1: Singleton elimination
        # If a cell has only one candidate, assign it
        every row := 1 to 9 do {
            every col := 1 to 9 do {
                if grid.values[row][col] = 0 then {
                    num_candidates := count_candidates(grid.candidates[row][col])
                    if num_candidates = 0 then
                        return 0  # Contradiction
                    if num_candidates = 1 then {
                        digit := get_first_candidate(grid.candidates[row][col])
                        if not assign(grid, row, col, digit) then
                            return 0  # Assignment caused contradiction
                        changed := 1
                    }
                }
            }
        }

        # Strategy 2: Hidden singles
        # For each unit (row, col, box), if a digit appears in only one cell, assign it

        # Check rows
        every row := 1 to 9 do {
            every digit := 1 to 9 do {
                count := 0
                last_col := -1
                already_assigned := 0

                every col := 1 to 9 do {
                    if grid.values[row][col] = digit then {
                        already_assigned := 1
                        break
                    }
                    if has_candidate(grid.candidates[row][col], digit) then {
                        count +:= 1
                        last_col := col
                    }
                }

                if already_assigned = 0 then {
                    if count = 1 then {
                        if not assign(grid, row, last_col, digit) then
                            return 0
                        changed := 1
                    } else if count = 0 then
                        return 0  # Digit cannot be placed anywhere in row
                }
            }
        }

        # Check columns
        every col := 1 to 9 do {
            every digit := 1 to 9 do {
                count := 0
                last_row := -1
                already_assigned := 0

                every row := 1 to 9 do {
                    if grid.values[row][col] = digit then {
                        already_assigned := 1
                        break
                    }
                    if has_candidate(grid.candidates[row][col], digit) then {
                        count +:= 1
                        last_row := row
                    }
                }

                if already_assigned = 0 then {
                    if count = 1 then {
                        if not assign(grid, last_row, col, digit) then
                            return 0
                        changed := 1
                    } else if count = 0 then
                        return 0  # Digit cannot be placed anywhere in column
                }
            }
        }

        # Check boxes
        every box := 0 to 8 do {
            box_row := (box / 3) * 3 + 1
            box_col := (box % 3) * 3 + 1

            every digit := 1 to 9 do {
                count := 0
                last_r := -1
                last_c := -1
                already_assigned := 0

                every r := box_row to box_row + 2 do {
                    every c := box_col to box_col + 2 do {
                        if grid.values[r][c] = digit then {
                            already_assigned := 1
                            break break
                        }
                        if has_candidate(grid.candidates[r][c], digit) then {
                            count +:= 1
                            last_r := r
                            last_c := c
                        }
                    }
                    if already_assigned = 1 then break
                }

                if already_assigned = 0 then {
                    if count = 1 then {
                        if not assign(grid, last_r, last_c, digit) then
                            return 0
                        changed := 1
                    } else if count = 0 then
                        return 0  # Digit cannot be placed anywhere in box
                }
            }
        }
    }

    return 1  # Success - reached fixpoint
end

procedure find_mrv_cell(grid)
    local min_candidates, found, mrv_row, mrv_col, r, c, num_candidates

    min_candidates := 10  # More than 9, so any cell will be smaller
    found := 0
    mrv_row := -1
    mrv_col := -1

    every r := 1 to 9 do {
        every c := 1 to 9 do {
            if grid.values[r][c] = 0 then {
                num_candidates := count_candidates(grid.candidates[r][c])
                if num_candidates < min_candidates then {
                    min_candidates := num_candidates
                    mrv_row := r
                    mrv_col := c
                    found := 1
                }
            }
        }
    }

    if found = 1 then
        return [mrv_row, mrv_col]
    return &null
end

procedure cp_search(grid, solution)
    local mrv_cell, mrv_row, mrv_col, candidates, digit, grid_copy, r, c

    # Base case: check if grid is complete
    mrv_cell := find_mrv_cell(grid)
    if /mrv_cell then {
        # No empty cells - grid is complete, extract solution
        every r := 1 to 9 do {
            every c := 1 to 9 do {
                solution[(r - 1) * 9 + c] := grid.values[r][c]
            }
        }
        return 1
    }

    mrv_row := mrv_cell[1]
    mrv_col := mrv_cell[2]

    # Recursive case: try each candidate for the MRV cell
    candidates := grid.candidates[mrv_row][mrv_col]

    every digit := 1 to 9 do {
        if has_candidate(candidates, digit) then {
            # Save grid state for backtracking
            grid_copy := copy_grid(grid)

            # Try assigning this digit
            if assign(grid, mrv_row, mrv_col, digit) then {
                # Assignment succeeded, propagate constraints
                if propagate(grid) then {
                    # Propagation succeeded, recurse
                    if cp_search(grid, solution) then
                        return 1  # Found solution
                }
            }

            # Failed - restore grid state and try next candidate
            grid.values := grid_copy.values
            grid.candidates := grid_copy.candidates
        }
    }

    # All candidates exhausted - dead end
    return 0
end

procedure print_puzzle(puzzle)
    local r, c, line

    write("\nPuzzle:")
    every r := 1 to 9 do {
        line := ""
        every c := 1 to 9 do {
            line ||:= puzzle[r][c] || " "
        }
        write(line)
    }
end

procedure read_matrix_file(filename)
    local puzzle, display_path, line, values, row_count, f, parts, i

    puzzle := []
    every 1 to 9 do
        put(puzzle, list(9, 0))

    # Normalize path for output
    display_path := filename
    if match("/app/Matrices/", filename) then
        display_path := "../" || filename[6:0]  # Skip "/app/" to get "Matrices/..."
    write(display_path)

    row_count := 0
    f := open(filename) | stop("Cannot open file: ", filename)

    while line := read(f) do {
        # Skip comments and empty lines
        line := trim(line)
        if *line = 0 | match("#", line) then next

        # Parse 9 integers from line
        parts := []
        line ? {
            while tab(many(' \t')) | 1 do {
                if i := tab(many(&digits)) then
                    put(parts, integer(i))
                else
                    break
            }
        }

        if *parts = 9 & row_count < 9 then {
            row_count +:= 1
            every i := 1 to 9 do
                puzzle[row_count][i] := parts[i]

            # Print the row
            line := ""
            every i := 1 to 9 do
                line ||:= parts[i] || " "
            write(line)
        }
    }

    close(f)

    if row_count ~= 9 then
        stop("Expected 9 lines, got ", row_count)

    return puzzle
end

procedure main(args)
    local start_time, filename, puzzle, grid, solution, r, c, solution_grid, elapsed

    start_time := &time

    if *args ~= 1 then {
        write(&errout, "Usage: ", &progname, " <matrix_file>")
        exit(1)
    }

    filename := args[1]

    # Read puzzle from file
    puzzle := read_matrix_file(filename) | {
        write(&errout, "Error reading matrix file")
        exit(1)
    }

    print_puzzle(puzzle)

    # Initialize CP grid
    grid := new_cpgrid()
    init_grid(grid, puzzle)

    # Apply initial propagation
    cp_iterations := 0
    if not propagate(grid) then {
        write("\nNo solution found (contradiction during initial propagation)\n")
        elapsed := (&time - start_time) / 1000.0
        write("Seconds to process ", elapsed)
        exit(0)
    }

    # Run search
    solution := list(81, 0)
    if cp_search(grid, solution) then {
        # Convert solution array back to 2D for printing
        solution_grid := []
        every 1 to 9 do
            put(solution_grid, list(9, 0))

        every r := 1 to 9 do {
            every c := 1 to 9 do {
                solution_grid[r][c] := solution[(r - 1) * 9 + c]
            }
        }

        print_puzzle(solution_grid)
        write("\nSolved in Iterations=", cp_iterations, "\n")
    } else {
        write("\nNo solution found\n")
    }

    elapsed := (&time - start_time) / 1000.0
    write("Seconds to process ", real(elapsed))

    exit(0)
end
