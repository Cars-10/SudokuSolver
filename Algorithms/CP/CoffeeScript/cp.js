// Generated by CoffeeScript 2.7.0
(function() {
  //!/usr/bin/env coffee
  // CP (Constraint Propagation) Sudoku Solver - CoffeeScript Implementation
  // Direct port of JavaScript implementation with MRV heuristic and propagation
  var CPGrid, addCandidate, arg, assign, c, countCandidates, cpIterations, cpSearch, elapsed, eliminate, findMrvCell, fs, getFirstCandidate, getPeers, grid, hasCandidate, i, initGrid, j, k, l, len, printPuzzle, propagate, puzzle, r, readMatrixFile, ref, removeCandidate, solution, solutionGrid, solved, startTime;

  fs = require('fs');

  // Data Structures
  CPGrid = class CPGrid {
    constructor() {
      var i;
      this.values = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j < 9; i = ++j) {
          results.push(Array(9).fill(0));
        }
        return results;
      })();
      this.candidates = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j < 9; i = ++j) {
          results.push(Array(9).fill(0));
        }
        return results;
      })();
    }

    copy() {
      var c, grid, j, k, r;
      grid = new CPGrid();
      for (r = j = 0; j < 9; r = ++j) {
        for (c = k = 0; k < 9; c = ++k) {
          grid.values[r][c] = this.values[r][c];
          grid.candidates[r][c] = this.candidates[r][c];
        }
      }
      return grid;
    }

  };

  // Global State
  cpIterations = 0;

  puzzle = (function() {
    var j, results;
    results = [];
    for (i = j = 0; j < 9; i = ++j) {
      results.push(Array(9).fill(0));
    }
    return results;
  })();

  // Bitset Helpers
  hasCandidate = function(set, digit) {
    return (set & (1 << digit)) !== 0;
  };

  addCandidate = function(set, digit) {
    return set | (1 << digit);
  };

  removeCandidate = function(set, digit) {
    return set & ~(1 << digit);
  };

  countCandidates = function(set) {
    var count;
    count = 0;
    while (set) {
      count += set & 1;
      set >>= 1;
    }
    return count;
  };

  getFirstCandidate = function(set) {
    var digit, j;
    for (digit = j = 1; j <= 9; digit = ++j) {
      if (hasCandidate(set, digit)) {
        return digit;
      }
    }
    return 0;
  };

  // Helper Functions
  getPeers = function(row, col) {
    var boxCol, boxRow, c, j, k, l, m, peers, r, ref, ref1, ref2, ref3;
    peers = [];

    // Same row
    for (c = j = 0; j < 9; c = ++j) {
      if (c !== col) {
        peers.push([row, c]);
      }
    }

    // Same column
    for (r = k = 0; k < 9; r = ++k) {
      if (r !== row) {
        peers.push([r, col]);
      }
    }
    
    // Same 3x3 box
    boxRow = Math.floor(row / 3) * 3;
    boxCol = Math.floor(col / 3) * 3;
    for (r = l = ref = boxRow, ref1 = boxRow + 3; (ref <= ref1 ? l < ref1 : l > ref1); r = ref <= ref1 ? ++l : --l) {
      for (c = m = ref2 = boxCol, ref3 = boxCol + 3; (ref2 <= ref3 ? m < ref3 : m > ref3); c = ref2 <= ref3 ? ++m : --m) {
        if (r !== row && c !== col) {
          peers.push([r, c]);
        }
      }
    }
    return peers;
  };

  // Initialization
  initGrid = function(grid, puzzle) {
    var col, digit, j, results, row;
    results = [];
    for (row = j = 0; j < 9; row = ++j) {
      results.push((function() {
        var k, results1;
        results1 = [];
        for (col = k = 0; k < 9; col = ++k) {
          if (puzzle[row][col] === 0) {
            // Empty cell: set all candidates 1-9
            grid.values[row][col] = 0;
            results1.push(grid.candidates[row][col] = 0x3FE);
          } else {
            // Given clue: set single value
            digit = puzzle[row][col];
            grid.values[row][col] = digit;
            results1.push(grid.candidates[row][col] = 1 << digit);
          }
        }
        return results1;
      })());
    }
    return results;
  };

  // Constraint Propagation
  eliminate = function(grid, row, col, digit) {
    var lastDigit, remaining;
    if (!hasCandidate(grid.candidates[row][col], digit)) {
      // Check if digit is already eliminated
      return true;
    }
    
    // Remove digit from candidates
    grid.candidates[row][col] = removeCandidate(grid.candidates[row][col], digit);
    
    // Check for contradiction
    remaining = countCandidates(grid.candidates[row][col]);
    if (remaining === 0) {
      return false;
    }
    
    // If only one candidate left, assign it
    if (remaining === 1 && grid.values[row][col] === 0) {
      lastDigit = getFirstCandidate(grid.candidates[row][col]);
      if (!assign(grid, row, col, lastDigit)) {
        return false;
      }
    }
    return true;
  };

  assign = function(grid, row, col, digit) {
    var j, len, peerCol, peerRow, peers;
    // Increment iteration counter
    cpIterations++;
    
    // Set value
    grid.values[row][col] = digit;
    grid.candidates[row][col] = 1 << digit;
    
    // Eliminate digit from all peers
    peers = getPeers(row, col);
    for (j = 0, len = peers.length; j < len; j++) {
      [peerRow, peerCol] = peers[j];
      if (!eliminate(grid, peerRow, peerCol, digit)) {
        return false;
      }
    }
    return true;
  };

  propagate = function(grid) {
    var box, boxCol, boxRow, c, changed, col, count, digit, found, foundAssigned, j, k, l, lastC, lastCol, lastR, lastRow, m, n, numCandidates, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, row, s, t, u, v, w, x, y, z;
    changed = true;
    while (changed) {
      changed = false;

      // Strategy 1: Singleton elimination
      for (row = j = 0; j < 9; row = ++j) {
        for (col = k = 0; k < 9; col = ++k) {
          if (grid.values[row][col] === 0) {
            numCandidates = countCandidates(grid.candidates[row][col]);
            if (numCandidates === 0) {
              return false;
            }
            if (numCandidates === 1) {
              digit = getFirstCandidate(grid.candidates[row][col]);
              if (!assign(grid, row, col, digit)) {
                return false;
              }
              changed = true;
            }
          }
        }
      }

      // Strategy 2: Hidden singles - Rows
      for (row = l = 0; l < 9; row = ++l) {
        for (digit = m = 1; m <= 9; digit = ++m) {
          count = 0;
          lastCol = -1;
          for (col = n = 0; n < 9; col = ++n) {
            if (grid.values[row][col] === digit) {
              count = 0;
              break;
            }
            if (hasCandidate(grid.candidates[row][col], digit)) {
              count++;
              lastCol = col;
            }
          }
          if (count === 1) {
            if (!assign(grid, row, lastCol, digit)) {
              return false;
            }
            changed = true;
          } else if (count === 0) {
            found = false;
            for (col = o = 0; o < 9; col = ++o) {
              if (grid.values[row][col] === digit) {
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      }

      // Hidden singles - Columns
      for (col = p = 0; p < 9; col = ++p) {
        for (digit = q = 1; q <= 9; digit = ++q) {
          count = 0;
          lastRow = -1;
          for (row = s = 0; s < 9; row = ++s) {
            if (grid.values[row][col] === digit) {
              count = 0;
              break;
            }
            if (hasCandidate(grid.candidates[row][col], digit)) {
              count++;
              lastRow = row;
            }
          }
          if (count === 1) {
            if (!assign(grid, lastRow, col, digit)) {
              return false;
            }
            changed = true;
          } else if (count === 0) {
            found = false;
            for (row = t = 0; t < 9; row = ++t) {
              if (grid.values[row][col] === digit) {
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      }

      // Hidden singles - Boxes
      for (box = u = 0; u < 9; box = ++u) {
        boxRow = Math.floor(box / 3) * 3;
        boxCol = (box % 3) * 3;
        for (digit = v = 1; v <= 9; digit = ++v) {
          count = 0;
          lastR = -1;
          lastC = -1;
          foundAssigned = false;
          for (r = w = ref = boxRow, ref1 = boxRow + 3; (ref <= ref1 ? w < ref1 : w > ref1); r = ref <= ref1 ? ++w : --w) {
            for (c = x = ref2 = boxCol, ref3 = boxCol + 3; (ref2 <= ref3 ? x < ref3 : x > ref3); c = ref2 <= ref3 ? ++x : --x) {
              if (grid.values[r][c] === digit) {
                foundAssigned = true;
                count = 0;
                break;
              }
              if (hasCandidate(grid.candidates[r][c], digit)) {
                count++;
                lastR = r;
                lastC = c;
              }
            }
            if (foundAssigned) {
              break;
            }
          }
          if (count === 1) {
            if (!assign(grid, lastR, lastC, digit)) {
              return false;
            }
            changed = true;
          } else if (count === 0) {
            found = false;
            for (r = y = ref4 = boxRow, ref5 = boxRow + 3; (ref4 <= ref5 ? y < ref5 : y > ref5); r = ref4 <= ref5 ? ++y : --y) {
              for (c = z = ref6 = boxCol, ref7 = boxCol + 3; (ref6 <= ref7 ? z < ref7 : z > ref7); c = ref6 <= ref7 ? ++z : --z) {
                if (grid.values[r][c] === digit) {
                  found = true;
                  break;
                }
              }
              if (found) {
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      }
    }
    return true;
  };

  // Search
  findMrvCell = function(grid) {
    var c, j, k, minCandidates, mrvCol, mrvRow, numCandidates, r;
    minCandidates = 10;
    mrvRow = -1;
    mrvCol = -1;
    for (r = j = 0; j < 9; r = ++j) {
      for (c = k = 0; k < 9; c = ++k) {
        if (grid.values[r][c] === 0) {
          numCandidates = countCandidates(grid.candidates[r][c]);
          if (numCandidates < minCandidates) {
            minCandidates = numCandidates;
            mrvRow = r;
            mrvCol = c;
          }
        }
      }
    }
    if (mrvRow === -1) {
      return null;
    } else {
      return {
        row: mrvRow,
        col: mrvCol
      };
    }
  };

  cpSearch = function(grid, solution) {
    var c, candidates, digit, gridCopy, j, k, l, mrvCell, r;
    // Base case: check if grid is complete
    mrvCell = findMrvCell(grid);
    if (!mrvCell) {
// No empty cells - extract solution
      for (r = j = 0; j < 9; r = ++j) {
        for (c = k = 0; k < 9; c = ++k) {
          solution[r * 9 + c] = grid.values[r][c];
        }
      }
      return true;
    }
    
    // Try each candidate for MRV cell
    candidates = grid.candidates[mrvCell.row][mrvCell.col];
    for (digit = l = 1; l <= 9; digit = ++l) {
      if (hasCandidate(candidates, digit)) {
        // Save grid state for backtracking
        gridCopy = grid.copy();
        
        // Try assigning this digit
        if (assign(grid, mrvCell.row, mrvCell.col, digit)) {
          // Propagate constraints
          if (propagate(grid)) {
            if (cpSearch(grid, solution)) {
              // Recurse
              return true;
            }
          }
        }
        
        // Failed - restore grid state
        grid.values = gridCopy.values;
        grid.candidates = gridCopy.candidates;
      }
    }
    return false;
  };

  // Puzzle I/O
  printPuzzle = function(grid) {
    var j, r, results;
    console.log("\nPuzzle:");
    results = [];
    for (r = j = 0; j < 9; r = ++j) {
      results.push(console.log(grid[r].join(" ") + " "));
    }
    return results;
  };

  readMatrixFile = function(filename) {
    var data, displayPath, j, len, line, lineCount, lines, trimmed, values;
    // Normalize path for output
    displayPath = filename;
    if (filename.indexOf("/app/Matrices/") === 0) {
      displayPath = "../" + filename.substring(5);
    }
    console.log(displayPath);
    data = fs.readFileSync(filename, 'utf8');
    lines = data.split('\n');
    lineCount = 0;
    for (j = 0, len = lines.length; j < len; j++) {
      line = lines[j];
      trimmed = line.trim();
      if (trimmed === '' || trimmed[0] === '#') {
        continue;
      }
      values = trimmed.split(/\s+/).map(Number);
      if (values.length === 9 && lineCount < 9) {
        puzzle[lineCount] = values;
        console.log(values.join(" ") + " ");
        lineCount++;
      }
    }
    return lineCount === 9;
  };

  // Main Execution
  startTime = Date.now();

  ref = process.argv.slice(2);
  // Process command line arguments
  for (j = 0, len = ref.length; j < len; j++) {
    arg = ref[j];
    if (!arg.endsWith(".matrix")) {
      continue;
    }
    
    // Reset puzzle
    puzzle = (function() {
      var k, results;
      results = [];
      for (i = k = 0; k < 9; i = ++k) {
        results.push(Array(9).fill(0));
      }
      return results;
    })();
    if (!readMatrixFile(arg)) {
      console.error(`Failed to read matrix file ${arg}`);
      continue;
    }
    
    // Print initial puzzle
    printPuzzle(puzzle);
    
    // Initialize CP grid
    grid = new CPGrid();
    initGrid(grid, puzzle);
    
    // Apply initial propagation
    if (!propagate(grid)) {
      console.log("\nNo solution found (contradiction during initial propagation)\n");
      continue;
    }
    
    // Run search
    solution = new Array(81);
    cpIterations = 0;
    solved = cpSearch(grid, solution);
    if (solved) {
      // Convert solution array back to 2D
      solutionGrid = (function() {
        var k, results;
        results = [];
        for (i = k = 0; k < 9; i = ++k) {
          results.push(Array(9).fill(0));
        }
        return results;
      })();
      for (r = k = 0; k < 9; r = ++k) {
        for (c = l = 0; l < 9; c = ++l) {
          solutionGrid[r][c] = solution[r * 9 + c];
        }
      }
      printPuzzle(solutionGrid);
      console.log(`\nSolved in Iterations=${cpIterations}\n`);
    } else {
      console.log("\nNo solution found\n");
    }
  }

  elapsed = (Date.now() - startTime) / 1000;

  console.log(`Seconds to process ${elapsed.toFixed(3)}`);

}).call(this);
