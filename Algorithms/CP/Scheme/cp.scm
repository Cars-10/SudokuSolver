#!/usr/bin/env guile
!#
;;; Sudoku CP Solver in GNU Guile (Scheme)  
;;; Note: Gets 84 iterations instead of target 67 due to propagation differences

(use-modules (ice-9 rdelim) (srfi srfi-1))

(define cp-iterations 0)

(define (make-grid)
  (let ((g (make-vector 2)))
    (vector-set! g 0 (make-vector 9))
    (vector-set! g 1 (make-vector 9))
    (do ((i 0 (+ i 1))) ((= i 9))
      (vector-set! (vector-ref g 0) i (make-vector 9 0))
      (vector-set! (vector-ref g 1) i (make-vector 9 0)))
    g))

(define (grid-vals g) (vector-ref g 0))
(define (grid-cands g) (vector-ref g 1))
(define (get-val g r c) (vector-ref (vector-ref (grid-vals g) r) c))
(define (set-val! g r c v) (vector-set! (vector-ref (grid-vals g) r) c v))
(define (get-cand g r c) (vector-ref (vector-ref (grid-cands g) r) c))
(define (set-cand! g r c v) (vector-set! (vector-ref (grid-cands g) r) c v))

(define (has-cand? set d) (not (= (logand set (ash 1 d)) 0)))
(define (rem-cand set d) (logand set (lognot (ash 1 d))))
(define (count-cands set)
  (do ((s set (ash s -1)) (cnt 0 (+ cnt (logand s 1)))) ((= s 0) cnt)))
(define (first-cand set)
  (do ((d 1 (+ d 1))) ((or (> d 9) (has-cand? set d)) (if (> d 9) 0 d))))

(define (copy-grid g)
  (let ((new-g (make-grid)))
    (do ((r 0 (+ r 1))) ((= r 9))
      (do ((c 0 (+ c 1))) ((= c 9))
        (set-val! new-g r c (get-val g r c))
        (set-cand! new-g r c (get-cand g r c))))
    new-g))

(define (init-grid! g puzzle)
  (do ((r 0 (+ r 1))) ((= r 9))
    (do ((c 0 (+ c 1))) ((= c 9))
      (let ((v (vector-ref (vector-ref puzzle r) c)))
        (if (= v 0)
            (begin (set-val! g r c 0) (set-cand! g r c #x3FE))
            (begin (set-val! g r c v) (set-cand! g r c (ash 1 v))))))))

(define (get-peers r c)
  (let ((peers '()))
    (do ((col 0 (+ col 1))) ((= col 9))
      (when (not (= col c)) (set! peers (cons (cons r col) peers))))
    (do ((row 0 (+ row 1))) ((= row 9))
      (when (not (= row r)) (set! peers (cons (cons row c) peers))))
    (let ((br (* (quotient r 3) 3)) (bc (* (quotient c 3) 3)))
      (do ((rr br (+ rr 1))) ((= rr (+ br 3)))
        (do ((cc bc (+ cc 1))) ((= cc (+ bc 3)))
          (when (and (not (= rr r)) (not (= cc c)))
            (set! peers (cons (cons rr cc) peers))))))
    peers))

(define (eliminate! g r c d)
  (if (not (has-cand? (get-cand g r c) d))
      #t
      (begin
        (set-cand! g r c (rem-cand (get-cand g r c) d))
        (let ((rem (count-cands (get-cand g r c))))
          (cond
            ((= rem 0) #f)
            ((and (= rem 1) (= (get-val g r c) 0))
             (assign! g r c (first-cand (get-cand g r c))))
            (else #t))))))

(define (assign! g r c d)
  (set! cp-iterations (+ cp-iterations 1))
  (set-val! g r c d)
  (set-cand! g r c (ash 1 d))
  (let loop ((peers (get-peers r c)))
    (if (null? peers)
        #t
        (let* ((p (car peers)) (pr (car p)) (pc (cdr p)))
          (if (eliminate! g pr pc d)
              (loop (cdr peers))
              #f)))))

(define (propagate! g)
  (let outer ((changed #t))
    (if (not changed)
        #t
        (begin
          (set! changed #f)
          (do ((row 0 (+ row 1))) ((= row 9))
            (do ((d 1 (+ d 1))) ((> d 9))
              (let ((cnt 0) (lcol -1) (assigned #f))
                (do ((col 0 (+ col 1))) ((= col 9))
                  (when (= (get-val g row col) d) (set! assigned #t))
                  (when (and (not assigned) (has-cand? (get-cand g row col) d))
                    (set! cnt (+ cnt 1)) (set! lcol col)))
                (when (and (not assigned) (= cnt 1))
                  (when (assign! g row lcol d) (set! changed #t))))))
          (do ((col 0 (+ col 1))) ((= col 9))
            (do ((d 1 (+ d 1))) ((> d 9))
              (let ((cnt 0) (lrow -1) (assigned #f))
                (do ((row 0 (+ row 1))) ((= row 9))
                  (when (= (get-val g row col) d) (set! assigned #t))
                  (when (and (not assigned) (has-cand? (get-cand g row col) d))
                    (set! cnt (+ cnt 1)) (set! lrow row)))
                (when (and (not assigned) (= cnt 1))
                  (when (assign! g lrow col d) (set! changed #t))))))
          (do ((box 0 (+ box 1))) ((= box 9))
            (let ((br (* (quotient box 3) 3)) (bc (* (modulo box 3) 3)))
              (do ((d 1 (+ d 1))) ((> d 9))
                (let ((cnt 0) (lr -1) (lc -1) (assigned #f))
                  (do ((r br (+ r 1))) ((or (= r (+ br 3)) assigned))
                    (do ((c bc (+ c 1))) ((or (= c (+ bc 3)) assigned))
                      (when (= (get-val g r c) d) (set! assigned #t))
                      (when (and (not assigned) (has-cand? (get-cand g r c) d))
                        (set! cnt (+ cnt 1)) (set! lr r) (set! lc c))))
                  (when (and (not assigned) (= cnt 1))
                    (when (assign! g lr lc d) (set! changed #t)))))))
          (outer changed)))))

(define (find-mrv g)
  (let ((min-c 10) (best-r -1) (best-c -1))
    (do ((r 0 (+ r 1))) ((= r 9))
      (do ((c 0 (+ c 1))) ((= c 9))
        (when (= (get-val g r c) 0)
          (let ((nc (count-cands (get-cand g r c))))
            (when (< nc min-c) (set! min-c nc) (set! best-r r) (set! best-c c))))))
    (if (= best-r -1) #f (cons best-r best-c))))

(define (cp-search! g)
  (let ((mrv (find-mrv g)))
    (if (not mrv) g
        (let ((r (car mrv)) (c (cdr mrv)) (cands (get-cand g r c)))
          (let try ((d 1))
            (cond
              ((> d 9) #f)
              ((has-cand? cands d)
               (let ((g-copy (copy-grid g)))
                 (if (and (assign! g r c d) (propagate! g))
                     (let ((res (cp-search! g)))
                       (if res res (begin (set! g (copy-grid g-copy)) (try (+ d 1)))))
                     (begin (set! g (copy-grid g-copy)) (try (+ d 1))))))
              (else (try (+ d 1)))))))))

(define (read-puzzle fname)
  (let ((puz (make-vector 9)))
    (do ((i 0 (+ i 1))) ((= i 9)) (vector-set! puz i (make-vector 9 0)))
    (if (string-prefix? "/app/Matrices/" fname)
        (display (string-append "../Matrices/" (substring fname 14) "\n"))
        (display (string-append fname "\n")))
    (call-with-input-file fname
      (lambda (port)
        (let row-loop ((row 0))
          (when (< row 9)
            (let ((line (read-line port)))
              (if (eof-object? line) #t
                  (let ((trimmed (string-trim-both line)))
                    (cond
                      ((or (string-null? trimmed) (char=? (string-ref trimmed 0) #\#))
                       (row-loop row))
                      (else
                       (let ((nums (filter (lambda (s) (not (string-null? s)))
                                          (string-split trimmed #\space))))
                         (let col-loop ((ns nums) (col 0))
                           (when (and (< col 9) (pair? ns))
                             (let ((n (string->number (car ns))))
                               (vector-set! (vector-ref puz row) col n)
                               (display n) (display " ")
                               (col-loop (cdr ns) (+ col 1)))))
                         (newline) (row-loop (+ row 1))))))))))))
    puz))

(define (print-grid g)
  (display "\nPuzzle:\n")
  (do ((r 0 (+ r 1))) ((= r 9))
    (do ((c 0 (+ c 1))) ((= c 9))
      (display (get-val g r c)) (display " "))
    (newline)))

(let ((args (command-line)))
  (if (< (length args) 2)
      (begin (display "Usage: guile cp.scm <matrix_file>\n" (current-error-port)) (exit 1))
      (let process ((i 1))
        (when (< i (length args))
          (let ((fname (list-ref args i)))
            (when (string-suffix? ".matrix" fname)
              (set! cp-iterations 0)
              (let* ((puz (read-puzzle fname)) (g (make-grid)))
                (init-grid! g puz)
                (print-grid g)
                (do ((r 0 (+ r 1))) ((= r 9))
                  (do ((c 0 (+ c 1))) ((= c 9))
                    (when (> (get-val g r c) 0) (assign! g r c (get-val g r c)))))
                (if (propagate! g)
                    (let ((sol (cp-search! g)))
                      (if sol
                          (begin (print-grid sol)
                                 (display "\nSolved in Iterations=")
                                 (display cp-iterations)
                                 (display "\n\n"))
                          (display "\nNo solution\n")))
                    (display "\nContradiction\n")))))
          (process (+ i 1))))))
