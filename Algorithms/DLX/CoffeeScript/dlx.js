// Generated by CoffeeScript 2.7.0
(function() {
  //!/usr/bin/env coffee
  // DLX (Dancing Links) Sudoku Solver - CoffeeScript Implementation
  // Direct port of JavaScript implementation using Algorithm X with Dancing Links
  var DlxColumn, DlxNode, addNode, arg, buildDlxMatrixFromPuzzle, buildDlxRow, chooseColumn, columns, coverClues, coverColumn, dlxIterations, dlxSearch, elapsed, extractSolution, fs, getBoxCol, getColCol, getPositionCol, getRowCol, i, initDlxMatrix, j, len, printPuzzle, puzzle, readMatrixFile, ref, result, root, rowInfo, rowStarts, solution, solutionGrid, startTime, uncoverColumn;

  fs = require('fs');

  // Data Structures
  DlxNode = class DlxNode {
    constructor() {
      this.left = null;
      this.right = null;
      this.up = null;
      this.down = null;
      this.column = null;
      this.rowId = -1;
    }

  };

  DlxColumn = class DlxColumn {
    constructor(name) {
      this.node = new DlxNode();
      this.size = 0;
      this.name = name || "";
      
      // Initialize column node as circular list
      this.node.left = this.node;
      this.node.right = this.node;
      this.node.up = this.node;
      this.node.down = this.node;
      this.node.column = this;
    }

  };

  // Global State
  dlxIterations = 0;

  puzzle = (function() {
    var j, results;
    results = [];
    for (i = j = 0; j < 9; i = ++j) {
      results.push(Array(9).fill(0));
    }
    return results;
  })();

  solutionGrid = (function() {
    var j, results;
    results = [];
    for (i = j = 0; j < 9; i = ++j) {
      results.push(Array(9).fill(0));
    }
    return results;
  })();

  // DLX matrix structures
  root = null;

  columns = [];

  rowInfo = [];

  rowStarts = [];

  // Constraint Column Indices
  getPositionCol = function(r, c) {
    return r * 9 + c;
  };

  getRowCol = function(r, n) {
    return 81 + r * 9 + (n - 1);
  };

  getColCol = function(c, n) {
    return 162 + c * 9 + (n - 1);
  };

  getBoxCol = function(r, c, n) {
    var box;
    box = Math.floor(r / 3) * 3 + Math.floor(c / 3);
    return 243 + box * 9 + (n - 1);
  };

  // DLX Core Operations
  coverColumn = function(c) {
    var colNode, results, rightNode, rowNode;
    colNode = c.node;
    
    // Remove column header from the header list
    colNode.right.left = colNode.left;
    colNode.left.right = colNode.right;
    
    // For each row in this column
    rowNode = colNode.down;
    results = [];
    while (rowNode !== colNode) {
      // For each node in this row
      rightNode = rowNode.right;
      while (rightNode !== rowNode) {
        // Remove this node from its column
        rightNode.down.up = rightNode.up;
        rightNode.up.down = rightNode.down;
        rightNode.column.size--;
        rightNode = rightNode.right;
      }
      results.push(rowNode = rowNode.down);
    }
    return results;
  };

  uncoverColumn = function(c) {
    var colNode, leftNode, rowNode;
    colNode = c.node;
    
    // For each row in this column (in reverse order)
    rowNode = colNode.up;
    while (rowNode !== colNode) {
      // For each node in this row (in reverse order)
      leftNode = rowNode.left;
      while (leftNode !== rowNode) {
        // Restore this node to its column
        leftNode.column.size++;
        leftNode.down.up = leftNode;
        leftNode.up.down = leftNode;
        leftNode = leftNode.left;
      }
      rowNode = rowNode.up;
    }
    
    // Restore column header to the header list
    colNode.right.left = colNode;
    return colNode.left.right = colNode;
  };

  chooseColumn = function() {
    var best, colNode, minSize, rootNode;
    rootNode = root.node;
    best = null;
    minSize = Number.MAX_SAFE_INTEGER;
    colNode = rootNode.right;
    while (colNode !== rootNode) {
      if (colNode.column.size < minSize) {
        minSize = colNode.column.size;
        best = colNode.column;
      }
      colNode = colNode.right;
    }
    return best;
  };

  dlxSearch = function(k, solution) {
    var col, leftNode, rightNode, rootNode, rowNode;
    dlxIterations++;
    rootNode = root.node;
    if (rootNode.right === rootNode) {
      
      // If matrix is empty, we found a solution
      return true;
    }
    
    // Choose column with minimum size
    col = chooseColumn();
    if (col.size === 0) {
      
      // If column has no rows, no solution possible
      return false;
    }
    
    // Cover this column
    coverColumn(col);
    
    // Try each row in this column
    rowNode = col.node.down;
    while (rowNode !== col.node) {
      // Add row to partial solution
      solution[k] = rowNode.rowId;
      
      // Cover all other columns in this row
      rightNode = rowNode.right;
      while (rightNode !== rowNode) {
        coverColumn(rightNode.column);
        rightNode = rightNode.right;
      }
      if (dlxSearch(k + 1, solution)) {
        
        // Recurse
        return true;
      }
      
      // Backtrack: uncover all columns in this row
      leftNode = rowNode.left;
      while (leftNode !== rowNode) {
        uncoverColumn(leftNode.column);
        leftNode = leftNode.left;
      }
      rowNode = rowNode.down;
    }
    
    // Uncover column
    uncoverColumn(col);
    return false;
  };

  // DLX Matrix Construction
  initDlxMatrix = function() {
    var col, j;
    // Create root column
    root = new DlxColumn("root");
    
    // Create 324 column headers
    columns = [];
    for (i = j = 0; j < 324; i = ++j) {
      col = new DlxColumn(`C${i}`);
      
      // Link into header list
      col.node.left = root.node.left;
      col.node.right = root.node;
      root.node.left.right = col.node;
      root.node.left = col.node;
      columns.push(col);
    }
    rowInfo = [];
    return rowStarts = [];
  };

  addNode = function(col, rowId) {
    var node;
    node = new DlxNode();
    node.column = col;
    node.rowId = rowId;
    
    // Insert at end of column's circular list
    node.down = col.node;
    node.up = col.node.up;
    col.node.up.down = node;
    col.node.up = node;
    col.size++;
    return node;
  };

  buildDlxRow = function(r, c, n, rowId) {
    var n1, n2, n3, n4;
    // Store row metadata
    rowInfo[rowId] = {
      row: r,
      col: c,
      num: n
    };
    
    // Create nodes for the 4 constraints
    n1 = addNode(columns[getPositionCol(r, c)], rowId);
    n2 = addNode(columns[getRowCol(r, n)], rowId);
    n3 = addNode(columns[getColCol(c, n)], rowId);
    n4 = addNode(columns[getBoxCol(r, c, n)], rowId);
    
    // Link nodes horizontally in circular list
    n1.right = n2;
    n2.right = n3;
    n3.right = n4;
    n4.right = n1;
    n1.left = n4;
    n2.left = n1;
    n3.left = n2;
    n4.left = n3;
    
    // Store first node for this row
    return rowStarts[rowId] = n1;
  };

  buildDlxMatrixFromPuzzle = function() {
    var c, j, n, r, results, rowId;
    rowId = 0;
    results = [];
    for (r = j = 0; j < 9; r = ++j) {
      results.push((function() {
        var l, results1;
        results1 = [];
        for (c = l = 0; l < 9; c = ++l) {
          if (puzzle[r][c] !== 0) {
            // Cell has a clue - create only one row
            results1.push(buildDlxRow(r, c, puzzle[r][c], rowId++));
          } else {
            results1.push((function() {
              var m, results2;
// Cell is empty - create rows for all possible values
              results2 = [];
              for (n = m = 1; m <= 9; n = ++m) {
                results2.push(buildDlxRow(r, c, n, rowId++));
              }
              return results2;
            })());
          }
        }
        return results1;
      })());
    }
    return results;
  };

  coverClues = function() {
    var c, curr, j, n, node, r, results, rowId;
    results = [];
    for (r = j = 0; j < 9; r = ++j) {
      results.push((function() {
        var l, results1;
        results1 = [];
        for (c = l = 0; l < 9; c = ++l) {
          if (puzzle[r][c] !== 0) {
            n = puzzle[r][c];
            results1.push((function() {
              var m, ref, results2;

              // Find the row for this clue
              results2 = [];
              for (rowId = m = 0, ref = rowStarts.length; (0 <= ref ? m < ref : m > ref); rowId = 0 <= ref ? ++m : --m) {
                if (rowStarts[rowId] && rowInfo[rowId].row === r && rowInfo[rowId].col === c && rowInfo[rowId].num === n) {
                  
                  // Cover all columns in this row
                  node = rowStarts[rowId];
                  curr = node;
                  while (true) {
                    coverColumn(curr.column);
                    curr = curr.right;
                    if (curr === node) {
                      break;
                    }
                  }
                  break;
                } else {
                  results2.push(void 0);
                }
              }
              return results2;
            })());
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      })());
    }
    return results;
  };

  extractSolution = function(solution, solutionLen) {
    var c, j, l, m, r, ref, results, rowId;
// Initialize solution grid with original puzzle
    for (r = j = 0; j < 9; r = ++j) {
      for (c = l = 0; l < 9; c = ++l) {
        solutionGrid[r][c] = puzzle[r][c];
      }
    }

    // Each solution entry is a row_id
    results = [];
    for (i = m = 0, ref = solutionLen; (0 <= ref ? m < ref : m > ref); i = 0 <= ref ? ++m : --m) {
      rowId = solution[i];
      if (rowId >= 0 && rowId < 729 && rowInfo[rowId]) {
        results.push(solutionGrid[rowInfo[rowId].row][rowInfo[rowId].col] = rowInfo[rowId].num);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  // Puzzle I/O
  printPuzzle = function(grid) {
    var j, r, results;
    console.log("\nPuzzle:");
    results = [];
    for (r = j = 0; j < 9; r = ++j) {
      results.push(console.log(grid[r].join(" ") + " "));
    }
    return results;
  };

  readMatrixFile = function(filename) {
    var data, displayPath, j, len, line, lineCount, lines, trimmed, values;
    // Normalize path for output
    displayPath = filename;
    if (filename.indexOf("/app/Matrices/") === 0) {
      displayPath = "../" + filename.substring(5);
    }
    console.log(displayPath);
    data = fs.readFileSync(filename, 'utf8');
    lines = data.split('\n');
    lineCount = 0;
    for (j = 0, len = lines.length; j < len; j++) {
      line = lines[j];
      trimmed = line.trim();
      if (trimmed === '' || trimmed[0] === '#') {
        // Skip comments and empty lines
        continue;
      }
      
      // Parse 9 integers from line
      values = trimmed.split(/\s+/).map(Number);
      if (values.length === 9 && lineCount < 9) {
        puzzle[lineCount] = values;
        console.log(values.join(" ") + " ");
        lineCount++;
      }
    }
    return lineCount === 9;
  };

  // Main Execution
  startTime = Date.now();

  ref = process.argv.slice(2);
  // Process command line arguments
  for (j = 0, len = ref.length; j < len; j++) {
    arg = ref[j];
    if (!arg.endsWith(".matrix")) {
      continue;
    }
    
    // Reset puzzle
    puzzle = (function() {
      var l, results;
      results = [];
      for (i = l = 0; l < 9; i = ++l) {
        results.push(Array(9).fill(0));
      }
      return results;
    })();
    solutionGrid = (function() {
      var l, results;
      results = [];
      for (i = l = 0; l < 9; i = ++l) {
        results.push(Array(9).fill(0));
      }
      return results;
    })();
    if (!readMatrixFile(arg)) {
      console.error(`Error reading ${arg}`);
      continue;
    }
    printPuzzle(puzzle);
    
    // Initialize DLX matrix
    initDlxMatrix();
    
    // Build matrix from puzzle
    buildDlxMatrixFromPuzzle();
    
    // Cover pre-filled clues
    coverClues();
    
    // Solve using DLX
    dlxIterations = 0;
    solution = new Array(81);
    result = dlxSearch(0, solution);
    if (result) {
      extractSolution(solution, 81);
      printPuzzle(solutionGrid);
      console.log(`\nSolved in Iterations=${dlxIterations}\n`);
    } else {
      console.log("\nNo solution found\n");
    }
  }

  elapsed = (Date.now() - startTime) / 1000;

  console.log(`Seconds to process ${elapsed.toFixed(3)}`);

}).call(this);
