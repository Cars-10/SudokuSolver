(defpackage :sudoku
  (:use :cl))
(in-package :sudoku)

(defparameter *puzzle* (make-array '(9 9) :element-type 'integer :initial-element 0))
(defparameter *count* 0)

(defun print-puzzle ()
  (format t "~%Puzzle:~%")
  (dotimes (r 9)
    (dotimes (c 9)
      (format t "~d " (aref *puzzle* r c)))
    (format t "~%")))

(defun read-matrix-file (filename)
  (format t "~a~%" filename)
  (with-open-file (stream filename)
    (loop for line = (read-line stream nil)
          with row = 0
          while (and line (< row 9))
          do (unless (or (string= line "") (char= (char line 0) #\#))
               (let ((parts (uiop:split-string line :separator " ")))
                 (let ((valid-parts (remove-if (lambda (s) (string= s "")) parts)))
                   (when (= (length valid-parts) 9)
                     (dotimes (col 9)
                       (setf (aref *puzzle* row col) (parse-integer (nth col valid-parts))))
                     (incf row))))))))

(defun is-possible (r c val)
  (dotimes (i 9)
    (when (= (aref *puzzle* i c) val) (return-from is-possible nil))
    (when (= (aref *puzzle* r i) val) (return-from is-possible nil)))
  
  (let ((r0 (* (floor r 3) 3))
        (c0 (* (floor c 3) 3)))
    (dotimes (i 3)
      (dotimes (j 3)
        (when (= (aref *puzzle* (+ r0 i) (+ c0 j)) val)
          (return-from is-possible nil)))))
  t)

(defun solve ()
  (dotimes (r 9)
    (dotimes (c 9)
      (when (= (aref *puzzle* r c) 0)
        (loop for val from 1 to 9 do
          (incf *count*)
          (when (is-possible r c val)
            (setf (aref *puzzle* r c) val)
            (if (solve) (return-from solve t))
            (setf (aref *puzzle* r c) 0)))
        (return-from solve nil))))
  (print-puzzle)
  (format t "~%Solved in Iterations=~d~%~%" *count*)
  t)

(defun main ()
  (let ((args (uiop:command-line-arguments))
        (start (get-internal-real-time)))
    (dolist (arg args)
      (when (search ".matrix" arg)
        (read-matrix-file arg)
        (print-puzzle)
        (setf *count* 0)
        (solve)))
    (let ((end (get-internal-real-time)))
      (format t "Seconds to process ~,3f~%" (/ (- end start) internal-time-units-per-second)))))

(main)
