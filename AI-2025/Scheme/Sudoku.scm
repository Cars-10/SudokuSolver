(use-modules (ice-9 rdelim) (ice-9 format) (srfi srfi-1) (srfi srfi-13))

(define puzzle (make-array 0 9 9))
(define count 0)

(define (print-puzzle)
  (display "\nPuzzle:\n")
  (do ((r 0 (+ r 1))) ((= r 9))
    (do ((c 0 (+ c 1))) ((= c 9))
      (display (array-ref puzzle r c))
      (display " "))
    (newline)))

(define (read-matrix-file filename)
  (display filename) (newline)
  (let ((port (open-input-file filename)))
    (let loop ((r 0))
      (if (< r 9)
          (let ((line (read-line port)))
            (if (eof-object? line)
                (close-port port)
                (if (or (string-prefix? "#" line) (string-null? line))
                    (loop r)
                    (let ((parts (string-split line #\space)))
                      (let ((valid-parts (filter (lambda (s) (not (string-null? s))) parts)))
                        (if (= (length valid-parts) 9)
                            (begin
                              (do ((c 0 (+ c 1))) ((= c 9))
                                (array-set! puzzle (string->number (list-ref valid-parts c)) r c))
                              (loop (+ r 1)))
                            (loop r)))))))))))

(define (is-possible r c val)
  (let loop ((i 0))
    (if (< i 9)
        (if (or (= (array-ref puzzle i c) val)
                (= (array-ref puzzle r i) val))
            #f
            (loop (+ i 1)))
        (let ((r0 (* (quotient r 3) 3))
              (c0 (* (quotient c 3) 3)))
          (let loop-box ((i 0))
            (if (< i 3)
                (let loop-inner ((j 0))
                  (if (< j 3)
                      (if (= (array-ref puzzle (+ r0 i) (+ c0 j)) val)
                          #f
                          (loop-inner (+ j 1)))
                      (loop-box (+ i 1))))
                #t))))))

(define (solve)
  (let loop-r ((r 0))
    (if (< r 9)
        (let loop-c ((c 0))
          (if (< c 9)
              (if (= (array-ref puzzle r c) 0)
                  (let loop-val ((val 1))
                    (if (<= val 9)
                        (begin
                          (set! count (+ count 1))
                          (if (is-possible r c val)
                              (begin
                                (array-set! puzzle val r c)
                                (if (solve)
                                    #t
                                    (begin
                                      (array-set! puzzle 0 r c)
                                      (loop-val (+ val 1)))))
                              (loop-val (+ val 1))))
                        #f))
                  (loop-c (+ c 1)))
              (loop-r (+ r 1))))
        (begin
          (print-puzzle)
          (format #t "\nSolved in Iterations=~d\n\n" count)
          #t))))

(define (main args)
  (let ((start (get-internal-real-time)))
    (for-each (lambda (arg)
                (if (string-suffix? ".matrix" arg)
                    (begin
                      (read-matrix-file arg)
                      (print-puzzle)
                      (set! count 0)
                      (solve))))
              args)
    (let ((end (get-internal-real-time)))
      (format #t "Seconds to process ~,3f\n" (/ (- end start) 1.0 internal-time-units-per-second)))))

(main (cdr (command-line)))
