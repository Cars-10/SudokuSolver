---
phase: 03-algorithm-cp
plan: 02
type: execute
depends_on: ["03-01"]
files_modified: [Algorithms/CP/C/cp.h, Algorithms/CP/C/cp_core.c, Algorithms/CP/C/cp_sudoku.c, Algorithms/CP/C/runMe.sh]
---

<objective>
Implement complete Constraint Propagation algorithm with backtracking search for Sudoku.

Purpose: Transform the scaffolding from Plan 1 into a fully functional CP solver that uses constraint propagation (singleton elimination and hidden singles) combined with backtracking search to solve Sudoku puzzles efficiently.
Output: Working CP solver integrated with benchmark system, producing metrics.json with iteration counts.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-algorithm-cp/03-01-SUMMARY.md
@Algorithms/CP/C/cp.h
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp_sudoku.c
@Algorithms/DLX/C/dlx_sudoku.c

**Tech stack available:** C compiler, Bash, Python timing, common.sh
**Established patterns:**
- Iteration counting on every assignment attempt
- Standard output format with puzzle display and timing
- Matrix file I/O (space-separated digits, 0 = empty)
- Integration with runMeGlobal.sh via runMe.sh

**Constraining decisions:**
- [Phase 2]: Iteration counting = search metric for benchmarking
- [Phase 2]: Output format must match project standard
- [Discovery]: CP uses two propagation strategies: singleton elimination + hidden singles

**CP Algorithm Implementation Guide:**

**Data Structures** (from Plan 1):
- CPGrid with values[9][9] (assigned digits) and candidates[9][9] (bitsets)
- Bitset operations via macros (HAS_CANDIDATE, REMOVE_CANDIDATE, etc.)

**Core Algorithm Flow**:
1. **Initialization**: Set all empty cells to candidates 1-9, given clues to single value
2. **Propagate**: Apply constraints until fixpoint:
   - Singleton elimination: If cell has one candidate, assign it and eliminate from peers
   - Hidden singles: If unit has one location for a digit, assign it
3. **Search**: If propagation incomplete, use backtracking:
   - Select cell with minimum remaining values (MRV heuristic)
   - Try each candidate, propagate, recurse
   - Undo on contradiction (backtrack)
4. **Iteration counting**: Increment on every assignment attempt (like brute-force)

**Key Differences from DLX**:
- DLX uses exact cover matrix (324 columns, complex linking)
- CP uses candidate elimination (simpler, more intuitive)
- DLX iteration = search calls; CP iteration = assignment attempts
- CP expected to have fewer iterations than brute-force but more than DLX

**References:**
- Norvig's Sudoku solver: https://norvig.com/sudoku.html
- DLX implementation pattern: Algorithms/DLX/C/dlx_sudoku.c
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement constraint propagation core</name>
  <files>Algorithms/CP/C/cp_core.c</files>
  <action>
Implement the core constraint propagation functions:

**1. init_grid(CPGrid *grid, int puzzle[9][9])**:
- Copy puzzle values to grid->values
- For empty cells (value == 0): Set candidates to 0x1FF (all 9 bits = digits 1-9)
- For given clues: Set candidates to single bit (1 << digit)
- This establishes the initial constraint state

**2. eliminate(CPGrid *grid, int row, int col, int digit)**:
- Remove digit from candidates[row][col] using REMOVE_CANDIDATE macro
- If candidates becomes empty (0x0), return 0 (contradiction)
- If candidates becomes singleton (count == 1), trigger assignment propagation
- Return 1 on success

**3. assign(CPGrid *grid, int row, int col, int digit)**:
- Increment cp_iterations (this is our benchmark metric)
- Set grid->values[row][col] = digit
- Set grid->candidates[row][col] to single bit (1 << digit)
- Eliminate digit from all peers (20 cells: same row, column, and 3x3 box)
- For each peer: call eliminate(grid, peer_row, peer_col, digit)
- If any elimination returns 0, return 0 (contradiction)
- Return 1 on success

**4. propagate(CPGrid *grid)**:
- Loop until fixpoint (no changes made):
  - **Singleton elimination**: For each cell with 1 candidate, assign it
  - **Hidden singles**: For each unit (row/col/box), for each digit, if only one cell can hold it, assign it
- Return 0 if any assignment causes contradiction, 1 otherwise
- This implements the two main CP strategies from discovery

**Helper functions to add**:
- `int count_candidates(CandidateSet cs)` - Use __builtin_popcount
- `int get_first_candidate(CandidateSet cs)` - Return first set bit (digit)
- `int* get_peers(int row, int col)` - Return array of 20 peer coordinates

**Critical**: Propagation must reach fixpoint before search. This is what makes CP efficient - most puzzles are solved by propagation alone, requiring minimal backtracking.
  </action>
  <verify>gcc -c Algorithms/CP/C/cp_core.c && grep -q "cp_iterations++" Algorithms/CP/C/cp_core.c</verify>
  <done>propagate() and assign() implemented, iteration counting in place, contradiction handling correct</done>
</task>

<task type="auto">
  <name>Task 2: Implement backtracking search with MRV</name>
  <files>Algorithms/CP/C/cp_core.c</files>
  <action>
Implement the search functions:

**1. find_mrv_cell(CPGrid *grid, int *out_row, int *out_col)**:
- Scan grid->values for empty cells (value == 0)
- Track cell with minimum candidate count (use COUNT_CANDIDATES macro)
- Set *out_row and *out_col to that cell's coordinates
- Return 0 if no empty cells (grid complete), 1 if cell found
- **MRV heuristic**: Choosing cells with fewer candidates reduces branching factor

**2. cp_search(CPGrid *grid, int *solution)**:
- **Base case**: If find_mrv_cell returns 0, copy grid->values to solution[81] and return 1 (solved)
- **Recursive case**:
  - Find MRV cell (row, col)
  - Get its candidates bitset
  - For each candidate digit (1-9):
    - If HAS_CANDIDATE(candidates, digit):
      - Make a copy of grid (save state for backtracking)
      - Call assign(grid, row, col, digit)
      - If assign succeeds, call propagate(grid)
      - If propagate succeeds, recurse: cp_search(grid, solution)
      - If recursion returns 1, return 1 (solved)
      - Otherwise restore grid from copy (backtrack)
  - If all candidates exhausted, return 0 (dead end)

**Backtracking implementation**:
- Use a simple `CPGrid grid_copy` and `memcpy(&grid_copy, grid, sizeof(CPGrid))` before each attempt
- On failure, `memcpy(grid, &grid_copy, sizeof(CPGrid))` to restore

This is the classic DFS with constraint propagation pattern - propagate as much as possible, backtrack when stuck.
  </action>
  <verify>grep -q "find_mrv_cell" Algorithms/CP/C/cp_core.c && grep -q "cp_search" Algorithms/CP/C/cp_core.c</verify>
  <done>Search functions implemented, MRV heuristic working, backtracking with state restoration correct</done>
</task>

<task type="auto">
  <name>Task 3: Implement puzzle I/O and main orchestration</name>
  <files>Algorithms/CP/C/cp_sudoku.c</files>
  <action>
Implement the puzzle I/O and main function (adapt from Algorithms/DLX/C/dlx_sudoku.c):

**1. readMatrixFile(const char *filename, int puzzle[9][9])**:
- Open file, read 9 lines of 9 space-separated integers
- Store in puzzle array
- Return 0 on error, 1 on success
- Handle missing files gracefully with error message
- **Reuse exact pattern from DLX** - this is proven code

**2. printPuzzle(int puzzle[9][9])**:
- Print 9 rows of 9 digits, space-separated
- Match the project's standard output format
- **Reuse exact pattern from DLX**

**3. main(int argc, char *argv[])**:
- Parse args: require exactly 1 argument (matrix file path)
- Call readMatrixFile(argv[1], puzzle)
- Print input puzzle: `printf("Puzzle:\n"); printPuzzle(puzzle);`
- Initialize CPGrid: `CPGrid grid; init_grid(&grid, puzzle);`
- Run propagate: `propagate(&grid);`
- Run search: `int solution[81]; int solved = cp_search(&grid, solution);`
- If solved:
  - Print solution puzzle
  - Print iteration count: `printf("Solved in Iterations=%lld\n", cp_iterations);`
- If not solved: `printf("No solution found\n");`
- Return 0 on success

**Output format must match**:
```
Puzzle:
[9 rows of initial state]

Puzzle:
[9 rows of solution]

Solved in Iterations=NNN
```

This format is required for common.sh to parse results correctly.
  </action>
  <verify>gcc Algorithms/CP/C/cp_sudoku.c Algorithms/CP/C/cp_core.c -o Algorithms/CP/C/cp_solver</verify>
  <done>I/O implemented, main() orchestrates init→propagate→search, output format matches standard</done>
</task>

<task type="auto">
  <name>Task 4: Test and debug with Matrix 1</name>
  <files>None (testing only)</files>
  <action>
Run the solver on the simplest puzzle to validate correctness:

```bash
./runMeGlobal.sh C 1 CP
```

**Expected behavior**:
1. Compilation succeeds (runMe.sh calls compile())
2. Solver runs without crashing
3. Puzzle is solved correctly (verify solution is valid)
4. Iteration count is printed
5. metrics.json is generated

**If solver fails or crashes**:
- Add debug prints to trace execution
- Check for segfaults (likely cause: array bounds, uninitialized memory)
- Verify propagation fixpoint is reached
- Verify backtracking state restoration works
- Use gdb if needed: `gdb Algorithms/CP/C/cp_solver`

**If iteration count seems wrong**:
- Verify cp_iterations++ happens on every assign() call
- Compare to brute-force count (656 for Matrix 1)
- CP should be lower than brute-force but higher than DLX (43)

**If solution is incorrect**:
- Verify constraint propagation eliminates correctly
- Check peer calculation (20 peers per cell)
- Verify hidden singles detection in propagate()

Fix all bugs until Matrix 1 solves correctly. This is the blocker for success criteria.
  </action>
  <verify>./runMeGlobal.sh C 1 CP && cat Algorithms/CP/C/metrics.json | jq '.results[0].passed'</verify>
  <done>Matrix 1 solves correctly, iteration count stable, metrics.json generated, no crashes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All core functions implemented (propagate, assign, eliminate, search)
- [ ] Puzzle I/O works correctly
- [ ] `./runMeGlobal.sh C 1 CP` succeeds
- [ ] Solution for Matrix 1 is correct
- [ ] Iteration count is printed and reasonable
- [ ] metrics.json is generated
- [ ] No compiler warnings or runtime errors
</verification>

<success_criteria>

- All 4 tasks completed
- All verification checks pass
- CP solver works end-to-end
- Integrated with benchmark infrastructure
- Ready for multi-matrix benchmarking
  </success_criteria>

<output>
After completion, create `.planning/phases/03-algorithm-cp/03-02-SUMMARY.md`:

# Phase 3 Plan 2: CP Algorithm Implementation Summary

**[Substantive one-liner - what was built]**

## Performance

- **Duration:** [X] min
- **Started:** [timestamp]
- **Completed:** [timestamp]
- **Tasks:** 4

## Accomplishments

- Implemented constraint propagation (singleton elimination + hidden singles)
- Implemented backtracking search with MRV heuristic
- Integrated puzzle I/O and main orchestration
- Validated on Matrix 1 with correct solution

## Task Commits

1. **Task 1: Core propagation** - [commit] (feat)
2. **Task 2: Search with MRV** - [commit] (feat)
3. **Task 3: I/O and main** - [commit] (feat)
4. **Task 4: Testing/debugging** - [commits if bugs found] (fix)

**Plan metadata:** (this commit)

## Files Created/Modified

- `Algorithms/CP/C/cp_core.c` - Full implementation of propagate/assign/eliminate/search
- `Algorithms/CP/C/cp_sudoku.c` - Complete I/O and main orchestration
- `Algorithms/CP/C/cp.h` - Minor updates if needed

## Decisions Made

- [Iteration counting placement]
- [Backtracking strategy]
- [Any other implementation choices]

## Issues Encountered

[Problems found during testing and how they were resolved, or "None"]

## Deviations from Plan

[Any auto-fixes applied during implementation, or "None"]

## Verification Results

**Test**: `./runMeGlobal.sh C 1 CP`

**Results**:
- Compilation: SUCCESS
- Execution: SUCCESS
- Matrix 1 solved: [YES/NO]
- Iterations: [count]
- Output format: [CORRECT/INCORRECT]
- Metrics generation: [SUCCESS/FAILURE]

## Next Phase Readiness

Phase 3 complete. CP solver is:
- Fully implemented with constraint propagation + backtracking
- Integrated with benchmark system
- Ready for multi-matrix benchmarking
- Comparable to BruteForce and DLX implementations

**Comparison to other algorithms** (after full benchmarking):
- BruteForce (Matrix 1): 656 iterations
- DLX (Matrix 1): 43 iterations
- CP (Matrix 1): [actual count] iterations

CP demonstrates the power of constraint propagation - significantly fewer iterations than brute-force while maintaining straightforward implementation.
</output>
