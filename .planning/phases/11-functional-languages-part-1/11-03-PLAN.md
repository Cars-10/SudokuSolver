---
phase: 11-functional-languages-part-1
plan: 03
type: execute
depends_on: []
files_modified: [Algorithms/DLX/F_Sharp/dlx.fs, Algorithms/DLX/F_Sharp/runMe.sh, Algorithms/CP/F_Sharp/cp.fs, Algorithms/CP/F_Sharp/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for F# using mutable record fields and .NET arrays.

Purpose: Port Dancing Links and Constraint Propagation from C to F#, leveraging .NET integration and F# mutable features.
Output: Working DLX and CP implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-functional-languages-part-1/11-RESEARCH.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/F_Sharp/Sudoku.fs

**Tech stack available:** F# compiler (dotnet fsi/fsc), mutable record fields, .NET arrays, ref cells
**Established patterns:** Mechanical C translation, iteration count verification
**Research findings:** Use mutable record fields for nodes, .Value property for refs (not deprecated ! operator), Array2D for 2D arrays
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in F# with mutable record fields</name>
  <files>Algorithms/DLX/F_Sharp/dlx.fs, Algorithms/DLX/F_Sharp/runMe.sh</files>
  <action>
Create Algorithms/DLX/F_Sharp/ directory. Port DLX from C to F#:

**dlx.fs structure**:
- Type definitions:
  - `type DlxNode = { mutable Left: DlxNode; mutable Right: DlxNode; mutable Up: DlxNode; mutable Down: DlxNode; mutable Column: DlxNode; mutable Size: int; RowId: int; ColId: int }`
  - Circular references work naturally with mutable fields
- Implement `coverColumn` and `uncoverColumn` with field mutation
- Implement `search` with Algorithm X recursion
- Build exact cover matrix (324 columns)
- Parse .matrix file and create constraint rows
- Global iteration counter: `let mutable dlxIterations = 0` incremented at start of search
- Main: `[<EntryPoint>]` with args processing

**Critical requirements**:
- Use `<-` for mutable field assignment: `node.Left <- newLeft`
- F# 6.0+: Use `.Value` for ref cells, NOT `!` operator (deprecated)
- Print output: puzzle, then "Solved in Iterations=43"
- Same exact cover mapping: row*81 + col*9 + digit
- **Avoid**: Don't use F# 5.0 or earlier ref syntax (`!` and `:=`). Use `.Value` property. Don't use immutable records.

**runMe.sh**:
- Set LANGUAGE="F_Sharp", SOLVER_BINARY="./dlx", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain dotnet; dotnet fsc -o dlx dlx.fs || fsc -o dlx dlx.fs`
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/F_Sharp && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX F# implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in F# with Array2D and mutable state</name>
  <files>Algorithms/CP/F_Sharp/cp.fs, Algorithms/CP/F_Sharp/runMe.sh</files>
  <action>
Create Algorithms/CP/F_Sharp/ directory. Port CP from C to F#:

**cp.fs structure**:
- Type definitions:
  - Grid: `let grid = Array2D.zeroCreate<int> 9 9` (mutable 2D array)
  - Candidates: `let candidates = Array2D.create 9 9 0` (bitsets as ints)
- Bitset helpers:
  - `let hasCandidate (set: int) (digit: int) = (set &&& (1 <<< digit)) <> 0`
  - `let removeCandidate (set: int) (digit: int) = set &&& ~~~(1 <<< digit)`
  - `let countCandidates (set: int) = ...` (popcount using recursion)
- Implement `initGrid`, `assign`, `eliminate`, `propagate`
- Implement `findMRVCell` returning option type
- Implement `cpSearch` with recursive backtracking (use Array2D.copy for backtracking)
- Global iteration counter: `let mutable cpIterations = 0` incremented at start of cpSearch
- Main: `[<EntryPoint>]` with args processing

**Critical requirements**:
- Array2D access: `grid.[r, c]` (comma syntax, not dot)
- Array2D assignment: `grid.[r, c] <- value`
- Bitset operations: `&&&` (and), `|||` (or), `<<<` (shift left), `~~~` (not)
- Bitset initial: 0x1FF (511)
- Propagate: singleton elimination, hidden singles, MRV
- Output: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't use `grid.(r).(c)` OCaml syntax. Use `grid.[r, c]` F# syntax.

**runMe.sh**:
- Set LANGUAGE="F_Sharp", SOLVER_BINARY="./cp", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain dotnet; dotnet fsc -o cp cp.fs || fsc -o cp cp.fs`
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/F_Sharp && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP F# implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] DLX F# shows exactly 43 iterations for Matrix 1
- [ ] CP F# shows exactly 67 iterations for Matrix 1
- [ ] Both compile without errors or warnings
- [ ] Both produce correctly solved puzzles
- [ ] metrics.json files exist for both
- [ ] Modern F# syntax used (.Value not !)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match C reference exactly
- Both implementations integrated into benchmark system
- Plan 11-03 complete
</success_criteria>

<output>
After completion, create `.planning/phases/11-functional-languages-part-1/11-03-SUMMARY.md`:

# Phase 11 Plan 3: F# Algorithms Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [DLX implementation details]
- [CP implementation details]

## Files Created/Modified

- `Algorithms/DLX/F_Sharp/dlx.fs` - Description
- `Algorithms/DLX/F_Sharp/runMe.sh` - Description
- `Algorithms/CP/F_Sharp/cp.fs` - Description
- `Algorithms/CP/F_Sharp/runMe.sh` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for parallel execution with other Phase 11 plans
</output>
