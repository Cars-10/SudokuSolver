---
phase: 11-functional-languages-part-1
plan: 02
type: execute
depends_on: []
files_modified: [Algorithms/DLX/OCaml/dlx.ml, Algorithms/DLX/OCaml/runMe.sh, Algorithms/CP/OCaml/cp.ml, Algorithms/CP/OCaml/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for OCaml using refs and mutable record fields.

Purpose: Port Dancing Links and Constraint Propagation from C to OCaml, demonstrating straightforward translation using OCaml's imperative features.
Output: Working DLX and CP implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-functional-languages-part-1/11-RESEARCH.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/dp_core.c
@Algorithms/BruteForce/OCaml/Sudoku.ml

**Tech stack available:** OCaml compiler (ocamlopt), refs, mutable record fields, arrays
**Established patterns:** Mechanical C translation, iteration count verification
**Research findings:** OCaml provides the most straightforward C translation - use mutable record fields for nodes, refs where needed
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in OCaml with mutable record fields</name>
  <files>Algorithms/DLX/OCaml/dlx.ml, Algorithms/DLX/OCaml/runMe.sh</files>
  <action>
Create Algorithms/DLX/OCaml/ directory. Port DLX from C to OCaml:

**dlx.ml structure**:
- Type definitions:
  - `type dlx_node = { mutable left: dlx_node; mutable right: dlx_node; mutable up: dlx_node; mutable down: dlx_node; mutable column: dlx_node; mutable size: int; row_id: int; col_id: int }`
  - Circular references handled naturally with mutable fields
- Implement `cover_column` and `uncover_column` with direct field mutation
- Implement `search` with Algorithm X recursion
- Build exact cover matrix (324 columns for Sudoku)
- Parse .matrix file and create constraint rows
- Global iteration counter: `let dlx_iterations = ref 0` incremented at start of search
- Main: iterate over command-line args, solve each .matrix file

**Critical requirements**:
- Use `<-` for mutable field assignment: `node.left <- new_left`
- Use `!` for ref dereference, `:=` for ref assignment
- Print output: puzzle, then "Solved in Iterations=43"
- Same exact cover mapping: row*81 + col*9 + digit
- **Avoid**: Don't use immutable records with {node with left = ...} (creates copies). Use mutable fields.

**runMe.sh**:
- Set LANGUAGE="OCaml", SOLVER_BINARY="./dlx", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain ocamlopt; ocamlopt -o dlx dlx.ml`
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/OCaml && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX OCaml implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in OCaml with arrays and refs</name>
  <files>Algorithms/CP/OCaml/cp.ml, Algorithms/CP/OCaml/runMe.sh</files>
  <action>
Create Algorithms/CP/OCaml/ directory. Port CP from C to OCaml:

**cp.ml structure**:
- Type definitions:
  - Grid: `let grid = Array.make_matrix 9 9 0` (mutable 2D array)
  - Candidates: `let candidates = Array.make_matrix 9 9 0` (bitsets as ints)
- Bitset helpers:
  - `let has_candidate set digit = (set land (1 lsl digit)) <> 0`
  - `let remove_candidate set digit = set land (lnot (1 lsl digit))`
  - `let count_candidates set = popcount set` (implement popcount with bit shifting)
- Implement `init_grid`, `assign`, `eliminate`, `propagate`
- Implement `find_mrv_cell` returning option type
- Implement `cp_search` with recursive backtracking (use Array.copy for grid copies)
- Global iteration counter: `let cp_iterations = ref 0` incremented at start of cp_search
- Main: iterate over args, solve each .matrix file

**Critical requirements**:
- Array access: `grid.(r).(c)` for 2D arrays
- Array assignment: `grid.(r).(c) <- value`
- Bitset initial value: 0x1FF (511) for digits 1-9
- Propagate: singleton elimination, hidden singles, MRV heuristic
- Output: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't use refs for grid cells (use arrays directly). Don't forget to copy arrays for backtracking.

**runMe.sh**:
- Set LANGUAGE="OCaml", SOLVER_BINARY="./cp", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain ocamlopt; ocamlopt -o cp cp.ml`
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/OCaml && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP OCaml implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] DLX OCaml shows exactly 43 iterations for Matrix 1
- [ ] CP OCaml shows exactly 67 iterations for Matrix 1
- [ ] Both compile without errors or warnings
- [ ] Both produce correctly solved puzzles
- [ ] metrics.json files exist for both
- [ ] Mutable patterns used correctly
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match C reference exactly
- Both implementations integrated into benchmark system
- Plan 11-02 complete
</success_criteria>

<output>
After completion, create `.planning/phases/11-functional-languages-part-1/11-02-SUMMARY.md`:

# Phase 11 Plan 2: OCaml Algorithms Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [DLX implementation details]
- [CP implementation details]

## Files Created/Modified

- `Algorithms/DLX/OCaml/dlx.ml` - Description
- `Algorithms/DLX/OCaml/runMe.sh` - Description
- `Algorithms/CP/OCaml/cp.ml` - Description
- `Algorithms/CP/OCaml/runMe.sh` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for parallel execution with other Phase 11 plans
</output>
