---
phase: 11-functional-languages-part-1
plan: 01
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Haskell/dlx.hs, Algorithms/DLX/Haskell/runMe.sh, Algorithms/CP/Haskell/cp.hs, Algorithms/CP/Haskell/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Haskell using ST monad for controlled mutation.

Purpose: Port Dancing Links and Constraint Propagation algorithms from C to Haskell, demonstrating functional implementation with mutable state encapsulation via ST monad.
Output: Working DLX and CP implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-functional-languages-part-1/11-RESEARCH.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Haskell/Sudoku.hs

**Tech stack available:** Haskell compiler (ghc), ST monad, STRef, MVector
**Established patterns:** Mechanical C translation using mutable features, iteration count verification
**Research findings:** Use ST monad with STRef for DLX nodes, index-based or two-phase construction for circular references
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Haskell using ST monad</name>
  <files>Algorithms/DLX/Haskell/dlx.hs, Algorithms/DLX/Haskell/runMe.sh</files>
  <action>
Create Algorithms/DLX/Haskell/ directory. Port DLX from C to Haskell:

**dlx.hs structure**:
- Use ST monad with STRef for controlled mutation
- Data type: `data DNode s = DNode { left, right, up, down, column :: STRef s (DNode s), size :: STRef s Int, rowId, colId :: Int }`
- Implement cover_column and uncover_column using STRef operations
- Implement search with Algorithm X recursion
- Build exact cover matrix for Sudoku (324 columns)
- Parse .matrix file and create constraint rows
- Global iteration counter using STRef, incremented at start of search
- Use index-based approach or two-phase construction to handle circular references (see RESEARCH.md Pattern 1)
- Main function: `main = do args <- getArgs; mapM_ solveFile (filter isMatrix args)` where `solveFile` uses `runST $ do { ... }`

**Critical requirements**:
- Use STRef operations: `newSTRef`, `readSTRef`, `writeSTRef`, `modifySTRef`
- Ensure STRef doesn't escape ST monad (only return pure Solution)
- Print output: puzzle, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + digit
- **Avoid**: Don't try to create circular structure directly (causes type errors). Use index-based approach with array of nodes, or two-phase construction (create nodes, then link).

**runMe.sh**:
- Set LANGUAGE="Haskell", SOLVER_BINARY="./dlx", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain ghc; ghc -O2 -o dlx dlx.hs`
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/Haskell && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX Haskell implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Haskell using ST monad with mutable arrays</name>
  <files>Algorithms/CP/Haskell/cp.hs, Algorithms/CP/Haskell/runMe.sh</files>
  <action>
Create Algorithms/CP/Haskell/ directory. Port CP from C to Haskell:

**cp.hs structure**:
- Use ST monad with STUArray for grid (mutable unboxed arrays)
- Data structures:
  - Grid: `STUArray s (Int, Int) Int` for cell values (9x9)
  - Candidates: `STUArray s (Int, Int) Int` for bitsets (9x9)
- Bitset helpers: `hasCandidate`, `removeCandidate`, `countCandidates` using Data.Bits operations
- Implement `initGrid`, `assign`, `eliminate`, `propagate` using ST + STUArray operations
- Implement `findMRVCell` to find cell with minimum remaining values
- Implement `cpSearch` with recursive backtracking
- Global iteration counter using STRef, incremented at start of cpSearch
- Main: `runST $ do { ... }` pattern, return pure result

**Critical requirements**:
- Import: `Control.Monad.ST`, `Data.Array.ST`, `Data.Bits`
- Bitset for candidates: Int (bits 1-9), initial value = 0x1FF (511)
- Propagate constraints: singleton elimination, hidden singles (rows/cols/boxes), MRV heuristic
- Output: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't use IORef (use STRef in ST monad). Don't use immutable arrays with copying (use STUArray for efficiency).

**runMe.sh**:
- Set LANGUAGE="Haskell", SOLVER_BINARY="./cp", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain ghc; ghc -O2 -o cp cp.hs`
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/Haskell && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP Haskell implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] DLX Haskell shows exactly 43 iterations for Matrix 1
- [ ] CP Haskell shows exactly 67 iterations for Matrix 1
- [ ] Both compile without errors or warnings
- [ ] Both produce correctly solved puzzles
- [ ] metrics.json files exist for both
- [ ] ST monad pattern used correctly (no STRef escape errors)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match C reference exactly
- Both implementations integrated into benchmark system
- Plan 11-01 complete
</success_criteria>

<output>
After completion, create `.planning/phases/11-functional-languages-part-1/11-01-SUMMARY.md`:

# Phase 11 Plan 1: Haskell Algorithms Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [DLX implementation details]
- [CP implementation details]

## Files Created/Modified

- `Algorithms/DLX/Haskell/dlx.hs` - Description
- `Algorithms/DLX/Haskell/runMe.sh` - Description
- `Algorithms/CP/Haskell/cp.hs` - Description
- `Algorithms/CP/Haskell/runMe.sh` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for parallel execution with other Phase 11 plans
</output>
