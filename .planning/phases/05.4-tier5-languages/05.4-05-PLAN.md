phase: 05.4-tier5-languages
plan: 05
type: execute
---

<objective>
Integrate and validate existing Assembly and EmacsLisp Sudoku solvers.

Purpose: Add low-level Assembly and classic Lisp (EmacsLisp) languages to the Tier 5 benchmark suite.
Output: Working Assembly and EmacsLisp solvers passing all 5 matrix validations with exact iteration counts.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Reference implementation:**
@Languages/C/Sudoku.c

**Existing implementations to be validated:**
@Languages/Assembly/Sudoku.asm
@Languages/EmacsLisp/sudoku.el

**Reference iteration counts:**
- Matrix 1: 656
- Matrix 2: 439,269
- Matrix 3: 98,847
- Matrix 4: 9,085
- Matrix 5: 445,778

**Language notes:**

**Assembly:**
- Requires `nasm` assembler and `ld` linker (from `build-essential`).
- We'll use x86_64 NASM syntax.
- Run with: `nasm -f elf64 Sudoku.asm && ld Sudoku.o -o sudoku && ./sudoku`

**EmacsLisp:**
- Requires `emacs` (non-interactive).
- Run with: `emacs -batch -l sudoku.el --eval '(sudoku-solve "path/to/matrix")'`

</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Assembly and EmacsLisp toolchains to Dockerfile</name>
  <files>server/Dockerfile</files>
  <action>
    1. Add NASM (for Assembly) language section (apt package):
       ```dockerfile
       # ----------------------------------------------------------------------------
       # 52. Assembly (NASM)
       # ----------------------------------------------------------------------------
       RUN apt-get update && apt-get install -y \
           nasm \
           && rm -rf /var/lib/apt/lists/*
       # nasm -v
       ```

    2. Add Emacs (for EmacsLisp) language section (apt package):
       ```dockerfile
       # ----------------------------------------------------------------------------
       # 53. EmacsLisp
       # ----------------------------------------------------------------------------
       RUN apt-get update && apt-get install -y \
           emacs-nox \
           && rm -rf /var/lib/apt/lists/*
       # emacs --version
       ```

    3. Rebuild Docker image:
       ```bash
       docker-compose down
       docker-compose build --no-cache app
       docker-compose up -d
       ```

    4. Verify the toolchains are installed.
  </action>
  <verify>
    docker exec sudokusolver-app-1 nasm -v && docker exec sudokusolver-app-1 emacs --version
  </verify>
  <done>Assembly and EmacsLisp toolchains available in Docker container</done>
</task>

<task type="auto">
  <name>Task 2: Implement and Validate Assembly solver</name>
  <files>Languages/Assembly/runMe.sh, Languages/Assembly/README.md</files>
  <action>
    1. Review `Languages/Assembly/Sudoku.asm` to ensure it follows the C algorithm.

    2. Create `runMe.sh` to compile and execute the solver:
       ```bash
       #!/bin/bash
       LANGUAGE="Assembly"
       source ../common.sh
       
       # Compile first
       nasm -f elf64 Sudoku.asm -o Sudoku.o
       ld Sudoku.o -o sudoku
       
       # Set the binary to be executed
       SOLVER_BINARY="./sudoku"

       # Main execution
       main "$@"
       ```

    3. Create `README.md` for the Assembly implementation.

    4. Run validation for all 5 matrices:
       ```bash
       cd Languages/Assembly && chmod +x runMe.sh
       for m in 1 2 3 4 5; do
           ./runMe.sh /app/Matrices/$m.matrix
       done
       ```
    5. Verify all iteration counts match.
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cd /app/Languages/Assembly && ./runMe.sh /app/Matrices/1.matrix" | grep "Iterations=656"
  </verify>
  <done>Assembly solver matches C reference for all 5 matrices</done>
</task>

<task type="auto">
  <name>Task 3: Implement and Validate EmacsLisp solver</name>
  <files>Languages/EmacsLisp/runMe.sh, Languages/EmacsLisp/README.md</files>
  <action>
    1. Review `Languages/EmacsLisp/sudoku.el` to ensure it follows the C algorithm.

    2. Create `runMe.sh` to execute the solver:
       ```bash
       #!/bin/bash
       LANGUAGE="EmacsLisp"
       source ../common.sh
       
       # Set the binary to be executed
       # Note the --eval argument to pass the matrix file to the script
       SOLVER_BINARY="emacs -batch -l sudoku.el --eval '(sudoku-solve \"$1\")'"

       # Main execution, but we need to handle the unquoted SOLVER_BINARY
       run_matrix_unquoted() {
           # ... (copy and modify run_matrix from common.sh if needed)
           # This is a bit tricky, might need a custom run script.
           # For now, let's try to make it work with a simple wrapper.
           echo "Running EmacsLisp solver on $1"
           emacs -batch -l sudoku.el --eval "(sudoku-solve \"$1\")"
       }

       # Since the command is complex, we'll call it directly
       run_benchmarks() {
            local matrices="$@"
            if [ -z "$matrices" ]; then
                matrices="../../Matrices/*.matrix"
            fi
            matrices=$(ls $matrices 2>/dev/null)
            
            for matrix in $matrices; do
                echo "Running EmacsLisp on $(basename $matrix)..." >&2
                (time emacs -batch -l sudoku.el --eval "(sudoku-solve \"$matrix\")") 2>> metrics.txt
            done
            # Process metrics.txt into metrics.json
       }

        main() {
            run_benchmarks "$@"
        }

        main "$@"

       ```
       **(Self-correction):** The `common.sh` script might struggle with the complex `emacs` command. I'll create a simple `runMe.sh` that calls `common.sh` but with a wrapper script to handle the command execution. Or, more simply, I will use a wrapper script as the `SOLVER_BINARY`.
       
       **Revised `runMe.sh`:**
       ```bash
        #!/bin/bash
        # Languages/EmacsLisp/runMe.sh
        
        LANGUAGE="EmacsLisp"
        
        # Create a wrapper script to be called by common.sh
        cat > run_emacs.sh << EOF
        #!/bin/bash
        emacs -batch -l sudoku.el --eval "(sudoku-solve \"$1\")"
        EOF
        chmod +x run_emacs.sh
        
        SOLVER_BINARY="./run_emacs.sh"
        
        source ../common.sh
        main "$@"

       ```

    3. Create `README.md` for the EmacsLisp implementation.
    
    4. Run validation for all 5 matrices:
       ```bash
       cd Languages/EmacsLisp && chmod +x runMe.sh
       for m in 1 2 3 4 5; do
           ./runMe.sh /app/Matrices/$m.matrix
       done
       ```
    5. Verify all iteration counts match.
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cd /app/Languages/EmacsLisp && ./runMe.sh /app/Matrices/1.matrix" | grep "Iterations=656"
  </verify>
  <done>EmacsLisp solver matches C reference for all 5 matrices</done>
</task>

<task type="auto">
  <name>Task 4: Finalize and Update State</name>
  <files>.planning/STATE.md</files>
  <action>
    1. If both languages are validated, update `STATE.md` to include them in the Tier 5 table.
    2. Update total language count.
    3. Regenerate benchmark report.
  </action>
  <verify>
    ls Languages/Assembly/metrics.json && ls Languages/EmacsLisp/metrics.json
  </verify>
  <done>STATE.md and benchmark report are updated with Assembly and EmacsLisp.</done>
</task>

</tasks>

<success_criteria>
- Assembly and EmacsLisp solvers are validated against all 5 matrices.
- Documentation for both languages is complete.
- The project state is updated to reflect their completion.
</success_criteria>

<output>
After completion, create `.planning/phases/05.4-tier5-languages/05.4-05-SUMMARY.md`
