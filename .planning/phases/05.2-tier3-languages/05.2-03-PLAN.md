---
phase: 05.2-tier3-languages
plan: 03
type: execute
---

<objective>
Implement Erlang and Scheme Sudoku solvers with exact algorithm match and C reference output format.

Purpose: Add concurrent functional and Lisp-family languages to the Tier 3 benchmark suite
Output: Working Erlang and Scheme solvers passing all 5 matrix validations with exact iteration counts
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Reference implementation:**
@Languages/C/Sudoku.c

**Existing code directories:**
@Languages/Erlang/
@Languages/Scheme/

**Reference iteration counts:**
- Matrix 1: 656
- Matrix 2: 439,269
- Matrix 3: 98,847
- Matrix 4: 9,085
- Matrix 5: 445,778

**Language notes:**
- Erlang: Functional, concurrent, uses escript for scripting, immutable data
- Scheme: Lisp dialect, uses S-expressions, supports mutation via set!
- Both have immutable-by-default semantics, need explicit mutable counter
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Erlang solver</name>
  <files>Languages/Erlang/Sudoku.erl, Languages/Erlang/runMe.sh, Languages/Erlang/README.md</files>
  <action>
    1. Create Sudoku.erl (as escript):
       - #!/usr/bin/env escript
       - Use process dictionary for mutable counter: put(count, 0), get(count)
       - Or use a simple recursive approach passing counter
       - -module(sudoku).
       - read_matrix(Filename) -> returns tuple-based grid
       - print_puzzle(Puzzle) -> io:format for each row
       - is_valid(Puzzle, Row, Col, Val) -> check constraints
       - solve(Puzzle, Count) ->
           find empty cell,
           lists:foldl for values 1-9:
             NewCount = Count + 1,
             case is_valid of true -> recurse; false -> continue
       - Use tuple for 9x9 grid: {{R0C0,R0C1,...},{R1C0,...},...}

    2. Erlang 0-based for consistency
       - element/2 is 1-based, so adjust accordingly

    3. Create runMe.sh:
       - LANGUAGE="Erlang"
       - No compilation needed (escript)
       - Run: escript Sudoku.erl "$matrix_file"
       - Source ../common.sh

    4. Create README.md
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cd /app/Languages/Erlang && escript Sudoku.erl ../../Matrices/1.matrix" | grep "Iterations=656"
  </verify>
  <done>Erlang solver matches C reference output format and iteration count (656)</done>
</task>

<task type="auto">
  <name>Task 2: Validate Erlang on all matrices</name>
  <files>Languages/Erlang/metrics.json</files>
  <action>
    1. Run Erlang solver on all 5 matrices in Docker
    2. Verify iteration counts match exactly
    3. Update README.md with validation results
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cat /app/Languages/Erlang/metrics.json" | grep -o '"iterations": [0-9]*' | head -5
  </verify>
  <done>Erlang validated on all 5 matrices</done>
</task>

<task type="auto">
  <name>Task 3: Implement Scheme solver</name>
  <files>Languages/Scheme/Sudoku.scm, Languages/Scheme/runMe.sh, Languages/Scheme/README.md</files>
  <action>
    1. Create Sudoku.scm (GNU Guile):
       - Use vector for puzzle: (make-vector 81 0) or nested vectors
       - (define count 0)
       - (define (read-matrix filename) ...)
       - (define (print-puzzle) ...)
       - (define (is-valid row col val) ...)
       - (define (solve)
           (let loop ((val 1))
             (when (<= val 9)
               (set! count (+ count 1))
               (if (is-valid row col val)
                   (begin ...)
                   (loop (+ val 1))))))
       - Print in exact C format

    2. Scheme uses 0-based indexing

    3. Create runMe.sh:
       - LANGUAGE="Scheme"
       - No compilation needed
       - Run: guile Sudoku.scm "$matrix_file"
       - Source ../common.sh

    4. Create README.md
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cd /app/Languages/Scheme && guile Sudoku.scm ../../Matrices/1.matrix" | grep "Iterations=656"
  </verify>
  <done>Scheme solver matches C reference for Matrix 1</done>
</task>

<task type="auto">
  <name>Task 4: Validate Scheme on all matrices</name>
  <files>Languages/Scheme/metrics.json</files>
  <action>
    1. Run Scheme solver on all 5 matrices
    2. Verify iteration counts match exactly
    3. Update README.md with validation results
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cat /app/Languages/Scheme/metrics.json" | grep -o '"iterations": [0-9]*' | head -5
  </verify>
  <done>Scheme validated on all 5 matrices</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Erlang solver matches C output format and all 5 iteration counts
- [ ] Scheme solver matches C output format and all 5 iteration counts
- [ ] Both metrics.json files populated
- [ ] Both README.md files document validation status
- [ ] Both runMe.sh scripts follow common.sh pattern
- [ ] Row-major iteration order verified in both languages
- [ ] Both tested in Docker container
</verification>

<success_criteria>
- Erlang and Scheme fully validated on all 5 matrices
- Both demonstrate functional programming with explicit mutation for counting
- Both use common.sh benchmark pattern
- Documentation complete
</success_criteria>

<output>
After completion, create `.planning/phases/05.2-tier3-languages/05.2-03-SUMMARY.md`
</output>
