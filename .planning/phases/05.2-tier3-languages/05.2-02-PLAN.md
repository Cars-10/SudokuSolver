---
phase: 05.2-tier3-languages
plan: 02
type: execute
---

<objective>
Implement Pascal and Prolog Sudoku solvers with exact algorithm match and C reference output format.

Purpose: Add classic compiled and logic programming languages to the Tier 3 benchmark suite
Output: Working Pascal and Prolog solvers passing all 5 matrix validations with exact iteration counts
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Reference implementation:**
@Languages/C/Sudoku.c

**Existing code directories:**
@Languages/Pascal/
@Languages/Prolog/

**Reference iteration counts:**
- Matrix 1: 656
- Matrix 2: 439,269
- Matrix 3: 98,847
- Matrix 4: 9,085
- Matrix 5: 445,778

**Language notes:**
- Pascal: Classic structured programming, strongly typed, uses arrays
- Prolog: Logic programming, uses backtracking natively (need explicit iteration counting)
- Pascal is compiled (fast), Prolog is interpreted (slower)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Pascal solver</name>
  <files>Languages/Pascal/Sudoku.pas, Languages/Pascal/runMe.sh, Languages/Pascal/README.md</files>
  <action>
    1. Create Sudoku.pas (Free Pascal):
       - program Sudoku;
       - var puzzle: array[0..8, 0..8] of Integer;
       - var count: Integer = 0;
       - procedure ReadMatrix(filename: String);
       - procedure PrintPuzzle;
       - function IsValid(row, col, val: Integer): Boolean;
       - function Solve: Boolean;
         for val := 1 to 9 do begin
           Inc(count);  { increment before validity check }
           if IsValid(row, col, val) then begin ... end;
         end;
       - Print in exact C format

    2. Pascal uses 0-based arrays (like C)
       - Box calculation: box_row := (row div 3) * 3

    3. Create runMe.sh:
       - LANGUAGE="Pascal"
       - COMPILE_CMD="fpc -O2 -o Sudoku Sudoku.pas"
       - SOLVER_BINARY="./Sudoku"
       - Source ../common.sh

    4. Create README.md
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cd /app/Languages/Pascal && fpc -O2 -o Sudoku Sudoku.pas 2>/dev/null && ./Sudoku ../../Matrices/1.matrix" | grep "Iterations=656"
  </verify>
  <done>Pascal solver matches C reference output format and iteration count (656)</done>
</task>

<task type="auto">
  <name>Task 2: Validate Pascal on all matrices</name>
  <files>Languages/Pascal/metrics.json</files>
  <action>
    1. Run Pascal solver on all 5 matrices in Docker
    2. Verify iteration counts match exactly
    3. Update README.md with validation results
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cat /app/Languages/Pascal/metrics.json" | grep -o '"iterations": [0-9]*' | head -5
  </verify>
  <done>Pascal validated on all 5 matrices</done>
</task>

<task type="auto">
  <name>Task 3: Implement Prolog solver</name>
  <files>Languages/Prolog/Sudoku.pl, Languages/Prolog/runMe.sh, Languages/Prolog/README.md</files>
  <action>
    1. Create Sudoku.pl (SWI-Prolog):
       - CRITICAL: Prolog has native backtracking, but we need EXPLICIT iteration counting
       - Use assertz/retract for mutable state (counter)
       - :- dynamic(count/1).
       - :- dynamic(puzzle/3).  % puzzle(Row, Col, Value)

       - read_matrix(File) - parse file into puzzle/3 facts
       - print_puzzle - iterate 0-8, 0-8 printing values
       - is_valid(Row, Col, Val) - check constraints
       - solve :-
           find empty cell,
           between(1, 9, Val),
           increment_count,  % retract(count(N)), N1 is N+1, assertz(count(N1))
           (is_valid(Row, Col, Val) ->
             assertz(puzzle(Row, Col, Val)),
             (solve -> true ; retract(puzzle(Row, Col, Val)), fail)
           ; fail).

       - Main entry point using command line args

    2. Prolog iteration order:
       - Find first empty cell scanning row-major (0-8, 0-8)
       - Try values 1-9 in order with between/3

    3. Create runMe.sh:
       - LANGUAGE="Prolog"
       - No compilation needed
       - Run: swipl -q -t main -s Sudoku.pl -- "$matrix_file"
       - Source ../common.sh

    4. Create README.md
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cd /app/Languages/Prolog && swipl -q -t main -s Sudoku.pl -- ../../Matrices/1.matrix" | grep "Iterations=656"
  </verify>
  <done>Prolog solver matches C reference for Matrix 1</done>
</task>

<task type="auto">
  <name>Task 4: Validate Prolog on all matrices</name>
  <files>Languages/Prolog/metrics.json</files>
  <action>
    1. Run Prolog solver on all 5 matrices
    2. Verify iteration counts match exactly
    3. Update README.md with validation results
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cat /app/Languages/Prolog/metrics.json" | grep -o '"iterations": [0-9]*' | head -5
  </verify>
  <done>Prolog validated on all 5 matrices</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Pascal solver matches C output format and all 5 iteration counts
- [ ] Prolog solver matches C output format and all 5 iteration counts
- [ ] Both metrics.json files populated
- [ ] Both README.md files document validation status
- [ ] Both runMe.sh scripts follow common.sh pattern
- [ ] Row-major iteration order verified in both languages
- [ ] Both tested in Docker container
</verification>

<success_criteria>
- Pascal and Prolog fully validated on all 5 matrices
- Prolog demonstrates explicit iteration counting despite native backtracking
- Both use common.sh benchmark pattern
- Documentation complete
</success_criteria>

<output>
After completion, create `.planning/phases/05.2-tier3-languages/05.2-02-SUMMARY.md`
</output>
