---
phase: 05.2-tier3-languages
plan: 04
type: execute
---

<objective>
Implement Common Lisp and Clojure Sudoku solvers with exact algorithm match and C reference output format.

Purpose: Add Lisp family languages to the Tier 3 benchmark suite
Output: Working Common Lisp and Clojure solvers passing all 5 matrix validations with exact iteration counts
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Reference implementation:**
@Languages/C/Sudoku.c

**Existing code directories:**
@Languages/CommonLisp/
@Languages/Clojure/

**Reference iteration counts:**
- Matrix 1: 656
- Matrix 2: 439,269
- Matrix 3: 98,847
- Matrix 4: 9,085
- Matrix 5: 445,778

**Language notes:**
- Common Lisp: Classic Lisp, powerful macro system, supports mutation
- Clojure: Modern JVM Lisp, immutable by default, uses atoms for state
- Both are interpreted/JIT, expect moderate performance
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Common Lisp solver</name>
  <files>Languages/CommonLisp/Sudoku.lisp, Languages/CommonLisp/runMe.sh, Languages/CommonLisp/README.md</files>
  <action>
    1. Create Sudoku.lisp (SBCL):
       - (defvar *puzzle* (make-array '(9 9) :initial-element 0))
       - (defvar *count* 0)
       - (defun read-matrix (filename) ...)
       - (defun print-puzzle () ...)
       - (defun is-valid (row col val) ...)
       - (defun solve ()
           (loop for val from 1 to 9 do
             (incf *count*)
             (when (is-valid row col val)
               ...)))
       - Print in exact C format using format directives

    2. Common Lisp uses 0-based array indexing

    3. Create runMe.sh:
       - LANGUAGE="CommonLisp"
       - No compilation needed (SBCL interprets)
       - Run: sbcl --script Sudoku.lisp "$matrix_file"
       - Source ../common.sh

    4. Create README.md
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cd /app/Languages/CommonLisp && sbcl --script Sudoku.lisp ../../Matrices/1.matrix" | grep "Iterations=656"
  </verify>
  <done>Common Lisp solver matches C reference output format and iteration count (656)</done>
</task>

<task type="auto">
  <name>Task 2: Validate Common Lisp on all matrices</name>
  <files>Languages/CommonLisp/metrics.json</files>
  <action>
    1. Run Common Lisp solver on all 5 matrices in Docker
    2. Verify iteration counts match exactly
    3. Update README.md with validation results
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cat /app/Languages/CommonLisp/metrics.json" | grep -o '"iterations": [0-9]*' | head -5
  </verify>
  <done>Common Lisp validated on all 5 matrices</done>
</task>

<task type="auto">
  <name>Task 3: Implement Clojure solver</name>
  <files>Languages/Clojure/Sudoku.clj, Languages/Clojure/runMe.sh, Languages/Clojure/README.md</files>
  <action>
    1. Create Sudoku.clj:
       - Use atom for mutable counter: (def count (atom 0))
       - Use vector of vectors for puzzle: [[0 0 ...] [0 0 ...] ...]
       - (defn read-matrix [filename] ...)
       - (defn print-puzzle [puzzle] ...)
       - (defn is-valid [puzzle row col val] ...)
       - (defn solve [puzzle]
           (loop [val 1]
             (when (<= val 9)
               (swap! count inc)
               (if (is-valid puzzle row col val)
                   ...
                   (recur (inc val))))))
       - Use assoc-in for immutable updates to puzzle

    2. Clojure uses 0-based indexing

    3. Create runMe.sh:
       - LANGUAGE="Clojure"
       - No compilation needed
       - Run: clojure -M Sudoku.clj "$matrix_file"
       - Source ../common.sh

    4. Create README.md
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cd /app/Languages/Clojure && clojure -M Sudoku.clj ../../Matrices/1.matrix" | grep "Iterations=656"
  </verify>
  <done>Clojure solver matches C reference for Matrix 1</done>
</task>

<task type="auto">
  <name>Task 4: Validate Clojure on all matrices</name>
  <files>Languages/Clojure/metrics.json</files>
  <action>
    1. Run Clojure solver on all 5 matrices
    2. Verify iteration counts match exactly
    3. Update README.md with validation results
  </action>
  <verify>
    docker exec sudokusolver-app-1 bash -c "cat /app/Languages/Clojure/metrics.json" | grep -o '"iterations": [0-9]*' | head -5
  </verify>
  <done>Clojure validated on all 5 matrices</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Common Lisp solver matches C output format and all 5 iteration counts
- [ ] Clojure solver matches C output format and all 5 iteration counts
- [ ] Both metrics.json files populated
- [ ] Both README.md files document validation status
- [ ] Both runMe.sh scripts follow common.sh pattern
- [ ] Row-major iteration order verified in both languages
- [ ] Both tested in Docker container
</verification>

<success_criteria>
- Common Lisp and Clojure fully validated on all 5 matrices
- Both demonstrate Lisp family characteristics with different mutation approaches
- Both use common.sh benchmark pattern
- Documentation complete
</success_criteria>

<output>
After completion, create `.planning/phases/05.2-tier3-languages/05.2-04-SUMMARY.md`
</output>
