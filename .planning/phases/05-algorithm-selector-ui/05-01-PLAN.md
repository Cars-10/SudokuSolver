---
phase: 05-algorithm-selector-ui
plan: 01
type: execute
depends_on: []
files_modified: [Metrics/HTMLGenerator.ts, Metrics/generate_report_only.ts]
---

<objective>
Add algorithm filtering UI to the benchmark report for BruteForce, DLX, and CP algorithms.

Purpose: Enable users to toggle between algorithm types to compare performance across different solving approaches.
Output: Interactive dropdown/toggle controls in report header that filter displayed languages by algorithm type, with all three algorithm types available.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Metrics/HTMLGenerator.ts
@Metrics/generate_report_only.ts
@Metrics/types.ts

**Tech stack available:**
- TypeScript (HTMLGenerator.ts, generate_report_only.ts)
- HTML/CSS (embedded in HTMLGenerator)
- JavaScript (client-side interaction in report_client.js)

**Established patterns:**
- Multi-algorithm directory structure: `Algorithms/BruteForce/`, `Algorithms/DLX/`, `Algorithms/CP/`
- Metrics collected from `metrics.json` files in each language directory
- Report generation via HTMLGenerator.ts
- Existing UI controls: variant selector dropdown, modal systems

**Constraining decisions:**
- Phase 4: All path references now use `Algorithms/[Type]/[Language]/` pattern
- v1.1: Three algorithm types implemented (BruteForce baseline, DLX, CP)
- Project aesthetic: Minimalist, clean UI with Tokyo Night color scheme

**Current state:**
- Report currently shows only BruteForce results
- No algorithm filtering UI exists
- DLX and CP metrics.json files exist but aren't displayed in report
- HTMLGenerator.ts loads metrics from `Algorithms/BruteForce/` only (line 108)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update metrics loading to include all algorithm types</name>
  <files>Metrics/generate_report_only.ts, Metrics/types.ts</files>
  <action>
Modify generate_report_only.ts to load metrics from all three algorithm directories:
- Scan `Algorithms/BruteForce/*/metrics.json`
- Scan `Algorithms/DLX/*/metrics.json`
- Scan `Algorithms/CP/*/metrics.json`

Add `algorithmType` field to SolverMetrics interface in types.ts:
```typescript
export interface SolverMetrics {
    language: string;
    algorithmType: 'BruteForce' | 'DLX' | 'CP';  // NEW FIELD
    results: MetricResult[];
    // ... existing fields
}
```

Update loading logic to:
1. Iterate through all three algorithm directories
2. For each metrics.json found, add `algorithmType` based on parent directory
3. Aggregate all metrics into single array passed to HTMLGenerator

**What to avoid and WHY:**
- Don't modify existing metrics.json files - add algorithmType during load time only
- Don't change iteration count comparison logic - each algorithm has different expected counts (BF:656, DLX:43, CP:67 for Matrix 1)
- Don't merge languages across algorithms - treat C/BruteForce and C/DLX as separate entries
  </action>
  <verify>
```bash
# Check types updated
grep "algorithmType" Metrics/types.ts

# Check loading updated
grep "Algorithms/DLX\|Algorithms/CP" Metrics/generate_report_only.ts

# Test generation
cd Metrics && npx ts-node generate_report_only.ts
# Should complete without errors
```
  </verify>
  <done>
- types.ts has algorithmType field in SolverMetrics
- generate_report_only.ts loads from all three algorithm directories
- Metrics array includes entries tagged with BruteForce, DLX, and CP
- Report generation succeeds without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add algorithm selector UI to report header</name>
  <files>Metrics/HTMLGenerator.ts</files>
  <action>
Add algorithm selector dropdown in HTMLGenerator.ts report header (near existing variant selector):

1. **HTML structure** (add after title, before language grid):
```html
<div class="algorithm-selector-container" style="margin: 20px 0; text-align: center;">
    <label for="algorithmSelector" style="color: #a9b1d6; margin-right: 10px; font-weight: bold;">Algorithm:</label>
    <select id="algorithmSelector" onchange="filterByAlgorithm(this.value)"
            style="padding: 8px 15px; background: #1a1b26; color: #c0caf5; border: 1px solid #414868; border-radius: 6px; font-size: 0.95em; cursor: pointer;">
        <option value="all">All Algorithms</option>
        <option value="BruteForce" selected>Brute Force (Baseline)</option>
        <option value="DLX">Dancing Links (Algorithm X)</option>
        <option value="CP">Constraint Propagation</option>
    </select>
    <span id="algorithmCount" style="margin-left: 15px; color: #565f89; font-size: 0.9em;"></span>
</div>
```

2. **Data attribute** (add algorithmType to each language card):
Modify language card generation to include:
```html
<div class="language-card" data-algorithm-type="${metrics.algorithmType}" ...>
```

3. **Filter function** (add to script section):
```javascript
window.filterByAlgorithm = function(algorithmType) {
    const cards = document.querySelectorAll('.language-card');
    let visibleCount = 0;

    cards.forEach(card => {
        const cardAlgo = card.getAttribute('data-algorithm-type');
        if (algorithmType === 'all' || cardAlgo === algorithmType) {
            card.style.display = 'block';
            visibleCount++;
        } else {
            card.style.display = 'none';
        }
    });

    // Update count display
    const countSpan = document.getElementById('algorithmCount');
    if (countSpan) {
        countSpan.textContent = `(${visibleCount} languages)`;
    }
};

// Initialize on load
document.addEventListener('DOMContentLoaded', () => {
    filterByAlgorithm('BruteForce'); // Default to BruteForce
});
```

**What to avoid and WHY:**
- Don't use radio buttons - dropdown is more compact and matches existing variant selector UI
- Don't filter server-side - client-side filtering allows instant switching without regeneration
- Don't modify logo loading logic - it already handles multiple algorithm directories
  </action>
  <verify>
```bash
# Generate report with new UI
cd Metrics && npx ts-node generate_report_only.ts

# Check report HTML has selector
grep "algorithmSelector" ../_report.html

# Check cards have data attribute
grep "data-algorithm-type" ../_report.html | head -5

# Manual test: Open _report.html in browser
# 1. Verify dropdown appears in header
# 2. Select "Brute Force" - should show only BruteForce languages
# 3. Select "Dancing Links" - should show only DLX languages
# 4. Select "Constraint Propagation" - should show only CP languages
# 5. Select "All Algorithms" - should show all languages
```
  </verify>
  <done>
- HTMLGenerator.ts has algorithm selector dropdown in header
- Language cards have data-algorithm-type attribute
- filterByAlgorithm() function implemented
- Dropdown defaults to "Brute Force (Baseline)"
- Selector filters language grid correctly for all three algorithm types
- Count display shows number of visible languages
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Algorithm selector dropdown with filtering for BruteForce, DLX, and CP</what-built>
  <how-to-verify>
1. Generate report: `cd Metrics && npx ts-node generate_report_only.ts`
2. Open `_report.html` in browser
3. Locate algorithm selector dropdown in header (below title, above language grid)
4. Test each option:
   - **Brute Force (Baseline)**: Should show languages with BruteForce implementations
   - **Dancing Links (Algorithm X)**: Should show only C (currently the only DLX implementation)
   - **Constraint Propagation**: Should show only C (currently the only CP implementation)
   - **All Algorithms**: Should show all unique language+algorithm combinations
5. Verify language count updates correctly
6. Verify filtering is instant (no page reload)
7. Verify UI matches Tokyo Night theme (dark background, blue accents)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `cd Metrics && npx ts-node generate_report_only.ts` succeeds without errors
- [ ] _report.html contains algorithm selector dropdown
- [ ] Language cards have data-algorithm-type attribute
- [ ] Filtering works for all three algorithm types
- [ ] UI is responsive and matches existing design patterns
</verification>

<success_criteria>

- All tasks completed
- types.ts has algorithmType field
- generate_report_only.ts loads from all three algorithm directories
- HTMLGenerator.ts renders algorithm selector UI
- Report filtering works correctly for BruteForce, DLX, CP, and "All"
- Manual verification passed
- No errors during report generation
  </success_criteria>

<output>
After completion, create `.planning/phases/05-algorithm-selector-ui/05-01-SUMMARY.md`:

# Phase 5 Plan 1: Algorithm Selector UI Summary

**Interactive algorithm filtering dropdown enabling comparison across BruteForce, DLX, and CP solving approaches**

## Accomplishments

- Extended metrics loading to include DLX and CP algorithm types
- Added algorithmType field to SolverMetrics interface
- Implemented algorithm selector dropdown in report header
- Client-side filtering for instant algorithm switching
- Count display showing number of visible languages per algorithm

## Files Created/Modified

- `Metrics/types.ts` - Added algorithmType field to SolverMetrics
- `Metrics/generate_report_only.ts` - Extended loading to scan all three algorithm directories
- `Metrics/HTMLGenerator.ts` - Added selector UI and filtering logic

## Decisions Made

- Client-side filtering: Instant switching without regeneration
- Dropdown format: Matches existing variant selector pattern
- Default to BruteForce: Maintains baseline focus while allowing comparison
- Treat language+algorithm as separate entries: C/BruteForce, C/DLX, C/CP as distinct

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 5 complete. Algorithm selector functional, ready for Phase 6: Core Performance Charts.

Enhanced reporting UI enables:
- Comparison across algorithm types
- Filtering by BruteForce (baseline), DLX (optimized), CP (constraint-based)
- Foundation for performance visualizations in Phase 6

---
*Phase: 05-algorithm-selector-ui*
*Completed: [date]*
</output>
