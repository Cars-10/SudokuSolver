---
phase: 13-systems-languages
plan: 03
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Zig/dlx.zig, Algorithms/DLX/Zig/runMe.sh, Algorithms/CP/Zig/cp.zig, Algorithms/CP/Zig/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Zig, leveraging Zig's explicit memory management and comptime features for efficient low-level programming.

Purpose: Extend the benchmark suite with Zig implementations of advanced algorithms, demonstrating Zig's modern approach to systems programming with manual memory control.
Output: Working DLX and CP Zig implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STRUCTURE.md

# Reference implementations
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Zig/Sudoku.zig

**Tech stack available**: Zig compiler (zig build-exe) with explicit allocators
**Established patterns**:
- DLX uses pointer-based circular doubly-linked lists with explicit allocation
- CP uses arrays/slices with u16 bitsets for candidates
- Target iteration counts: DLX=43, CP=67
- Zig requires explicit allocator usage (std.heap.page_allocator or arena)

**Key decisions from previous phases**:
- Use pointers (*DlxNode) for node references
- Use allocator.create() for node allocation
- Matrix 1 verification is mandatory
- Zig's explicit memory model requires careful allocator management
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Zig with explicit allocation</name>
  <files>Algorithms/DLX/Zig/dlx.zig, Algorithms/DLX/Zig/runMe.sh</files>
  <action>
Create Algorithms/DLX/Zig/ directory. Port DLX from C to Zig:

**dlx.zig structure**:
- Import: const std = @import("std");
- Struct DlxNode: const DlxNode = struct { left: ?*DlxNode, right: ?*DlxNode, up: ?*DlxNode, down: ?*DlxNode, column: ?*DlxNode, size: usize, row_id: i32, col_id: i32 };
- Global var dlx_iterations: usize = 0;
- Functions:
  - coverColumn(c: *DlxNode): remove column and rows
  - uncoverColumn(c: *DlxNode): restore column and rows
  - chooseColumn(root: *DlxNode) ?*DlxNode: find min size column
  - dlxSearch(root: *DlxNode, k: usize, solution: []i32) bool: Algorithm X
  - buildSudokuMatrix(allocator: std.mem.Allocator): create nodes
  - parseMatrixFile(allocator: std.mem.Allocator, filename: []const u8): read puzzle
- pub fn main() !void: setup allocator (std.heap.page_allocator or ArenaAllocator), solve, print
- Increment dlx_iterations at start of dlxSearch

**Critical requirements**:
- Use std.heap.page_allocator or std.heap.ArenaAllocator for memory
- Create nodes with allocator.create(DlxNode)
- Use ?*DlxNode for nullable pointers
- Dereference with .* when needed
- Print output: puzzle, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + (digit-1)
- **Avoid**: Don't forget to handle allocation errors with try/catch. Don't use undefined for pointers, use null.

**runMe.sh**:
- Set LANGUAGE="Zig", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain zig; zig build-exe -O ReleaseFast -femit-bin=dlx_solver dlx.zig`
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/Zig && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX Zig implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Zig with array-based grid</name>
  <files>Algorithms/CP/Zig/cp.zig, Algorithms/CP/Zig/runMe.sh</files>
  <action>
Create Algorithms/CP/Zig/ directory. Port CP from C to Zig:

**cp.zig structure**:
- Import: const std = @import("std");
- Type: const CandidateSet = u16;
- Struct CPGrid: const CPGrid = struct { values: [9][9]i32, candidates: [9][9]CandidateSet };
- Global var cp_iterations: i64 = 0;
- Helper functions:
  - hasCand(cs: CandidateSet, digit: i32) bool: (cs & (@as(u16, 1) << @intCast(digit))) != 0
  - countCand(cs: CandidateSet) usize: count bits with @popCount
  - getPeers(row: usize, col: usize) [20][2]usize: return peer coordinates
- Main functions:
  - initGrid(puzzle: [9][9]i32) CPGrid: set candidates to 0x3FE for empty
  - propagate(grid: *CPGrid, row: usize, col: usize, digit: i32) bool: eliminate from peers
  - assign(grid: *CPGrid, row: usize, col: usize, digit: i32) bool: place and propagate, increment cp_iterations
  - search(grid: *CPGrid) bool: find MRV cell, try digits 1-9
  - parseMatrixFile(allocator: std.mem.Allocator, filename: []const u8): read puzzle
- pub fn main() !void: setup allocator, solve, print result

**Critical requirements**:
- Use fixed-size arrays [9][9]i32 for grid (stack allocation)
- CandidateSet as u16 with bits 1-9 (bit 0 unused)
- Use @as(u16, 1) for bit shifts with explicit cast
- Use @intCast for integer conversions
- Iteration counting in assign() before propagation
- Deep copy grid for backtracking: grid.* for struct copy
- Print output: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't mix signed/unsigned without explicit cast. Use @intCast consistently.

**runMe.sh**:
- Set LANGUAGE="Zig", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain zig; zig build-exe -O ReleaseFast -femit-bin=cp_solver cp.zig`
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/Zig && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP Zig implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both DLX and CP Zig implementations compile without errors
- [ ] DLX produces exactly 43 iterations on Matrix 1
- [ ] CP produces exactly 67 iterations on Matrix 1
- [ ] Both metrics.json files created successfully
- [ ] Both implementations produce valid solved puzzles
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No compilation errors
- Iteration counts match reference implementations exactly
- Both algorithms fully functional
</success_criteria>

<output>
After completion, create `.planning/phases/13-systems-languages/13-03-SUMMARY.md`:

# Phase 13 Plan 3: Zig Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.zig` - Description
- `path/to/another.zig` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for next plan in Phase 13 (13-04: D Algorithms)
</output>
