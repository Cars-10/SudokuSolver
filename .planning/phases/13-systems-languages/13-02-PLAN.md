---
phase: 13-systems-languages
plan: 02
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Go/dlx.go, Algorithms/DLX/Go/runMe.sh, Algorithms/CP/Go/cp.go, Algorithms/CP/Go/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Go, leveraging Go's pointers and structs for efficient mutable data structures.

Purpose: Extend the benchmark suite with Go implementations of advanced algorithms, demonstrating Go's simplicity and performance for systems programming.
Output: Working DLX and CP Go implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STRUCTURE.md

# Reference implementations
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Go/Sudoku.go

**Tech stack available**: Go compiler (go build) with pointer-based structs
**Established patterns**:
- DLX uses pointer-based circular doubly-linked lists
- CP uses 2D slices with uint16 bitsets for candidates
- Target iteration counts: DLX=43, CP=67
- Go's pointers make DLX implementation straightforward (similar to C)

**Key decisions from previous phases**:
- Use pointer struct fields for DLX nodes (*DlxNode)
- Use [][]int and [][]uint16 for grid storage
- Matrix 1 verification is mandatory
- Go's garbage collector handles circular references automatically
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Go with pointer-based nodes</name>
  <files>Algorithms/DLX/Go/dlx.go, Algorithms/DLX/Go/runMe.sh</files>
  <action>
Create Algorithms/DLX/Go/ directory. Port DLX from C to Go:

**dlx.go structure**:
- Package main
- Struct DlxNode: type DlxNode struct { left, right, up, down, column *DlxNode; size, rowId, colId int }
- Global var dlxIterations int
- Functions:
  - coverColumn(c *DlxNode): remove column and rows from matrix
  - uncoverColumn(c *DlxNode): restore column and rows (exact reverse)
  - chooseColumn(root *DlxNode) *DlxNode: find column with min size
  - dlxSearch(root *DlxNode, k int, solution []int) bool: Algorithm X with backtracking
  - buildSudokuMatrix(): create 324 columns + constraint rows
  - parseMatrixFile(filename string) [][]int: read puzzle
- Main: parse args, solve puzzle, print result with iteration count
- Increment dlxIterations at start of dlxSearch (before base case check)

**Critical requirements**:
- Use pointers for all node references (*DlxNode)
- Initialize circular lists with root.left = root, root.right = root, etc.
- Print output: puzzle, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + (digit-1)
- **Avoid**: Don't use make() for fixed-size structs. Use new() or struct literals with &.

**runMe.sh**:
- Set LANGUAGE="Go", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain go; go build -o dlx_solver dlx.go`
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/Go && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX Go implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Go with slice-based grid</name>
  <files>Algorithms/CP/Go/cp.go, Algorithms/CP/Go/runMe.sh</files>
  <action>
Create Algorithms/CP/Go/ directory. Port CP from C to Go:

**cp.go structure**:
- Package main
- Type alias: type CandidateSet uint16
- Struct CPGrid: type CPGrid struct { values [][]int; candidates [][]CandidateSet }
- Global var cpIterations int64
- Helper functions:
  - hasCand(cs CandidateSet, digit int) bool: check bit (cs & (1 << digit)) != 0
  - countCand(cs CandidateSet) int: count set bits
  - getPeers(row, col int) [][2]int: return 20 peer coordinates
- Main functions:
  - initGrid(puzzle [][]int) *CPGrid: initialize candidates to 0x3FE for empty cells
  - propagate(grid *CPGrid, row, col, digit int) bool: eliminate from peers
  - assign(grid *CPGrid, row, col, digit int) bool: place and propagate, increment cpIterations
  - search(grid *CPGrid) bool: find MRV cell, try digits 1-9, backtrack
  - parseMatrixFile(filename string) [][]int
- Main: parse args, solve puzzle, print result with iteration count

**Critical requirements**:
- Use [][]int for values, [][]CandidateSet for candidates
- Initialize with make([][]int, 9) then make([]int, 9) for each row
- CandidateSet as uint16 with bits 1-9 (bit 0 unused)
- Iteration counting in assign() function before propagation
- Deep copy grid before backtracking: copy slices with copy() or make new grid
- Print output: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't share slice backing arrays. Always deep copy for backtracking.

**runMe.sh**:
- Set LANGUAGE="Go", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain go; go build -o cp_solver cp.go`
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/Go && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP Go implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both DLX and CP Go implementations compile without errors
- [ ] DLX produces exactly 43 iterations on Matrix 1
- [ ] CP produces exactly 67 iterations on Matrix 1
- [ ] Both metrics.json files created successfully
- [ ] Both implementations produce valid solved puzzles
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No compilation errors
- Iteration counts match reference implementations exactly
- Both algorithms fully functional
</success_criteria>

<output>
After completion, create `.planning/phases/13-systems-languages/13-02-SUMMARY.md`:

# Phase 13 Plan 2: Go Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.go` - Description
- `path/to/another.go` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for next plan in Phase 13 (13-03: Zig Algorithms)
</output>
