---
phase: 13-systems-languages
plan: 04
type: execute
depends_on: []
files_modified: [Algorithms/DLX/D/dlx.d, Algorithms/DLX/D/runMe.sh, Algorithms/CP/D/cp.d, Algorithms/CP/D/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for D, leveraging D's C-like syntax with modern features like classes and built-in arrays.

Purpose: Extend the benchmark suite with D implementations of advanced algorithms, demonstrating D's balance between low-level control and high-level abstractions.
Output: Working DLX and CP D implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STRUCTURE.md

# Reference implementations
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/D/Sudoku.d

**Tech stack available**: D compiler (dmd/ldc2) with classes and built-in dynamic arrays
**Established patterns**:
- DLX can use class-based nodes with references or C-style structs with pointers
- CP uses built-in arrays int[][] with ushort bitsets
- Target iteration counts: DLX=43, CP=67
- D's GC handles circular references, making DLX implementation straightforward

**Key decisions from previous phases**:
- Use class DlxNode with member references for circular lists
- Use int[][] and ushort[][] for grid storage
- Matrix 1 verification is mandatory
- D's syntax is very similar to C/C++ but with GC
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in D with class-based nodes</name>
  <files>Algorithms/DLX/D/dlx.d, Algorithms/DLX/D/runMe.sh</files>
  <action>
Create Algorithms/DLX/D/ directory. Port DLX from C to D:

**dlx.d structure**:
- Import: import std.stdio, std.algorithm, std.conv, std.file;
- Class DlxNode: class DlxNode { DlxNode left, right, up, down, column; int size, rowId, colId; }
- Global int dlxIterations = 0;
- Functions:
  - void coverColumn(DlxNode c): remove column and rows from matrix
  - void uncoverColumn(DlxNode c): restore column and rows
  - DlxNode chooseColumn(DlxNode root): find column with min size
  - bool dlxSearch(DlxNode root, int k, int[] solution): Algorithm X with backtracking
  - DlxNode buildSudokuMatrix(): create 324 columns + constraint rows
  - int[][] parseMatrixFile(string filename): read puzzle
- void main(string[] args): solve puzzle, print result with iteration count
- Increment dlxIterations at start of dlxSearch

**Critical requirements**:
- Use class references (no pointers needed, GC handles it)
- Initialize circular lists: root.left = root; root.right = root;
- Use new DlxNode() for allocation
- Print output: puzzle, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + (digit-1)
- **Avoid**: Don't use @nogc or manual memory management. Let GC work.

**runMe.sh**:
- Set LANGUAGE="D", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain dmd || check_toolchain ldc2; if command -v ldc2 >/dev/null 2>&1; then ldc2 -O3 -release -of=dlx_solver dlx.d; else dmd -O -release -of=dlx_solver dlx.d; fi`
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/D && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX D implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in D with dynamic array-based grid</name>
  <files>Algorithms/CP/D/cp.d, Algorithms/CP/D/runMe.sh</files>
  <action>
Create Algorithms/CP/D/ directory. Port CP from C to D:

**cp.d structure**:
- Import: import std.stdio, std.algorithm, std.conv, std.file, std.array;
- Type alias: alias CandidateSet = ushort;
- Struct CPGrid: struct CPGrid { int[][] values; ushort[][] candidates; }
- Global long cpIterations = 0;
- Helper functions:
  - bool hasCand(CandidateSet cs, int digit): (cs & (1 << digit)) != 0
  - int countCand(CandidateSet cs): count bits using loop or __builtin_popcount equivalent
  - int[2][] getPeers(int row, int col): return 20 peer coordinates as array
- Main functions:
  - CPGrid initGrid(int[][] puzzle): allocate and initialize candidates to 0x3FE for empty
  - bool propagate(ref CPGrid grid, int row, int col, int digit): eliminate from peers
  - bool assign(ref CPGrid grid, int row, int col, int digit): place and propagate, increment cpIterations
  - bool search(ref CPGrid grid): find MRV cell, try digits 1-9, backtrack
  - int[][] parseMatrixFile(string filename): read puzzle file
- void main(string[] args): solve puzzle, print result

**Critical requirements**:
- Use int[][] for values (dynamic array of arrays)
- Initialize with: values = new int[][](9, 9); or loop allocation
- CandidateSet as ushort with bits 1-9 (bit 0 unused)
- Use ref for grid parameter to avoid copying
- Iteration counting in assign() before propagation
- Deep copy grid for backtracking: use .dup for array slices
- Print output: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't shallow copy arrays. Use .dup or explicit deep copy.

**runMe.sh**:
- Set LANGUAGE="D", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain dmd || check_toolchain ldc2; if command -v ldc2 >/dev/null 2>&1; then ldc2 -O3 -release -of=cp_solver cp.d; else dmd -O -release -of=cp_solver cp.d; fi`
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/D && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP D implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both DLX and CP D implementations compile without errors
- [ ] DLX produces exactly 43 iterations on Matrix 1
- [ ] CP produces exactly 67 iterations on Matrix 1
- [ ] Both metrics.json files created successfully
- [ ] Both implementations produce valid solved puzzles
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No compilation errors
- Iteration counts match reference implementations exactly
- Both algorithms fully functional
</success_criteria>

<output>
After completion, create `.planning/phases/13-systems-languages/13-04-SUMMARY.md`:

# Phase 13 Plan 4: D Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.d` - Description
- `path/to/another.d` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for next plan in Phase 13 (13-05: Nim Algorithms)
</output>
