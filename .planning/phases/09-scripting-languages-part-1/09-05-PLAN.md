---
phase: 09-scripting-languages-part-1
plan: 05
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Perl/dlx.pl, Algorithms/DLX/Perl/runMe.sh, Algorithms/CP/Perl/cp.pl, Algorithms/CP/Perl/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Perl, completing Phase 9 scripting language algorithm coverage.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms from C reference to Perl, following established patterns. Perl's hash references provide flexible object-like structures for DLX nodes.
Output: Working DLX and CP implementations for Perl with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Perl/Sudoku.pl

**Tech stack available**: Perl (already present for BruteForce)
**Established patterns**: Mechanical translation from C, iteration count verification, runMe.sh integration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in Perl</name>
  <files>Algorithms/DLX/Perl/dlx.pl, Algorithms/DLX/Perl/runMe.sh</files>
  <action>
Create Algorithms/DLX/Perl/ directory structure. Port the DLX algorithm from C to Perl:

**dlx.pl structure**:
- Use hash references for DlxNode: {left => $ref, right => $ref, up => $ref, down => $ref, column => $ref, row_id => $num}
- Use hash references for DlxColumn: {node => $node_ref, size => $num, name => $str}
- Implement sub cover_column($c) - exact same logic as C (unlink column and all rows)
- Implement sub uncover_column($c) - exact reversal of cover operation
- Implement sub search($root, $k, $solution_ref) - recursive backtracking with Algorithm X
- Implement sub build_exact_cover_matrix() - create 324 columns for Sudoku constraints
- Implement sub parse_matrix($filename) - read .matrix file and create constraint rows
- Main execution that calls parse_matrix, search, and prints results
- Global $dlx_iterations counter incremented at start of search

**Critical requirements**:
- Use Perl's hash references as object-like structures (blessed hashes not required)
- Maintain circular doubly-linked list structure exactly as in C
- Print output format: puzzle state, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + digit
- File structure: all code in single dlx.pl file, executable via perl dlx.pl <matrix_file>
- Add shebang: #!/usr/bin/env perl
- Use strict and warnings: use strict; use warnings;

**runMe.sh**:
- Set LANGUAGE="Perl", SOLVER_BINARY="perl dlx.pl", METRICS_FILE="metrics.json"
- Source ../../common.sh
- No compile() function needed (interpreted language)
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Perl's array operations (@array shift/push) for node manipulation - need explicit hash reference pointer operations
- Do NOT use blessed objects unless it improves clarity - plain hash refs are fine
- Do NOT optimize the search order - must match C reference exactly
- Do NOT use Perl modules beyond core (no Moose, etc.) - keep it simple and portable
</action>
  <verify>cd Algorithms/DLX/Perl && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in Perl</name>
  <files>Algorithms/CP/Perl/cp.pl, Algorithms/CP/Perl/runMe.sh</files>
  <action>
Create Algorithms/CP/Perl/ directory structure. Port the CP algorithm from C to Perl:

**cp.pl structure**:
- Use hash reference for CPGrid: {values => [[...]], candidates => [[...]]} (2D arrays for bitsets)
- Define bitset helper subroutines:
  - sub has_candidate($set, $digit) - test bit
  - sub add_candidate($set, $digit) - set bit (returns new value)
  - sub remove_candidate($set, $digit) - clear bit (returns new value)
  - sub count_candidates($set) - popcount
- Implement sub init_grid($grid, $puzzle) - set empty cells to candidates = 0x1FF
- Implement sub assign($grid, $row, $col, $value) - place value and propagate constraints
- Implement sub eliminate($grid, $row, $col, $candidates_to_remove) - remove candidates and propagate
- Implement sub propagate($grid) - apply constraint propagation until quiescence
- Implement sub find_mrv_cell($grid) - find cell with Minimum Remaining Values (returns ($row, $col) or undef)
- Implement sub cp_search($grid) - recursive search with propagation
- Implement sub parse_matrix($filename) and main execution with global $cp_iterations counter
- Add shebang: #!/usr/bin/env perl
- Use strict and warnings: use strict; use warnings;

**Critical requirements**:
- Use Perl integers for bitsets (Perl handles arbitrary precision)
- Bitset operations: use bit shifting and masking (1 << $digit, $set & (1 << $digit))
- Print output format: puzzle state, then "Solved in Iterations=67"
- Increment $cp_iterations at start of cp_search
- Use custom popcount: sub popcount { my $n = shift; my $c = 0; while ($n) { $c += $n & 1; $n >>= 1; } return $c; }

**runMe.sh**:
- Set LANGUAGE="Perl", SOLVER_BINARY="perl cp.pl", METRICS_FILE="metrics.json"
- Source ../../common.sh
- No compile() function needed
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Perl hashes for candidates - must use bitsets (integers)
- Do NOT add extra constraint propagation techniques
- Do NOT change MRV selection order
- Do NOT use CPAN modules - keep implementation self-contained
</action>
  <verify>cd Algorithms/CP/Perl && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created, Phase 9 complete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] DLX Perl shows exactly 43 iterations for Matrix 1
- [ ] CP Perl shows exactly 67 iterations for Matrix 1
- [ ] Both produce correctly solved puzzles
- [ ] metrics.json files exist for both
- [ ] No Perl syntax errors or warnings
- [ ] Phase 9 complete: All 5 scripting languages (Python, Ruby, JavaScript, TypeScript, Perl) have DLX and CP implementations
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match C reference exactly
- Both implementations integrated into benchmark system
- Phase 9 complete
</success_criteria>

<output>
After completion, create `.planning/phases/09-scripting-languages-part-1/09-05-SUMMARY.md`:

# Phase 9 Plan 5: Perl Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.pl` - Description
- `path/to/another.pl` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 9 complete. Ready for Phase 10: Scripting Languages - Part 2 (PHP, Lua, R, Julia, MATLAB).
</output>
