---
phase: 09-scripting-languages-part-1
plan: 04
type: execute
depends_on: []
files_modified: [Algorithms/DLX/TypeScript/dlx.ts, Algorithms/DLX/TypeScript/runMe.sh, Algorithms/CP/TypeScript/cp.ts, Algorithms/CP/TypeScript/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for TypeScript, continuing scripting language algorithm coverage.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms from C reference to TypeScript, following established patterns. TypeScript's static typing provides additional safety while maintaining JavaScript's runtime performance.
Output: Working DLX and CP implementations for TypeScript with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/TypeScript/Sudoku.ts

**Tech stack available**: Node.js + TypeScript (already present for BruteForce)
**Established patterns**: Mechanical translation from C, iteration count verification, runMe.sh integration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in TypeScript</name>
  <files>Algorithms/DLX/TypeScript/dlx.ts, Algorithms/DLX/TypeScript/runMe.sh</files>
  <action>
Create Algorithms/DLX/TypeScript/ directory structure. Port the DLX algorithm from C to TypeScript:

**dlx.ts structure**:
- Create DlxNode class with properties: left: DlxNode | null, right: DlxNode | null, up: DlxNode | null, down: DlxNode | null, column: DlxColumn | null, rowId: number
- Create DlxColumn class with embedded node: DlxNode, plus size: number and name: string
- Implement coverColumn(c: DlxColumn): void - exact same logic as C (unlink column and all rows)
- Implement uncoverColumn(c: DlxColumn): void - exact reversal of cover operation
- Implement search(root: DlxColumn, k: number, solution: number[]): boolean - recursive backtracking with Algorithm X
- Implement buildExactCoverMatrix(): DlxColumn - create 324 columns for Sudoku constraints
- Implement parseMatrix(filename: string): {root: DlxColumn, puzzle: number[][]} - read .matrix file using fs.readFileSync
- Main execution that calls parseMatrix, search, and prints results
- Global dlxIterations: number counter incremented at start of search

**Critical requirements**:
- Use TypeScript's type system for safety (nullable types, explicit return types)
- Maintain circular doubly-linked list structure exactly as in C
- Print output format: puzzle state, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + digit
- File structure: all code in single dlx.ts file
- Import fs: import * as fs from 'fs'

**runMe.sh**:
- Set LANGUAGE="TypeScript", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- Define compile() function:
  - check_toolchain tsc
  - tsc --strict --target ES2020 --module commonjs dlx.ts
  - Create dlx_solver wrapper script: echo '#!/bin/bash\nnode dlx.js "$@"' > dlx_solver && chmod +x dlx_solver
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use TypeScript's strictNullChecks in a way that forces defensive null checks everywhere - use non-null assertions (!) where circular structure guarantees non-null
- Do NOT use Array methods for node manipulation - need explicit pointer operations
- Do NOT optimize the search order - must match C reference exactly
</action>
  <verify>cd Algorithms/DLX/TypeScript && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX implementation compiles and runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in TypeScript</name>
  <files>Algorithms/CP/TypeScript/cp.ts, Algorithms/CP/TypeScript/runMe.sh</files>
  <action>
Create Algorithms/CP/TypeScript/ directory structure. Port the CP algorithm from C to TypeScript:

**cp.ts structure**:
- Create CPGrid class with properties: values: number[][], candidates: number[][] (for bitsets)
- Define bitset helper functions with types:
  - hasCandidate(set: number, digit: number): boolean
  - addCandidate(set: number, digit: number): number
  - removeCandidate(set: number, digit: number): number
  - countCandidates(set: number): number
- Implement initGrid(grid: CPGrid, puzzle: number[][]): void - set empty cells to candidates = 0x1FF
- Implement assign(grid: CPGrid, row: number, col: number, value: number): boolean - place value and propagate
- Implement eliminate(grid: CPGrid, row: number, col: number, candidatesToRemove: number): boolean
- Implement propagate(grid: CPGrid): boolean - apply constraint propagation
- Implement findMrvCell(grid: CPGrid): {row: number, col: number} | null - find cell with Minimum Remaining Values
- Implement cpSearch(grid: CPGrid): boolean - recursive search with propagation
- Implement parseMatrix(filename: string): {puzzle: number[][], grid: CPGrid}
- Main execution with global cpIterations: number counter
- Import fs: import * as fs from 'fs'

**Critical requirements**:
- Use TypeScript types for clarity and safety
- Use JavaScript numbers for bitsets (bitwise ops work on 32-bit integers)
- Print output format: puzzle state, then "Solved in Iterations=67"
- Increment cpIterations at start of cpSearch
- Use custom popcount function with proper type signature

**runMe.sh**:
- Set LANGUAGE="TypeScript", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- Define compile() function:
  - check_toolchain tsc
  - tsc --strict --target ES2020 --module commonjs cp.ts
  - Create cp_solver wrapper script: echo '#!/bin/bash\nnode cp.js "$@"' > cp_solver && chmod +x cp_solver
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use TypeScript's Set for candidates - must use bitsets
- Do NOT add extra constraint propagation techniques
- Do NOT change MRV selection order
</action>
  <verify>cd Algorithms/CP/TypeScript && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP implementation compiles and runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] DLX TypeScript compiles without errors and shows exactly 43 iterations for Matrix 1
- [ ] CP TypeScript compiles without errors and shows exactly 67 iterations for Matrix 1
- [ ] Both produce correctly solved puzzles
- [ ] metrics.json files exist for both
- [ ] No TypeScript compilation errors or runtime errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match C reference exactly
- Both implementations integrated into benchmark system
</success_criteria>

<output>
After completion, create `.planning/phases/09-scripting-languages-part-1/09-04-SUMMARY.md`
</output>
