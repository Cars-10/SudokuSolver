---
phase: 09-scripting-languages-part-1
plan: 03
type: execute
depends_on: []
files_modified: [Algorithms/DLX/JavaScript/dlx.js, Algorithms/DLX/JavaScript/runMe.sh, Algorithms/CP/JavaScript/cp.js, Algorithms/CP/JavaScript/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for JavaScript, continuing scripting language algorithm coverage.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms from C reference to JavaScript, following established patterns. JavaScript's prototype-based objects map well to the pointer-heavy DLX algorithm.
Output: Working DLX and CP implementations for JavaScript with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/JavaScript/Sudoku.js

**Tech stack available**: Node.js (already present for BruteForce)
**Established patterns**: Mechanical translation from C, iteration count verification, runMe.sh integration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in JavaScript</name>
  <files>Algorithms/DLX/JavaScript/dlx.js, Algorithms/DLX/JavaScript/runMe.sh</files>
  <action>
Create Algorithms/DLX/JavaScript/ directory structure. Port the DLX algorithm from C to JavaScript:

**dlx.js structure**:
- Create DlxNode class with properties: left, right, up, down, column, rowId
- Create DlxColumn class with embedded node object, plus size and name
- Implement coverColumn(c) function - exact same logic as C (unlink column and all rows)
- Implement uncoverColumn(c) function - exact reversal of cover operation
- Implement search(root, k, solution) function - recursive backtracking with Algorithm X
- Implement buildExactCoverMatrix() - create 324 columns for Sudoku constraints
- Implement parseMatrix(filename) - read .matrix file using fs.readFileSync and create constraint rows
- Main execution that calls parseMatrix, search, and prints results
- Global dlxIterations counter incremented at start of search

**Critical requirements**:
- Use JavaScript object references naturally (JS objects are reference types)
- Maintain circular doubly-linked list structure exactly as in C
- Print output format: puzzle state, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + digit
- File structure: all code in single dlx.js file, executable via node dlx.js <matrix_file>
- Add shebang: #!/usr/bin/env node
- Use const fs = require('fs') for file I/O

**runMe.sh**:
- Set LANGUAGE="JavaScript", SOLVER_BINARY="node dlx.js", METRICS_FILE="metrics.json"
- Source ../../common.sh
- No compile() function needed (interpreted language)
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use JavaScript's Array methods (splice, shift, push) for node manipulation - need explicit pointer operations
- Do NOT use ES6 classes if they obscure the pointer manipulation - plain objects or ES5 prototypes are fine
- Do NOT optimize the search order - must match C reference exactly
- Do NOT use async/await - algorithm is synchronous
</action>
  <verify>cd Algorithms/DLX/JavaScript && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in JavaScript</name>
  <files>Algorithms/CP/JavaScript/cp.js, Algorithms/CP/JavaScript/runMe.sh</files>
  <action>
Create Algorithms/CP/JavaScript/ directory structure. Port the CP algorithm from C to JavaScript:

**cp.js structure**:
- Create CPGrid class with properties: values (9x9 array), candidates (9x9 array of integers for bitsets)
- Define bitset helper functions: hasCandidate(set, digit), addCandidate(set, digit), removeCandidate(set, digit), countCandidates(set)
- Implement initGrid(grid, puzzle) - set empty cells to candidates = 0x1FF
- Implement assign(grid, row, col, value) - place value and propagate constraints
- Implement eliminate(grid, row, col, candidatesToRemove) - remove candidates and propagate
- Implement propagate(grid) - apply constraint propagation until quiescence
- Implement findMrvCell(grid) - find cell with Minimum Remaining Values
- Implement cpSearch(grid) - recursive search with propagation
- Implement parseMatrix(filename) and main execution with global cpIterations counter
- Add shebang: #!/usr/bin/env node
- Use const fs = require('fs') for file I/O

**Critical requirements**:
- Use JavaScript numbers for bitsets (JS numbers are 64-bit floats but bitwise ops work on 32-bit integers)
- Bitset operations: use bit shifting (1 << digit)
- Print output format: puzzle state, then "Solved in Iterations=67"
- Increment cpIterations at start of cpSearch
- Use custom popcount function: (n) => { let count = 0; while(n) { count += n & 1; n >>= 1; } return count; }

**runMe.sh**:
- Set LANGUAGE="JavaScript", SOLVER_BINARY="node cp.js", METRICS_FILE="metrics.json"
- Source ../../common.sh
- No compile() function needed
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use JavaScript's Set for candidates - must use bitsets
- Do NOT add extra constraint propagation techniques
- Do NOT change MRV selection order
- Do NOT use async/await - algorithm is synchronous
</action>
  <verify>cd Algorithms/CP/JavaScript && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] DLX JavaScript shows exactly 43 iterations for Matrix 1
- [ ] CP JavaScript shows exactly 67 iterations for Matrix 1
- [ ] Both produce correctly solved puzzles
- [ ] metrics.json files exist for both
- [ ] No JavaScript runtime errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match C reference exactly
- Both implementations integrated into benchmark system
</success_criteria>

<output>
After completion, create `.planning/phases/09-scripting-languages-part-1/09-03-SUMMARY.md`
</output>
