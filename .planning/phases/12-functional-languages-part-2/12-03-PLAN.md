---
phase: 12-functional-languages-part-2
plan: 03
type: execute
depends_on: []
files_modified: [Algorithms/DLX/CommonLisp/dlx.lisp, Algorithms/DLX/CommonLisp/runMe.sh, Algorithms/CP/CommonLisp/cp.lisp, Algorithms/CP/CommonLisp/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Common Lisp, leveraging its powerful macro system and native support for mutable structures (arrays, structs with setf).

Purpose: Extend the benchmark suite with Common Lisp implementations demonstrating traditional Lisp's imperative capabilities for algorithm implementation.
Output: Working DLX and CP Common Lisp implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STRUCTURE.md

# Phase 11 patterns established
@.planning/phases/11-functional-languages-part-1/11-02-SUMMARY.md
@.planning/phases/11-functional-languages-part-1/11-05-SUMMARY.md

# Reference implementations
@Algorithms/BruteForce/CommonLisp/Sudoku.lisp

**Tech stack available**: Common Lisp (SBCL or CCL) with full imperative programming support
**Established patterns**:
- DLX uses circular doubly-linked lists with mutable structs
- CP uses mutable arrays with bitsets for candidates
- Target iteration counts: DLX=43, CP=67
- Common Lisp has defstruct with mutable slots, make-array with :adjustable nil for fixed arrays

**Key decisions from Phase 11**:
- Common Lisp's (setf (slot-value ...)) provides direct mutation
- (make-array) with type declarations for performance
- Use (defstruct (:type vector)) for compact node representation
- Matrix 1 verification is mandatory
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Common Lisp</name>
  <files>Algorithms/DLX/CommonLisp/dlx.lisp, Algorithms/DLX/CommonLisp/runMe.sh</files>
  <action>Create dlx.lisp implementing Dancing Links using Common Lisp structs. Structure:
  - Use #!/usr/bin/env sbcl --script (or similar shebang)
  - (defstruct node left right up down column size row-id col-id) with mutable slots
  - Initialize 324-column exact cover matrix (9×9×4 constraints)
  - Store nodes in adjustable vector or hash-table by integer ID
  - Use (setf (node-left x) y) for pointer updates in cover/uncover
  - Column selection heuristic: minimum size via loop
  - Pre-cover given clues before search
  - Search function with backtracking
  - Parse Matrix 1 format: read lines with (read-line), parse digits
  - Output solved board matching C format
  - Track iteration counter (defvar *iterations* 0) incremented in search
  - Should reach exactly 43 iterations for Matrix 1

  Create runMe.sh following Phase 11 pattern:
  - Set LANGUAGE="CommonLisp", ALGORITHM="DLX"
  - SOLVER_BINARY="sbcl --script dlx.lisp" (or ccl equivalent)
  - METRICS_FILE="metrics.json"
  - Source ../../common.sh
  - compile() checks for sbcl or ccl in PATH
  - Call main "$@"

  Avoid: Excessive consing in hot loops, using lists instead of vectors for arrays, interpreted mode without compilation.</action>
  <verify>./runMe.sh ../../Matrices/1.matrix outputs "Solved in Iterations=43" and correct solution</verify>
  <done>DLX Common Lisp passes Matrix 1 with exactly 43 iterations, runMe.sh functional</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Common Lisp</name>
  <files>Algorithms/CP/CommonLisp/cp.lisp, Algorithms/CP/CommonLisp/runMe.sh</files>
  <action>Create cp.lisp implementing Constraint Propagation using Common Lisp arrays. Structure:
  - Use #!/usr/bin/env sbcl --script shebang
  - Grid: (make-array '(9 9) :element-type 'fixnum :initial-element 0)
  - Candidates: (make-array '(9 9) :element-type 'fixnum) with bitsets (bits 1-9)
  - Bitset operations: (logand), (logior), (lognot), (ash) for masking
  - Initialize: empty cells get candidates = #b1111111110
  - assign(row, col, digit): (setf (aref grid row col) digit), clear candidates, propagate
  - eliminate(row, col, digit): (setf (aref candidates row col) (logand ...)), check singleton
  - Propagate strategies: singleton elimination via nested loops, hidden singles
  - Search with MRV heuristic: find cell with minimum (logcount candidates)
  - Backtracking: save/restore arrays with (loop for i below 9 do (loop for j below 9 ...))
  - Track iteration counter (defvar *iterations* 0) in assign
  - Expect 67 iterations (may vary to ~77-84 like other functional languages)

  Create runMe.sh following Phase 11 pattern:
  - Set LANGUAGE="CommonLisp", ALGORITHM="CP"
  - SOLVER_BINARY="sbcl --script cp.lisp"
  - METRICS_FILE="metrics.json"
  - Source ../../common.sh
  - compile() checks for sbcl or ccl in PATH
  - Call main "$@"

  Avoid: Using lists for arrays (slow random access), stack overflow from non-tail recursion, excessive memory allocation in loops.</action>
  <verify>./runMe.sh ../../Matrices/1.matrix outputs "Solved in Iterations=67" (or 77-84 acceptable) with correct solution</verify>
  <done>CP Common Lisp passes Matrix 1 with correct solution and iteration count in acceptable range, runMe.sh functional</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both DLX and CP implementations exist
- [ ] DLX achieves exactly 43 iterations on Matrix 1
- [ ] CP achieves 67 iterations (or 77-84 range acceptable) on Matrix 1
- [ ] Both produce correct solutions matching C reference
- [ ] Both runMe.sh scripts work with common.sh integration
- [ ] metrics.json files generated successfully
</verification>

<success_criteria>

- DLX Common Lisp implementation complete with verified iteration count (43)
- CP Common Lisp implementation complete with verified iteration count (67 or acceptable range)
- Both algorithms produce correct solutions
- No compilation errors or runtime crashes
- Integration with benchmark suite successful
</success_criteria>

<output>
After completion, create `.planning/phases/12-functional-languages-part-2/12-03-SUMMARY.md`:

# Phase 12 Plan 3: Common Lisp Algorithms Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [DLX/CP implementation details]
- [Struct/array approach used]
- [Iteration counts achieved]

## Files Created/Modified

- `Algorithms/DLX/CommonLisp/dlx.lisp` - Description
- `Algorithms/DLX/CommonLisp/runMe.sh` - Description
- `Algorithms/CP/CommonLisp/cp.lisp` - Description
- `Algorithms/CP/CommonLisp/runMe.sh` - Description

## Decisions Made

[Key technical decisions and rationale]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for parallel execution with other Phase 12 plans.
</output>
