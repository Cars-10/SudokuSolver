---
phase: 07-interactive-solver
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Metrics/modules/solver-grid.js
  - Metrics/modules/solver-effects.js
  - Metrics/SharedStyles.ts
autonomous: true

must_haves:
  truths:
    - "9x9 grid renders with CSS Grid layout and 3D perspective"
    - "Cells display numbers with neon glow effect (cyan, green, red per state)"
    - "Active cell spins along vertical axis using CSS rotateY animation"
    - "Backtracking cells spin counter-clockwise with red glow"
    - "Screen shake effect triggers on deep backtracking"
    - "Alien character scramble effect available for intense moments"
  artifacts:
    - path: "Metrics/modules/solver-grid.js"
      provides: "3D grid renderer with state-based styling"
      exports: ["SolverGridRenderer"]
      min_lines: 100
    - path: "Metrics/modules/solver-effects.js"
      provides: "Glitch effects: screen shake, alien scramble, chromatic aberration"
      exports: ["GlitchEffects"]
      min_lines: 60
    - path: "Metrics/SharedStyles.ts"
      provides: "CSS for 3D grid, neon glow, spin animations"
      contains: "solver-grid"
  key_links:
    - from: "Metrics/modules/solver-grid.js"
      to: "CSS classes"
      via: "classList manipulation"
      pattern: "classList\\.(add|remove)"
    - from: "Metrics/modules/solver-effects.js"
      to: "solver-grid container"
      via: "DOM reference"
      pattern: "glitch-screen-shake"
    - from: "Metrics/SharedStyles.ts"
      to: "rotateY animation"
      via: "@keyframes"
      pattern: "@keyframes spinY"
---

<objective>
Create the visual rendering layer: 3D CSS grid with neon styling and glitch effects.

Purpose: Provide visually entertaining Matrix/Neon themed animation (INT-03, INT-04, INT-05)
Output: solver-grid.js (3D grid renderer), solver-effects.js (glitch effects), CSS styles in SharedStyles.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-interactive-solver/07-CONTEXT.md
@.planning/phases/07-interactive-solver/07-RESEARCH.md

# Existing alien character reference
@Metrics/modules/screensaver.js (AlienStatusSystem class has alien characters)

# Existing styles pattern
@Metrics/SharedStyles.ts

# CSS patterns from research
# Pattern 3: CSS 3D Grid with Perspective
# Pattern 4: Neon Glow Effects
# Pattern 5: Glitch Effects
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create 3D grid renderer with neon styling</name>
  <files>Metrics/modules/solver-grid.js, Metrics/SharedStyles.ts</files>
  <action>
Create the 3D grid renderer that displays the Sudoku puzzle with neon/Matrix visual styling.

**Part A: Add CSS styles to SharedStyles.ts**

Add a new section for interactive solver styles. Follow existing pattern in SharedStyles.ts.

```css
/* Interactive Solver - 3D Grid */
.solver-section {
    background: #0a0a0f;
    padding: 2rem;
    border-radius: 8px;
    border: 1px solid rgba(0, 255, 157, 0.3);
}

.solver-grid-container {
    perspective: 1000px;
    perspective-origin: center center;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 2rem;
}

.solver-grid {
    display: grid;
    grid-template-columns: repeat(9, 1fr);
    gap: 2px;
    background: rgba(0, 255, 157, 0.1);
    padding: 4px;
    border-radius: 4px;
    box-shadow:
        0 0 20px rgba(0, 255, 157, 0.3),
        inset 0 0 20px rgba(0, 255, 157, 0.1);
    transform-style: preserve-3d;
    transform: rotateX(5deg); /* Slight 3D tilt */
}

/* 3x3 box borders */
.solver-grid::before {
    content: '';
    position: absolute;
    /* Grid lines for 3x3 boxes handled via cell borders */
}

.solver-cell {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(10, 10, 20, 0.9);
    border: 1px solid rgba(0, 255, 157, 0.2);
    transform-style: preserve-3d;
    transition: transform 0.3s ease, background 0.3s ease;
    position: relative;
}

/* 3x3 box emphasis borders */
.solver-cell[data-col="2"],
.solver-cell[data-col="5"] {
    border-right: 2px solid rgba(0, 255, 157, 0.5);
}

.solver-cell[data-row="2"],
.solver-cell[data-row="5"] {
    border-bottom: 2px solid rgba(0, 255, 157, 0.5);
}

.cell-value {
    font-family: 'JetBrains Mono', 'Fira Code', monospace;
    font-size: 1.5rem;
    font-weight: bold;
    color: #00ff9d;
    text-shadow:
        0 0 5px #fff,
        0 0 10px #00ff9d,
        0 0 20px #00ff9d;
    backface-visibility: hidden;
}

/* Initial puzzle values (fixed) */
.solver-cell.fixed .cell-value {
    color: #888;
    text-shadow: none;
}

/* Active cell being tried */
.solver-cell.active {
    background: rgba(0, 184, 255, 0.2);
    border-color: #00b8ff;
    box-shadow:
        0 0 10px rgba(0, 184, 255, 0.5),
        inset 0 0 10px rgba(0, 184, 255, 0.2);
}

.solver-cell.active .cell-value {
    color: #00b8ff;
    text-shadow:
        0 0 5px #fff,
        0 0 10px #00b8ff,
        0 0 20px #00b8ff;
}

/* Successfully placed value */
.solver-cell.success {
    background: rgba(0, 255, 157, 0.2);
}

.solver-cell.success .cell-value {
    color: #00ff9d;
    text-shadow:
        0 0 5px #fff,
        0 0 10px #00ff9d,
        0 0 20px #00ff9d,
        0 0 40px #00ff9d;
}

/* Backtracking - error state */
.solver-cell.backtrack {
    background: rgba(255, 0, 100, 0.2);
    border-color: #ff0064;
}

.solver-cell.backtrack .cell-value {
    color: #ff0064;
    text-shadow:
        0 0 5px #fff,
        0 0 10px #ff0064,
        0 0 20px #ff0064;
}

/* Spin animations */
.solver-cell.spinning {
    animation: spinY 0.6s ease-in-out;
}

.solver-cell.spinning-reverse {
    animation: spinY-reverse 0.6s ease-in-out;
}

@keyframes spinY {
    0% { transform: rotateY(0deg); }
    50% { transform: rotateY(90deg); }
    100% { transform: rotateY(0deg); }
}

@keyframes spinY-reverse {
    0% { transform: rotateY(0deg); }
    50% { transform: rotateY(-90deg); }
    100% { transform: rotateY(0deg); }
}

/* Glitch effects */
.solver-grid-container.glitch-screen-shake {
    animation: shake 0.2s ease-in-out;
}

@keyframes shake {
    0%, 100% { transform: translate(0, 0); }
    25% { transform: translate(-3px, 3px); }
    50% { transform: translate(3px, -3px); }
    75% { transform: translate(-3px, -3px); }
}

/* Chromatic aberration on intense moments */
.solver-cell.chromatic .cell-value {
    position: relative;
}

.solver-cell.chromatic .cell-value::before,
.solver-cell.chromatic .cell-value::after {
    content: attr(data-value);
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.solver-cell.chromatic .cell-value::before {
    left: 2px;
    color: #f0f;
    opacity: 0.7;
}

.solver-cell.chromatic .cell-value::after {
    left: -2px;
    color: #0ff;
    opacity: 0.7;
}

/* Info panel */
.solver-info {
    display: flex;
    gap: 2rem;
    margin-top: 1rem;
    padding: 1rem;
    background: rgba(0, 255, 157, 0.05);
    border-radius: 4px;
    font-family: 'JetBrains Mono', monospace;
}

.solver-info-item {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.solver-info-label {
    font-size: 0.75rem;
    color: #888;
    text-transform: uppercase;
}

.solver-info-value {
    font-size: 1.25rem;
    color: #00ff9d;
    text-shadow: 0 0 10px rgba(0, 255, 157, 0.5);
}

/* Responsive - smaller on mobile */
@media (max-width: 600px) {
    .solver-cell {
        width: 32px;
        height: 32px;
    }
    .cell-value {
        font-size: 1rem;
    }
}
```

**Part B: Create solver-grid.js**

```javascript
// solver-grid.js - 3D Grid Renderer for Interactive Solver

export class SolverGridRenderer {
    constructor(containerElement) {
        this.container = containerElement;
        this.cells = [];
        this.initialPuzzle = null; // To mark fixed cells
        this.currentAnimationSpeed = 1; // For adaptive animation duration
    }

    // Initialize the 9x9 grid
    initGrid() {
        this.container.innerHTML = `
            <div class="solver-grid-container">
                <div class="solver-grid">
                    ${Array(81).fill(0).map((_, i) => {
                        const row = Math.floor(i / 9);
                        const col = i % 9;
                        return `
                            <div class="solver-cell" data-row="${row}" data-col="${col}">
                                <span class="cell-value" data-value=""></span>
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
        `;
        this.cells = Array.from(this.container.querySelectorAll('.solver-cell'));
        this.gridContainer = this.container.querySelector('.solver-grid-container');
    }

    // Set initial puzzle (marks fixed cells)
    setInitialPuzzle(grid) {
        this.initialPuzzle = grid.map(row => [...row]);
        this.renderGrid(grid);

        // Mark fixed cells
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                if (grid[r][c] !== 0) {
                    const idx = r * 9 + c;
                    this.cells[idx].classList.add('fixed');
                }
            }
        }
    }

    // Render current grid state (values only, no animations)
    renderGrid(grid) {
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                const idx = r * 9 + c;
                const cell = this.cells[idx];
                const valueSpan = cell.querySelector('.cell-value');
                const val = grid[r][c];
                valueSpan.textContent = val === 0 ? '' : val;
                valueSpan.setAttribute('data-value', val === 0 ? '' : val);
            }
        }
    }

    // Render state with animations and styling
    render(state, options = {}) {
        const { grid, row, col, value, isBacktrack, depth } = state;
        const skipAnimation = options.skipAnimation || false;

        // Update all cell values
        this.renderGrid(grid);

        // Clear previous active/backtrack states (except fixed)
        this.cells.forEach(cell => {
            cell.classList.remove('active', 'success', 'backtrack', 'spinning', 'spinning-reverse', 'chromatic');
        });

        // Highlight active cell if specified
        if (row !== undefined && col !== undefined && row >= 0 && col >= 0) {
            const idx = row * 9 + col;
            const cell = this.cells[idx];

            if (isBacktrack) {
                cell.classList.add('backtrack');
                if (!skipAnimation && this.currentAnimationSpeed <= 10) {
                    cell.classList.add('spinning-reverse');
                }
            } else {
                cell.classList.add('active');
                if (!skipAnimation && this.currentAnimationSpeed <= 10) {
                    cell.classList.add('spinning');
                }

                // Success if value was placed (non-zero in grid at that position)
                if (grid[row][col] !== 0) {
                    // Transition to success after spin
                    setTimeout(() => {
                        cell.classList.remove('active');
                        cell.classList.add('success');
                    }, skipAnimation ? 0 : 300);
                }
            }
        }
    }

    // Set animation speed multiplier (disables animations at high speeds)
    setAnimationSpeed(speed) {
        this.currentAnimationSpeed = speed;

        // Adjust animation durations based on speed
        const duration = Math.max(0.1, 0.6 / Math.sqrt(speed));
        this.container.style.setProperty('--spin-duration', `${duration}s`);
    }

    // Get cell element by row/col
    getCell(row, col) {
        return this.cells[row * 9 + col];
    }

    // Get grid container for effects
    getGridContainer() {
        return this.gridContainer;
    }

    // Cleanup
    cleanup() {
        this.container.innerHTML = '';
        this.cells = [];
        this.initialPuzzle = null;
    }
}
```
  </action>
  <verify>
1. Check SharedStyles.ts has solver-grid styles added
2. solver-grid.js exists in Metrics/modules/
3. Create test HTML:
```html
<div id="solver-container"></div>
<script type="module">
import { SolverGridRenderer } from './Metrics/modules/solver-grid.js';
const renderer = new SolverGridRenderer(document.getElementById('solver-container'));
renderer.initGrid();
const testPuzzle = [
    [0,0,3,0,2,0,6,0,0],
    [9,0,0,3,0,5,0,0,1],
    [0,0,1,8,0,6,4,0,0],
    [0,0,8,1,0,2,9,0,0],
    [7,0,0,0,0,0,0,0,8],
    [0,0,6,7,0,8,2,0,0],
    [0,0,2,6,0,9,5,0,0],
    [8,0,0,2,0,3,0,0,9],
    [0,0,5,0,1,0,3,0,0]
];
renderer.setInitialPuzzle(testPuzzle);
// Should see 9x9 grid with 3D perspective, fixed cells dimmed
</script>
```
  </verify>
  <done>SolverGridRenderer exports from solver-grid.js, CSS styles added to SharedStyles.ts with 3D grid, neon glow, spin animations</done>
</task>

<task type="auto">
  <name>Task 2: Create glitch effects module</name>
  <files>Metrics/modules/solver-effects.js</files>
  <action>
Create the glitch effects module for visual feedback during solving.

**Effects from CONTEXT.md decisions:**
1. Screen shake on backtrack (especially deep backtracks)
2. Alien character scramble during intense moments
3. Chromatic aberration at high speeds

**Use existing alien characters from screensaver.js:**
```javascript
const aliens = "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜｦﾝ0123456789";
```

**Module structure:**
```javascript
// solver-effects.js - Glitch Effects for Interactive Solver

export class GlitchEffects {
    constructor(gridContainer) {
        this.container = gridContainer;
        this.aliens = "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜｦﾝ0123456789";
        this.activeEffects = new Set();
        this.enabled = true;
    }

    // Enable/disable all effects
    setEnabled(enabled) {
        this.enabled = enabled;
    }

    // Screen shake effect
    // Trigger on deep backtracks (depth > threshold)
    screenShake(duration = 200) {
        if (!this.enabled || this.activeEffects.has('shake')) return;

        this.activeEffects.add('shake');
        this.container.classList.add('glitch-screen-shake');

        setTimeout(() => {
            this.container.classList.remove('glitch-screen-shake');
            this.activeEffects.delete('shake');
        }, duration);
    }

    // Alien character scramble on a specific cell
    // Shows random alien characters briefly before settling
    alienScramble(cellElement, finalValue, duration = 300) {
        if (!this.enabled) return;

        const valueSpan = cellElement.querySelector('.cell-value');
        if (!valueSpan) return;

        const startTime = Date.now();
        const originalValue = finalValue || valueSpan.textContent;

        const scrambleInterval = setInterval(() => {
            const elapsed = Date.now() - startTime;
            if (elapsed >= duration) {
                clearInterval(scrambleInterval);
                valueSpan.textContent = originalValue;
                valueSpan.setAttribute('data-value', originalValue);
                return;
            }

            // Random alien character
            const randomChar = this.aliens[Math.floor(Math.random() * this.aliens.length)];
            valueSpan.textContent = randomChar;
        }, 50);
    }

    // Chromatic aberration effect on cell
    chromaticAberration(cellElement, duration = 500) {
        if (!this.enabled) return;

        cellElement.classList.add('chromatic');

        setTimeout(() => {
            cellElement.classList.remove('chromatic');
        }, duration);
    }

    // Color inversion flash (entire grid)
    colorInvert(duration = 100) {
        if (!this.enabled) return;

        this.container.style.filter = 'invert(1)';

        setTimeout(() => {
            this.container.style.filter = '';
        }, duration);
    }

    // Trigger combined glitch based on intensity level
    // intensity: 0-1 (0 = subtle, 1 = maximum chaos)
    triggerGlitch(intensity, cellElement = null) {
        if (!this.enabled) return;

        if (intensity > 0.7) {
            this.screenShake(200 + intensity * 100);
        }

        if (intensity > 0.5 && cellElement) {
            this.chromaticAberration(cellElement, 300 + intensity * 200);
        }

        if (intensity > 0.8) {
            this.colorInvert(50);
        }
    }

    // Smart trigger based on solver state
    // Call this from animation controller when state changes
    onStateChange(state, prevState) {
        if (!this.enabled) return;

        const { isBacktrack, depth, row, col } = state;

        // Screen shake on deep backtrack
        if (isBacktrack && depth > 5) {
            const intensity = Math.min(1, depth / 15);
            this.screenShake(150 + intensity * 150);
        }

        // Alien scramble on backtrack
        if (isBacktrack && row !== undefined && col !== undefined) {
            const cellIdx = row * 9 + col;
            const cells = this.container.querySelectorAll('.solver-cell');
            if (cells[cellIdx]) {
                // Only scramble occasionally to avoid chaos
                if (Math.random() > 0.7) {
                    this.alienScramble(cells[cellIdx], '', 150);
                }
            }
        }
    }

    // Clear all active effects
    clear() {
        this.container.classList.remove('glitch-screen-shake');
        this.container.style.filter = '';
        this.container.querySelectorAll('.chromatic').forEach(el => {
            el.classList.remove('chromatic');
        });
        this.activeEffects.clear();
    }
}

// Factory function
export function createGlitchEffects(gridContainer) {
    return new GlitchEffects(gridContainer);
}
```

**Integration point:**
The GlitchEffects will be instantiated by the animation controller (07-03) and called during state changes. The `onStateChange` method provides smart triggering based on solver state.
  </action>
  <verify>
1. solver-effects.js exists in Metrics/modules/
2. Exports GlitchEffects class and createGlitchEffects factory
3. Test in browser console:
```javascript
import { GlitchEffects } from './Metrics/modules/solver-effects.js';
const container = document.querySelector('.solver-grid-container');
const effects = new GlitchEffects(container);
effects.screenShake(); // Should shake the grid
```
  </verify>
  <done>GlitchEffects class exports from solver-effects.js with screenShake, alienScramble, chromaticAberration, colorInvert effects and smart onStateChange trigger</done>
</task>

</tasks>

<verification>
Overall verification:
1. Metrics/modules/solver-grid.js exists and exports SolverGridRenderer
2. Metrics/modules/solver-effects.js exists and exports GlitchEffects
3. Metrics/SharedStyles.ts contains solver-grid, solver-cell, spin animation styles
4. Grid renders 81 cells in 9x9 CSS Grid layout
5. Cells have 3D perspective (transform: rotateX)
6. Neon glow applied via text-shadow
7. Spin animations defined (@keyframes spinY, spinY-reverse)
8. Screen shake animation defined (@keyframes shake)
9. Active/backtrack/success cell states have distinct visual styling
10. Mobile responsive (smaller cells at max-width: 600px)
</verification>

<success_criteria>
- 9x9 grid renders with CSS Grid and 3D perspective
- Neon glow effects on numbers (cyan for active, green for success, red for backtrack)
- Spin animations: clockwise for forward, counter-clockwise for backtrack
- Screen shake triggers on deep backtracks
- Alien scramble effect available
- Chromatic aberration effect available
- Fixed cells (initial puzzle values) visually distinct
- Responsive sizing for mobile
</success_criteria>

<output>
After completion, create `.planning/phases/07-interactive-solver/07-02-SUMMARY.md`
</output>
