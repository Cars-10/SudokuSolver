---
phase: 07-interactive-solver
plan: 04
type: execute
wave: 3
depends_on: ["07-01", "07-02", "07-03"]
files_modified:
  - Metrics/HTMLGenerator.ts
  - Metrics/modules/interactive-solver.js
autonomous: false

must_haves:
  truths:
    - "Interactive Solver tab appears in report navigation"
    - "User can select matrix (1-6) from dropdown"
    - "User can select algorithm (BruteForce) from dropdown"
    - "Start Solving button initiates solver and populates history"
    - "Full playback controls appear after solving starts"
    - "Grid renders with 3D perspective and neon styling"
    - "Animation plays through solving process with visual effects"
    - "Tab integrates seamlessly with existing report UI"
  artifacts:
    - path: "Metrics/modules/interactive-solver.js"
      provides: "Main orchestrator integrating all solver modules"
      exports: ["InteractiveSolver", "initInteractiveSolver"]
      min_lines: 150
    - path: "Metrics/HTMLGenerator.ts"
      provides: "Interactive Solver tab section in generated HTML"
      contains: "interactive-solver-section"
  key_links:
    - from: "Metrics/modules/interactive-solver.js"
      to: "all solver modules"
      via: "import and instantiation"
      pattern: "import.*solver"
    - from: "Metrics/HTMLGenerator.ts"
      to: "interactive-solver.js"
      via: "script tag"
      pattern: "interactive-solver\\.js"
    - from: "tab navigation"
      to: "solver section"
      via: "showTab"
      pattern: "showTab\\('interactive"
---

<objective>
Integrate all solver modules into HTMLGenerator.ts with a dedicated Interactive Solver tab.

Purpose: Provide complete interactive solver experience accessible from the benchmark report (INT-01 through INT-05)
Output: interactive-solver.js (orchestrator), Interactive Solver tab in generated HTML
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-interactive-solver/07-CONTEXT.md
@.planning/phases/07-interactive-solver/07-RESEARCH.md

# Dependencies from all previous plans
@.planning/phases/07-interactive-solver/07-01-PLAN.md (solver-engine.js, solver-state.js)
@.planning/phases/07-interactive-solver/07-02-PLAN.md (solver-grid.js, solver-effects.js)
@.planning/phases/07-interactive-solver/07-03-PLAN.md (solver-animation.js, solver-controls.js)

# Integration target
@Metrics/HTMLGenerator.ts

# Matrix files for dropdown
@Matrices/ (1.matrix through 6.matrix)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create main orchestrator module</name>
  <files>Metrics/modules/interactive-solver.js</files>
  <action>
Create the main orchestrator that integrates all solver modules and provides the public API.

```javascript
// interactive-solver.js - Main Orchestrator for Interactive Solver

import { BruteForceSolver } from './solver-engine.js';
import { SolverHistory, getSharedHistory, resetSharedHistory } from './solver-state.js';
import { SolverGridRenderer } from './solver-grid.js';
import { GlitchEffects, createGlitchEffects } from './solver-effects.js';
import { AnimationController, createAnimationController } from './solver-animation.js';
import { SolverControls, createSolverControls } from './solver-controls.js';

// Matrix puzzle data - will be populated from window.matrixPuzzles
const MATRIX_PUZZLES = {
    '1': null, // Loaded dynamically
    '2': null,
    '3': null,
    '4': null,
    '5': null,
    '6': null
};

// Reference iteration counts for validation
const REFERENCE_ITERATIONS = {
    '1': 656,
    '2': 439269,
    '3': 98847,
    '4': 9085,
    '5': 445778,
    '6': 622577597
};

export class InteractiveSolver {
    constructor(containerElement) {
        this.container = containerElement;
        this.gridContainer = null;
        this.controlsContainer = null;
        this.statusContainer = null;

        // Module instances
        this.solver = null;
        this.history = null;
        this.gridRenderer = null;
        this.effects = null;
        this.animationController = null;
        this.controls = null;

        // State
        this.currentMatrix = '1';
        this.currentAlgorithm = 'BruteForce';
        this.isLoaded = false;
        this.isSolving = false;
    }

    // Initialize the UI structure
    init() {
        this.container.innerHTML = `
            <div class="solver-section">
                <div class="solver-header">
                    <h2>Interactive Solver</h2>
                    <p class="solver-subtitle">Watch the algorithm think</p>
                </div>

                <div class="solver-setup">
                    <div class="solver-setup-row">
                        <label for="matrix-select">Matrix:</label>
                        <select id="matrix-select" class="solver-select">
                            <option value="1">Matrix 1 (656 iterations)</option>
                            <option value="2">Matrix 2 (439,269 iterations)</option>
                            <option value="3">Matrix 3 (98,847 iterations)</option>
                            <option value="4">Matrix 4 (9,085 iterations)</option>
                            <option value="5">Matrix 5 (445,778 iterations)</option>
                            <option value="6" disabled>Matrix 6 (622M - too large)</option>
                        </select>
                    </div>

                    <div class="solver-setup-row">
                        <label for="algorithm-select">Algorithm:</label>
                        <select id="algorithm-select" class="solver-select">
                            <option value="BruteForce">Brute Force Backtracking</option>
                        </select>
                    </div>

                    <button id="start-solving" class="solver-btn primary solver-start-btn">
                        <span class="icon">‚ñ∂</span> Start Solving
                    </button>
                </div>

                <div class="solver-status" id="solver-status" style="display: none;">
                    <span class="status-text"></span>
                </div>

                <div id="solver-grid-area" style="display: none;"></div>

                <div id="solver-controls-area" style="display: none;"></div>

                <div class="solver-memory-warning" id="memory-warning" style="display: none;">
                    <span class="warning-icon">‚ö†</span>
                    <span class="warning-text">History limit reached. Older states have been discarded.</span>
                </div>
            </div>
        `;

        // Get container references
        this.gridContainer = this.container.querySelector('#solver-grid-area');
        this.controlsContainer = this.container.querySelector('#solver-controls-area');
        this.statusContainer = this.container.querySelector('#solver-status');

        // Setup event listeners
        this.container.querySelector('#start-solving').addEventListener('click', () => {
            this.startSolving();
        });

        this.container.querySelector('#matrix-select').addEventListener('change', (e) => {
            this.currentMatrix = e.target.value;
            this.reset();
        });

        this.container.querySelector('#algorithm-select').addEventListener('change', (e) => {
            this.currentAlgorithm = e.target.value;
            this.reset();
        });

        // Load matrix data from window if available
        if (window.matrixPuzzles) {
            this.loadMatrixData(window.matrixPuzzles);
        }
    }

    // Load matrix puzzle data
    loadMatrixData(puzzles) {
        // puzzles is an array of puzzle strings (from HTMLGenerator)
        puzzles.forEach((puzzleStr, index) => {
            if (index < 6) {
                MATRIX_PUZZLES[String(index + 1)] = this.parseMatrixString(puzzleStr);
            }
        });
    }

    // Parse matrix string to 2D array
    parseMatrixString(matrixStr) {
        const lines = matrixStr.split('\n').filter(line => {
            const trimmed = line.trim();
            return trimmed && !trimmed.startsWith('#');
        });

        const grid = [];
        for (let i = 0; i < 9 && i < lines.length; i++) {
            const values = lines[i].trim().split(/\s+/).map(Number);
            if (values.length === 9) {
                grid.push(values);
            }
        }

        return grid.length === 9 ? grid : null;
    }

    // Show status message
    showStatus(message, type = 'info') {
        this.statusContainer.style.display = 'block';
        const textEl = this.statusContainer.querySelector('.status-text');
        textEl.textContent = message;
        textEl.className = `status-text status-${type}`;
    }

    // Hide status
    hideStatus() {
        this.statusContainer.style.display = 'none';
    }

    // Start solving process
    async startSolving() {
        if (this.isSolving) return;

        const puzzle = MATRIX_PUZZLES[this.currentMatrix];
        if (!puzzle) {
            this.showStatus(`Matrix ${this.currentMatrix} data not loaded`, 'error');
            return;
        }

        this.isSolving = true;
        this.showStatus('Solving puzzle...', 'info');

        // Disable start button
        const startBtn = this.container.querySelector('#start-solving');
        startBtn.disabled = true;
        startBtn.innerHTML = '<span class="icon">‚è≥</span> Solving...';

        // Reset any previous state
        this.cleanupModules();

        // Initialize modules
        this.history = getSharedHistory(10000); // 10K state limit

        // Initialize grid renderer
        this.gridRenderer = new SolverGridRenderer(this.gridContainer);
        this.gridRenderer.initGrid();
        this.gridContainer.style.display = 'block';

        // Set initial puzzle
        this.gridRenderer.setInitialPuzzle(puzzle);

        // Initialize effects
        this.effects = createGlitchEffects(this.gridRenderer.getGridContainer());

        // Initialize solver
        this.solver = new BruteForceSolver();
        this.solver.loadPuzzle(puzzle);

        // Capture states during solving
        this.solver.onStateChange = (state) => {
            this.history.push(state);
        };

        // Run solver (synchronous for small puzzles)
        // For large puzzles, we'd want to chunk this
        const expectedIterations = REFERENCE_ITERATIONS[this.currentMatrix];

        try {
            // Solve in chunks to keep UI responsive
            await this.solveInChunks();

            // Validate iteration count
            if (this.solver.iteration !== expectedIterations) {
                console.warn(`Iteration mismatch: expected ${expectedIterations}, got ${this.solver.iteration}`);
            }

            this.showStatus(`Solved in ${this.solver.iteration.toLocaleString()} iterations`, 'success');

        } catch (error) {
            this.showStatus(`Error: ${error.message}`, 'error');
            this.isSolving = false;
            startBtn.disabled = false;
            startBtn.innerHTML = '<span class="icon">‚ñ∂</span> Start Solving';
            return;
        }

        // Go to start of history
        this.history.goToStart();

        // Initialize animation controller
        this.animationController = createAnimationController(
            this.history,
            this.gridRenderer,
            this.effects
        );

        // Initialize controls
        this.controlsContainer.style.display = 'block';
        this.controls = createSolverControls(this.controlsContainer, this.animationController);

        // Check if memory limit was reached
        const stats = this.history.getStats();
        if (stats.memoryLimitReached) {
            this.container.querySelector('#memory-warning').style.display = 'block';
        }

        // Update start button
        startBtn.innerHTML = '<span class="icon">üîÑ</span> Restart';
        startBtn.disabled = false;

        // Render initial state
        const initialState = this.history.getCurrentState();
        if (initialState) {
            this.gridRenderer.render(initialState, { skipAnimation: true });
            this.controls.updateInfo(initialState, stats);
        }

        this.isLoaded = true;
        this.isSolving = false;
    }

    // Solve puzzle in chunks to keep UI responsive
    solveInChunks() {
        return new Promise((resolve, reject) => {
            // For Matrix 1-5, synchronous solving is fast enough
            // For very large puzzles, we'd chunk this differently
            try {
                this.solver.solve();
                resolve();
            } catch (error) {
                reject(error);
            }
        });
    }

    // Reset to initial state
    reset() {
        this.cleanupModules();
        this.gridContainer.style.display = 'none';
        this.controlsContainer.style.display = 'none';
        this.container.querySelector('#memory-warning').style.display = 'none';
        this.hideStatus();

        const startBtn = this.container.querySelector('#start-solving');
        startBtn.disabled = false;
        startBtn.innerHTML = '<span class="icon">‚ñ∂</span> Start Solving';

        this.isLoaded = false;
    }

    // Cleanup module instances
    cleanupModules() {
        if (this.animationController) {
            this.animationController.cleanup();
            this.animationController = null;
        }

        if (this.controls) {
            this.controls.cleanup();
            this.controls = null;
        }

        if (this.effects) {
            this.effects.clear();
            this.effects = null;
        }

        if (this.gridRenderer) {
            this.gridRenderer.cleanup();
            this.gridRenderer = null;
        }

        resetSharedHistory();
        this.history = null;
        this.solver = null;
    }

    // Full cleanup when leaving tab
    cleanup() {
        this.cleanupModules();
        this.container.innerHTML = '';
    }
}

// Initialize interactive solver when DOM ready
export function initInteractiveSolver() {
    const container = document.getElementById('interactive-solver-section');
    if (!container) {
        console.warn('Interactive solver container not found');
        return null;
    }

    const solver = new InteractiveSolver(container);
    solver.init();

    // Store reference for cleanup
    window.interactiveSolver = solver;

    return solver;
}

// Auto-initialize when module loads (for use in generated HTML)
if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        // Only auto-init if container exists
        if (document.getElementById('interactive-solver-section')) {
            initInteractiveSolver();
        }
    });
}
```

**Key integration points:**
1. Uses `window.matrixPuzzles` for puzzle data (set by HTMLGenerator)
2. Stores reference at `window.interactiveSolver` for external access
3. Auto-initializes on DOMContentLoaded if container exists
4. Memory warning shows if history limit exceeded
5. Matrix 6 disabled (622M iterations too large for browser)
  </action>
  <verify>
1. interactive-solver.js exists in Metrics/modules/
2. Exports InteractiveSolver class and initInteractiveSolver function
3. Imports all solver modules correctly
4. No syntax errors (can test by importing in browser console)
  </verify>
  <done>InteractiveSolver orchestrator exports from interactive-solver.js, integrates all solver modules, provides public init function</done>
</task>

<task type="auto">
  <name>Task 2: Add Interactive Solver tab to HTMLGenerator.ts</name>
  <files>Metrics/HTMLGenerator.ts</files>
  <action>
Add a dedicated Interactive Solver tab to the generated HTML report.

**1. Add tab button to navigation:**

Find the existing tab buttons section (near methodology tabs or chart tabs) and add:

```html
<button class="tab-btn" onclick="showTab('interactive-solver')">
    <span class="tab-icon">üéÆ</span> Interactive Solver
</button>
```

**2. Add tab content section:**

Add a new section for the interactive solver (after other main sections):

```html
<section id="interactive-solver-section" class="tab-content" style="display: none;">
    <!-- Content populated by interactive-solver.js -->
</section>
```

**3. Add module script import:**

In the scripts section at the bottom, add:

```html
<script type="module">
    import { initInteractiveSolver } from './Metrics/modules/interactive-solver.js';

    // Initialize when Interactive Solver tab is shown
    window.initInteractiveSolverOnce = false;
    const originalShowTab = window.showTab;
    window.showTab = function(tabId) {
        originalShowTab(tabId);
        if (tabId === 'interactive-solver' && !window.initInteractiveSolverOnce) {
            initInteractiveSolver();
            window.initInteractiveSolverOnce = true;
        }
    };
</script>
```

**4. Ensure matrixPuzzles is available:**

The existing HTMLGenerator already has `matrixContents` - ensure it's exposed as:

```javascript
window.matrixPuzzles = ${safeJSON(matrixContents)};
```

(Check if this already exists; if so, interactive-solver.js will use it)

**5. Add CSS for setup dropdowns:**

Add to SharedStyles.ts (if not already):

```css
/* Interactive Solver - Setup */
.solver-header {
    text-align: center;
    margin-bottom: 2rem;
}

.solver-header h2 {
    color: #00ff9d;
    font-size: 2rem;
    margin: 0;
    text-shadow: 0 0 20px rgba(0, 255, 157, 0.5);
}

.solver-subtitle {
    color: #888;
    font-style: italic;
    margin-top: 0.5rem;
}

.solver-setup {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
}

.solver-setup-row {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.solver-setup-row label {
    font-family: 'JetBrains Mono', monospace;
    color: #888;
    min-width: 80px;
}

.solver-select {
    background: rgba(0, 255, 157, 0.1);
    border: 1px solid rgba(0, 255, 157, 0.3);
    color: #00ff9d;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    font-family: 'JetBrains Mono', monospace;
    cursor: pointer;
    min-width: 250px;
}

.solver-select:focus {
    outline: none;
    border-color: #00ff9d;
    box-shadow: 0 0 10px rgba(0, 255, 157, 0.3);
}

.solver-select option {
    background: #0a0a0f;
    color: #00ff9d;
}

.solver-select option:disabled {
    color: #666;
}

.solver-start-btn {
    margin-top: 1rem;
    padding: 0.75rem 2rem;
    font-size: 1rem;
}

.solver-status {
    text-align: center;
    padding: 1rem;
    margin-bottom: 1rem;
    border-radius: 4px;
    font-family: 'JetBrains Mono', monospace;
}

.status-info {
    color: #00b8ff;
    background: rgba(0, 184, 255, 0.1);
    border: 1px solid rgba(0, 184, 255, 0.3);
}

.status-success {
    color: #00ff9d;
    background: rgba(0, 255, 157, 0.1);
    border: 1px solid rgba(0, 255, 157, 0.3);
}

.status-error {
    color: #ff0064;
    background: rgba(255, 0, 100, 0.1);
    border: 1px solid rgba(255, 0, 100, 0.3);
}

.solver-memory-warning {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    background: rgba(255, 157, 0, 0.1);
    border: 1px solid rgba(255, 157, 0, 0.3);
    border-radius: 4px;
    color: #ff9d00;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    margin-top: 1rem;
}

.warning-icon {
    font-size: 1.2rem;
}
```

**6. Add showTab function if needed:**

If showTab doesn't exist yet, add it to handle tab switching:

```javascript
function showTab(tabId) {
    // Hide all tab contents
    document.querySelectorAll('.tab-content').forEach(el => {
        el.style.display = 'none';
    });

    // Deactivate all tab buttons
    document.querySelectorAll('.tab-btn').forEach(el => {
        el.classList.remove('active');
    });

    // Show selected tab
    const tabContent = document.getElementById(tabId + '-section');
    if (tabContent) {
        tabContent.style.display = 'block';
    }

    // Activate selected button
    const activeBtn = document.querySelector(`.tab-btn[onclick*="${tabId}"]`);
    if (activeBtn) {
        activeBtn.classList.add('active');
    }
}
```

**Integration notes:**
- Tab lazy-loads the interactive solver (only initializes on first view)
- Matrix puzzles data is already in `matrixContents` variable
- Style integration follows existing neon/matrix theme
  </action>
  <verify>
1. Run `npx ts-node Metrics/generate_report_only.ts`
2. Open generated index.html
3. Find "Interactive Solver" tab button
4. Click tab - should show setup UI with Matrix and Algorithm dropdowns
5. Select Matrix 1, click "Start Solving"
6. Grid should appear, solving should complete
7. Playback controls should appear
8. Click Play - animation should run through solving steps
9. Test speed slider, step buttons, reset
</verify>
  <done>Interactive Solver tab added to HTMLGenerator.ts with lazy loading, matrix dropdown, algorithm dropdown, start button, integration with all solver modules</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Interactive Solver feature:
- Browser-based BruteForce solver with state emission
- 10K state history with immutable snapshots
- 3D CSS grid with neon glow styling
- Spin animations (clockwise forward, counter-clockwise backtrack)
- Glitch effects (screen shake, alien scramble)
- Animation controller with speed control (1x-100x)
- Playback controls (play/pause, step, reset, skip to end)
- Live info display (iteration, cell, value, depth)
- Dedicated tab in benchmark report
  </what-built>
  <how-to-verify>
1. Generate report: `npx ts-node Metrics/generate_report_only.ts`
2. Open index.html in browser
3. Click "Interactive Solver" tab

**Setup verification:**
4. Matrix dropdown shows options 1-5 (6 disabled)
5. Algorithm dropdown shows "Brute Force Backtracking"

**Basic functionality:**
6. Select Matrix 1, click "Start Solving"
7. Status shows "Solving puzzle..."
8. Grid appears with 3D perspective
9. Initial puzzle shows (some cells filled, others empty)
10. Fixed cells appear dimmed
11. Status shows "Solved in 656 iterations"
12. Controls appear below grid

**Animation verification:**
13. Click Play button
14. Numbers appear with cyan glow, then green when placed
15. Active cell spins clockwise
16. Backtracking cells turn red and spin counter-clockwise
17. Deep backtracks trigger screen shake

**Controls verification:**
18. Pause button stops animation
19. Step Forward advances one iteration
20. Step Back goes back one iteration
21. Reset returns to initial state
22. Skip to End shows solved puzzle
23. Speed slider changes animation rate (try 10x, 50x)
24. Live info updates: iteration count, cell coordinates, value, depth

**Theme verification:**
25. Dark background with neon glow effects
26. Numbers have text-shadow glow
27. Grid has 3D perspective tilt

**Test Matrix 2 (larger):**
28. Select Matrix 2, click Start Solving
29. Should solve (takes a few seconds)
30. Memory warning may appear (history limit)
31. Animation works through captured states
  </how-to-verify>
  <resume-signal>Type "approved" if working correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Overall verification:
1. All solver modules integrate correctly
2. Interactive Solver tab appears in report
3. Matrix/Algorithm selection works
4. Start Solving captures state history
5. Grid renders with 3D perspective and neon styling
6. Animation plays through solving process
7. All playback controls function
8. Speed control (1x-100x) works
9. Glitch effects trigger on backtracks
10. Live info display updates correctly
11. Memory warning shows when history limit reached
12. Tab integrates seamlessly with existing report
</verification>

<success_criteria>
- Interactive Solver accessible as dedicated tab
- Matrix 1-5 selectable (6 disabled)
- Algorithm selection works (BruteForce)
- Solving captures states to history
- 3D grid renders with neon glow
- Animation plays with configurable speed
- Spin animations work (clockwise/counter-clockwise)
- Screen shake on deep backtracks
- All controls functional (play, pause, step, reset, skip)
- Live info shows iteration, cell, value, depth
- Memory warning for large puzzles
- Human verification confirms visual quality
</success_criteria>

<output>
After completion, create `.planning/phases/07-interactive-solver/07-04-SUMMARY.md`
</output>
