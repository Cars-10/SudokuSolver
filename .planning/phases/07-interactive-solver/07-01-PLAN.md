---
phase: 07-interactive-solver
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Metrics/modules/solver-engine.js
  - Metrics/modules/solver-state.js
autonomous: true

must_haves:
  truths:
    - "Browser solver can solve Matrix 1 (656 iterations) correctly"
    - "Solver emits state callback at each iteration with grid, row, col, value, depth"
    - "State history stores up to 10,000 states with immutable snapshots"
    - "State history supports stepForward, stepBack, getCurrentState operations"
    - "History position tracks current playback location"
  artifacts:
    - path: "Metrics/modules/solver-engine.js"
      provides: "Browser-compatible BruteForce solver with state emission"
      exports: ["BruteForceSolver"]
      min_lines: 80
    - path: "Metrics/modules/solver-state.js"
      provides: "Immutable state history with position pointer"
      exports: ["SolverHistory"]
      min_lines: 60
  key_links:
    - from: "Metrics/modules/solver-engine.js"
      to: "onStateChange callback"
      via: "callback invocation"
      pattern: "this\\.onStateChange\\("
    - from: "Metrics/modules/solver-state.js"
      to: "Object.freeze"
      via: "immutability"
      pattern: "Object\\.freeze"
---

<objective>
Create the core solver engine and state management system for the interactive solver.

Purpose: Enable browser-based solving with captured state history for step-by-step animation playback (INT-02)
Output: Two JavaScript modules: solver-engine.js (BruteForce solver) and solver-state.js (state history management)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-interactive-solver/07-CONTEXT.md
@.planning/phases/07-interactive-solver/07-RESEARCH.md

# Existing reference implementation
@Algorithms/BruteForce/JavaScript/Sudoku.js

# Existing modules pattern
@Metrics/modules/screensaver.js
@Metrics/modules/globals.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create browser-compatible BruteForce solver with state emission</name>
  <files>Metrics/modules/solver-engine.js</files>
  <action>
Create a browser-compatible BruteForce Sudoku solver that emits state at each iteration.

**Port from existing implementation:**
Reference `Algorithms/BruteForce/JavaScript/Sudoku.js` but adapt for:
- Browser execution (no fs, no process, no Node-specific APIs)
- State callback emission at each iteration
- Support for both synchronous solving and async/generator-based stepping

**Class structure:**
```javascript
export class BruteForceSolver {
    constructor() {
        this.puzzle = [];       // 9x9 grid
        this.iteration = 0;     // Total iteration count
        this.depth = 0;         // Current recursion depth (backtrack indicator)
        this.onStateChange = null; // Callback function
        this.solved = false;
    }

    // Load puzzle from 2D array or string
    loadPuzzle(input) { ... }

    // Validation: check row, column, 3x3 box
    isValid(row, col, val) { ... }

    // Main solve with state emission
    solve() {
        // Find first empty cell (row-major order)
        // For each candidate 1-9:
        //   this.iteration++;
        //   if (this.onStateChange) {
        //       this.onStateChange({
        //           grid: this.getGridSnapshot(),
        //           row, col,
        //           value: val,
        //           iteration: this.iteration,
        //           depth: this.depth,
        //           isBacktrack: false
        //       });
        //   }
        //   if (isValid) place, recurse
        //   if (!solved) backtrack:
        //       if (this.onStateChange) {
        //           this.onStateChange({ ..., isBacktrack: true });
        //       }
    }

    // Return deep copy of puzzle grid
    getGridSnapshot() {
        return this.puzzle.map(row => [...row]);
    }

    // Reset solver state
    reset() { ... }
}
```

**Key requirements:**
1. **Row-major search order**: top-to-bottom, left-to-right (same as C reference)
2. **Candidate order**: 1-9 ascending
3. **Iteration counting**: Increment BEFORE validity check (matches C reference: 656 for Matrix 1)
4. **State callback**: Called at EVERY iteration, includes isBacktrack flag
5. **Deep copy grid**: getGridSnapshot returns copy to prevent mutation of history
6. **Depth tracking**: Increment on recursive call, decrement on return (indicates backtrack depth)

**Static method for parsing matrix files:**
```javascript
static parseMatrixString(matrixString) {
    // Parse 9 lines of 9 space-separated digits
    // Return 9x9 2D array
}
```

**Test validation:**
Include a simple test at bottom (commented out) that verifies Matrix 1 = 656 iterations:
```javascript
// To test: uncomment and run in Node
// const solver = new BruteForceSolver();
// solver.loadPuzzle([[0,0,3,...], ...]);
// solver.solve();
// console.assert(solver.iteration === 656, 'Matrix 1 should be 656 iterations');
```
  </action>
  <verify>
Create a simple test HTML that loads the module and solves Matrix 1:
```html
<script type="module">
import { BruteForceSolver } from './Metrics/modules/solver-engine.js';
const solver = new BruteForceSolver();
solver.loadPuzzle([[0,0,3,0,2,0,6,0,0],[9,0,0,3,0,5,0,0,1],[0,0,1,8,0,6,4,0,0],[0,0,8,1,0,2,9,0,0],[7,0,0,0,0,0,0,0,8],[0,0,6,7,0,8,2,0,0],[0,0,2,6,0,9,5,0,0],[8,0,0,2,0,3,0,0,9],[0,0,5,0,1,0,3,0,0]]);
let stateCount = 0;
solver.onStateChange = () => stateCount++;
solver.solve();
console.log('Iterations:', solver.iteration, 'States emitted:', stateCount);
console.assert(solver.iteration === 656, 'Expected 656 iterations');
</script>
```
  </verify>
  <done>BruteForceSolver class exports from solver-engine.js, solves Matrix 1 in 656 iterations, emits state at each iteration with grid/row/col/value/depth/isBacktrack</done>
</task>

<task type="auto">
  <name>Task 2: Create state history system with memory limits</name>
  <files>Metrics/modules/solver-state.js</files>
  <action>
Create state history management system for step-by-step animation with memory protection.

**Class structure (from RESEARCH.md pattern):**
```javascript
export class SolverHistory {
    constructor(maxStates = 10000) {
        this.states = [];           // Array of frozen state objects
        this.position = -1;         // Current playback position
        this.maxStates = maxStates; // Memory limit
        this.totalPushed = 0;       // Track total states seen (even if discarded)
    }

    // Add new state (freezes for immutability)
    push(state) {
        // When pushing, truncate any future states beyond position
        this.states.length = this.position + 1;

        // Add frozen copy
        const frozenState = Object.freeze({
            grid: state.grid.map(row => Object.freeze([...row])),
            row: state.row,
            col: state.col,
            value: state.value,
            iteration: state.iteration,
            depth: state.depth,
            isBacktrack: state.isBacktrack
        });

        this.states.push(frozenState);
        this.position++;
        this.totalPushed++;

        // Enforce memory limit: remove oldest states if exceeded
        if (this.states.length > this.maxStates) {
            const excess = this.states.length - this.maxStates;
            this.states.splice(0, excess);
            this.position -= excess;
            if (this.position < 0) this.position = 0;
        }
    }

    // Navigation methods
    canStepBack() {
        return this.position > 0;
    }

    canStepForward() {
        return this.position < this.states.length - 1;
    }

    stepBack() {
        if (this.canStepBack()) {
            this.position--;
        }
        return this.getCurrentState();
    }

    stepForward() {
        if (this.canStepForward()) {
            this.position++;
        }
        return this.getCurrentState();
    }

    getCurrentState() {
        if (this.position >= 0 && this.position < this.states.length) {
            return this.states[this.position];
        }
        return null;
    }

    // Jump to specific position
    goTo(index) {
        if (index >= 0 && index < this.states.length) {
            this.position = index;
        }
        return this.getCurrentState();
    }

    // Jump to start
    goToStart() {
        this.position = 0;
        return this.getCurrentState();
    }

    // Jump to end
    goToEnd() {
        this.position = this.states.length - 1;
        return this.getCurrentState();
    }

    // Clear all history
    clear() {
        this.states = [];
        this.position = -1;
        this.totalPushed = 0;
    }

    // Stats for UI display
    getStats() {
        return {
            totalStates: this.states.length,
            currentPosition: this.position,
            totalPushed: this.totalPushed,
            memoryLimitReached: this.totalPushed > this.maxStates
        };
    }
}
```

**Key requirements:**
1. **Immutability**: Object.freeze on all stored states to prevent accidental mutation
2. **Memory limit**: Default 10,000 states (configurable via constructor)
3. **Circular buffer behavior**: When limit exceeded, oldest states removed
4. **Position tracking**: Allows forward/backward stepping without re-solving
5. **Grid deep freeze**: Both outer array and inner row arrays frozen
6. **Stats for UI**: Track if memory limit was reached (show warning to user)

**Export both class and a singleton factory:**
```javascript
export class SolverHistory { ... }

// Factory for shared instance (used by animation controller)
let sharedInstance = null;
export function getSharedHistory(maxStates = 10000) {
    if (!sharedInstance) {
        sharedInstance = new SolverHistory(maxStates);
    }
    return sharedInstance;
}

export function resetSharedHistory() {
    if (sharedInstance) {
        sharedInstance.clear();
    }
    sharedInstance = null;
}
```
  </action>
  <verify>
Create test to verify memory limit and navigation:
```javascript
import { SolverHistory } from './Metrics/modules/solver-state.js';

// Test memory limit
const history = new SolverHistory(100); // Small limit for testing
for (let i = 0; i < 200; i++) {
    history.push({ grid: [[i]], row: 0, col: 0, value: i % 9 + 1, iteration: i, depth: 0, isBacktrack: false });
}
console.assert(history.states.length === 100, 'Should cap at 100 states');
console.assert(history.totalPushed === 200, 'Should track total pushed');

// Test navigation
const h2 = new SolverHistory();
h2.push({ grid: [[1]], row: 0, col: 0, value: 1, iteration: 1, depth: 0, isBacktrack: false });
h2.push({ grid: [[2]], row: 0, col: 1, value: 2, iteration: 2, depth: 0, isBacktrack: false });
console.assert(h2.canStepBack() === true, 'Should be able to step back');
h2.stepBack();
console.assert(h2.getCurrentState().iteration === 1, 'Should be at iteration 1');
console.assert(h2.canStepForward() === true, 'Should be able to step forward');
```
  </verify>
  <done>SolverHistory class exports from solver-state.js with 10K state limit, stepForward/stepBack navigation, immutable state storage via Object.freeze</done>
</task>

</tasks>

<verification>
Overall verification:
1. Both modules exist in Metrics/modules/
2. solver-engine.js exports BruteForceSolver class
3. solver-state.js exports SolverHistory class and factory functions
4. BruteForceSolver solves Matrix 1 in exactly 656 iterations
5. State callback fires with correct structure (grid, row, col, value, iteration, depth, isBacktrack)
6. SolverHistory respects 10K state limit
7. SolverHistory navigation (stepForward, stepBack, goToStart, goToEnd) works correctly
8. States are frozen (immutable)
</verification>

<success_criteria>
- BruteForceSolver produces 656 iterations for Matrix 1 (verified against C reference)
- State callback emits at every iteration with complete state object
- SolverHistory caps at maxStates (default 10,000)
- Forward/backward stepping works with position tracking
- States are immutable (Object.freeze applied)
- No Node.js-specific APIs used (browser-compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/07-interactive-solver/07-01-SUMMARY.md`
</output>
