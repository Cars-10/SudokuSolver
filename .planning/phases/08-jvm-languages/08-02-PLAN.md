---
phase: 08-jvm-languages
plan: 02
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Kotlin/DLX.kt, Algorithms/DLX/Kotlin/runMe.sh, Algorithms/CP/Kotlin/CP.kt, Algorithms/CP/Kotlin/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Kotlin, demonstrating idiomatic Kotlin patterns while maintaining algorithmic correctness.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms to Kotlin, leveraging Kotlin's modern language features (data classes, null safety, extension functions) while preserving exact algorithm behavior.
Output: Working DLX and CP implementations for Kotlin with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-c-family-languages/07-01-SUMMARY.md
@.planning/phases/07-c-family-languages/07-02-SUMMARY.md
@Algorithms/DLX/C/dlx.h
@Algorithms/DLX/C/dlx_core.c
@Algorithms/DLX/C/dlx_sudoku.c
@Algorithms/CP/C/cp.h
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp_sudoku.c
@Algorithms/BruteForce/Kotlin/Sudoku.kt

**Tech stack available**: Kotlin compiler (kotlinc), Kotlin standard library, JVM runtime
**Established patterns**: Mechanical translation from C, use language-native features for data structures, verify iteration counts
**Constraining decisions**:
- Phase 7: Strict algorithmic correctness over idiomatic style when they conflict
- Phase 8-01 (Java): DLX uses classes for nodes, CP uses bitsets for candidates
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in Kotlin</name>
  <files>Algorithms/DLX/Kotlin/DLX.kt, Algorithms/DLX/Kotlin/runMe.sh</files>
  <action>
Create Algorithms/DLX/Kotlin/ directory structure. Port the DLX algorithm to Kotlin:

**DLX.kt structure**:
- Use Kotlin classes: `class DlxNode(var left: DlxNode?, var right: DlxNode?, var up: DlxNode?, var down: DlxNode?, var column: DlxColumn?, var row: Int)`
- Use Kotlin class: `class DlxColumn(name: String, var size: Int = 0) : DlxNode(...)` extending DlxNode
- Implement `fun coverColumn(c: DlxColumn)` - exact same logic as C
- Implement `fun uncoverColumn(c: DlxColumn)` - exact reversal of cover
- Implement `fun search(k: Int): Boolean` - recursive backtracking
- Implement `fun buildExactCoverMatrix()` - 324 columns for Sudoku constraints
- Implement `fun parseMatrix(filename: String)` - read .matrix file
- Main function with iteration counter: `var iterations = 0`

**Kotlin-specific features to use**:
- Nullable types (DlxNode?) for proper null safety
- Data classes if beneficial (but avoid if it breaks pointer manipulation)
- Use `lateinit var` or nullable types for circular references
- File I/O: `File(filename).readLines()` instead of C-style fopen
- String interpolation: `println("Solved in Iterations=$iterations")`

**Critical requirements**:
- Maintain circular doubly-linked list structure (same pointer manipulation as C)
- Must produce exactly 43 iterations for Matrix 1
- Use same exact cover matrix construction (324 columns)
- Output format must match: puzzle state + "Solved in Iterations=43"

**runMe.sh**:
- Set LANGUAGE="Kotlin", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function: check_toolchain kotlinc, then `kotlinc DLX.kt -include-runtime -d dlx_solver.jar && echo '#!/bin/bash\njava -jar dlx_solver.jar "$@"' > dlx_solver && chmod +x dlx_solver`
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Kotlin collections (LinkedList, ArrayList) for the dancing links structure - we need manual pointer manipulation
- Do NOT add Kotlin-style functional operations (map, filter) to search logic - must match C reference exactly
- Do NOT use Kotlin's lazy initialization for nodes - we need explicit control over construction order
</action>
  <verify>cd Algorithms/DLX/Kotlin && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX implementation compiles cleanly with kotlinc, produces exactly 43 iterations, output format matches C reference, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in Kotlin</name>
  <files>Algorithms/CP/Kotlin/CP.kt, Algorithms/CP/Kotlin/runMe.sh</files>
  <action>
Create Algorithms/CP/Kotlin/ directory structure. Port the CP algorithm to Kotlin:

**CP.kt structure**:
- Use Kotlin class: `class CPGrid(val cells: Array<IntArray>, val candidates: Array<ShortArray>)` where cells is 9x9 Int array, candidates is 9x9 Short array
- Define bitset operations as extension functions or inline functions:
  ```kotlin
  inline fun Short.setBit(bit: Int) = (this.toInt() or (1 shl bit)).toShort()
  inline fun Short.clearBit(bit: Int) = (this.toInt() and (1 shl bit).inv()).toShort()
  inline fun Short.testBit(bit: Int) = (this.toInt() and (1 shl bit)) != 0
  inline fun Short.countBits() = this.toInt().countOneBits()
  ```
- Implement `fun initializeGrid()` - set empty cells to 0x1FF candidates
- Implement `fun assign(grid: CPGrid, row: Int, col: Int, value: Int)` - place value and propagate
- Implement `fun eliminate(grid: CPGrid, row: Int, col: Int, candidates: Short)` - remove candidates and propagate
- Implement `fun propagate(grid: CPGrid): Boolean` - constraint propagation until quiescence
- Implement `fun findMRV(grid: CPGrid): Pair<Int, Int>?` - find cell with minimum remaining values
- Implement `fun solve(grid: CPGrid): Boolean` - recursive search with propagation
- Main function with iteration counter

**Kotlin-specific features to use**:
- Use `Pair<Int, Int>` for row/col return values from findMRV
- Use `?.let` for null-safe MRV handling
- Extension functions for bitset operations on Short type
- Use `when` expressions if beneficial for clarity
- File I/O: `File(filename).readLines()`

**Critical requirements**:
- Use Short (16-bit) for candidate bitsets, not Int or Kotlin's built-in BitSet
- Count every assignment attempt before validity check
- Use MRV heuristic for cell selection (produces 67 iterations)
- Must produce exactly 67 iterations for Matrix 1
- Output format: puzzle state + "Solved in Iterations=67"

**runMe.sh**:
- Set LANGUAGE="Kotlin", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function: check_toolchain kotlinc, then `kotlinc CP.kt -include-runtime -d cp_solver.jar && echo '#!/bin/bash\njava -jar cp_solver.jar "$@"' > cp_solver && chmod +x cp_solver`
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Kotlin's native BitSet class - we need Short (16-bit) for memory efficiency matching C
- Do NOT add Kotlin coroutines or async logic - algorithm must be synchronous for iteration counting
- Do NOT use Kotlin's sequence builders - must maintain straightforward control flow matching C reference
</action>
  <verify>cd Algorithms/CP/Kotlin && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP implementation compiles cleanly with kotlinc, produces exactly 67 iterations, output format matches C reference, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd Algorithms/DLX/Kotlin && ./runMe.sh ../../../Matrices/1.matrix` produces exactly 43 iterations
- [ ] `cd Algorithms/CP/Kotlin && ./runMe.sh ../../../Matrices/1.matrix` produces exactly 67 iterations
- [ ] Both implementations compile without errors
- [ ] Output format matches C reference
- [ ] metrics.json files created for both implementations
</verification>

<success_criteria>

- Both DLX and CP algorithms implemented in Kotlin
- Iteration counts verified: DLX=43, CP=67 for Matrix 1
- Both implementations integrated into benchmark system
- Compilation successful with kotlinc
- Output format matches established conventions
</success_criteria>

<output>
After completion, create `.planning/phases/08-jvm-languages/08-02-SUMMARY.md`
</output>
