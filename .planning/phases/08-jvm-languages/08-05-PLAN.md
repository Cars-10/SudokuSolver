---
phase: 08-jvm-languages
plan: 05
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Clojure/dlx.clj, Algorithms/DLX/Clojure/runMe.sh, Algorithms/CP/Clojure/cp.clj, Algorithms/CP/Clojure/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Clojure, adapting imperative algorithms to Clojure's functional paradigm while maintaining exact iteration counts.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms to Clojure, demonstrating how a functional Lisp on the JVM can implement algorithms requiring mutable state through refs/atoms while preserving algorithmic correctness.
Output: Working DLX and CP implementations for Clojure with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-c-family-languages/07-01-SUMMARY.md
@.planning/phases/07-c-family-languages/07-02-SUMMARY.md
@Algorithms/DLX/C/dlx.h
@Algorithms/DLX/C/dlx_core.c
@Algorithms/DLX/C/dlx_sudoku.c
@Algorithms/CP/C/cp.h
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp_sudoku.c
@Algorithms/BruteForce/Clojure/Sudoku.clj

**Tech stack available**: Clojure, Java interop, JVM runtime
**Established patterns**: Mechanical translation from C, use mutable constructs where needed (atoms/refs), verify iteration counts
**Constraining decisions**:
- Phase 7: Algorithm structure takes precedence over language idioms
- Phase 8 JVM languages: DLX needs pointer manipulation (use deftype with mutable fields), CP uses 16-bit bitsets (Java Short interop)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in Clojure</name>
  <files>Algorithms/DLX/Clojure/dlx.clj, Algorithms/DLX/Clojure/runMe.sh</files>
  <action>
Create Algorithms/DLX/Clojure/ directory structure. Port the DLX algorithm to Clojure:

**dlx.clj structure**:
- Use Clojure deftype with mutable fields (CRITICAL for performance and correctness):
  ```clojure
  (deftype DlxNode [^:unsynchronized-mutable left
                    ^:unsynchronized-mutable right
                    ^:unsynchronized-mutable up
                    ^:unsynchronized-mutable down
                    ^:unsynchronized-mutable column
                    ^:unsynchronized-mutable row])

  (deftype DlxColumn [^String name
                      ^:unsynchronized-mutable size]
    ...)
  ```
- Implement `(defn cover-column [c] ...)` - exact same logic as C, use `set!` for mutations
- Implement `(defn uncover-column [c] ...)` - exact reversal
- Implement `(defn search [k] ...)` - recursive backtracking
- Implement `(defn build-exact-cover-matrix [] ...)` - 324 columns
- Implement `(defn parse-matrix [filename] ...)` - read .matrix file
- Use atom for iteration counter: `(def iterations (atom 0))`
- Main function: `(defn -main [& args] ...)`

**Clojure-specific considerations**:
- Use `deftype` with `^:unsynchronized-mutable`, NOT defrecord (immutable) or refs (too slow)
- Access/set fields with direct field access: `(.left node)`, `(set! (.left node) new-val)`
- File I/O: `(with-open [rdr (io/reader filename)] (doall (line-seq rdr)))`
- Use `(format "Solved in Iterations=%d" @iterations)` for output
- Keep imperative style with `do`, `doseq`, `dotimes` - don't force functional purity
- Use Java interop for mutable arrays if needed: `(make-array DlxNode 1000)`

**Critical requirements**:
- MUST use `deftype` with mutable fields, NOT immutable data structures - dancing links requires in-place mutation
- Maintain circular doubly-linked list structure with direct field mutation via `set!`
- Must produce exactly 43 iterations for Matrix 1
- Use same exact cover matrix construction (324 columns)
- Output format must match: puzzle state + "Solved in Iterations=43"

**runMe.sh**:
- Set LANGUAGE="Clojure", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function: check_toolchain clojure, then `echo '#!/bin/bash\nclojure -M dlx.clj "$@"' > dlx_solver && chmod +x dlx_solver` (or use `clj` if available)
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Clojure's immutable data structures (maps, records) for nodes - the algorithm requires in-place mutation for correctness and performance
- Do NOT use refs or agents - they add transaction overhead and complexity; use deftype with mutable fields
- Do NOT try to make the algorithm purely functional with recursion and immutable updates - iteration counts will be wrong and performance will be terrible
- Do NOT use Clojure's persistent data structures for node storage - we need direct pointer manipulation
</action>
  <verify>cd Algorithms/DLX/Clojure && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX implementation runs successfully with clojure, produces exactly 43 iterations, output format matches C reference, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in Clojure</name>
  <files>Algorithms/CP/Clojure/cp.clj, Algorithms/CP/Clojure/runMe.sh</files>
  <action>
Create Algorithms/CP/Clojure/ directory structure. Port the CP algorithm to Clojure:

**cp.clj structure**:
- Use deftype or defrecord for CPGrid with mutable arrays via Java interop:
  ```clojure
  (deftype CPGrid [^"[[I" cells         ; 2D int array
                   ^"[[S" candidates])  ; 2D short array

  ; Or create with Java interop:
  (defn make-grid []
    (CPGrid. (make-array Integer/TYPE 9 9)
             (make-array Short/TYPE 9 9)))
  ```
- Define bitset operations as functions using Java Short interop:
  ```clojure
  (defn set-bit ^short [^short bits ^long bit]
    (unchecked-short (bit-or bits (bit-shift-left 1 bit))))
  (defn clear-bit ^short [^short bits ^long bit]
    (unchecked-short (bit-and bits (bit-not (bit-shift-left 1 bit)))))
  (defn test-bit [^short bits ^long bit]
    (not= 0 (bit-and bits (bit-shift-left 1 bit))))
  (defn count-bits [^short bits]
    (Integer/bitCount (short bits)))
  ```
- Implement `(defn initialize-grid [] ...)` - set empty cells to 0x1FF candidates
- Implement `(defn assign [grid row col value] ...)` - place value and propagate
- Implement `(defn eliminate [grid row col candidates] ...)` - remove candidates
- Implement `(defn propagate [grid] ...)` - constraint propagation
- Implement `(defn find-mrv [grid] ...)` - return {:row r :col c} or nil
- Implement `(defn solve [grid] ...)` - recursive search
- Use atom for iteration counter: `(def iterations (atom 0))`
- Main function: `(defn -main [& args] ...)`

**Clojure-specific considerations**:
- Use Java arrays (make-array) for mutable 2D grid state during backtracking
- Use type hints `^short`, `^int`, `^long` to avoid reflection and ensure correct types
- Use `unchecked-short` for bitset operations to prevent overflow exceptions
- File I/O: `(with-open [rdr (io/reader filename)] (line-seq rdr))`
- Use aget/aset for array access: `(aget cells row col)`, `(aset cells row col value)`
- Keep imperative style for propagation with `doseq` and mutations

**Critical requirements**:
- Use Java Short (16-bit) for candidate bitsets with proper type hints
- Use mutable Java arrays for grid state (can't use immutable Clojure vectors for backtracking)
- Count every assignment attempt before validity check
- Use MRV heuristic for cell selection (produces 67 iterations)
- Must produce exactly 67 iterations for Matrix 1
- Output format: puzzle state + "Solved in Iterations=67"

**runMe.sh**:
- Set LANGUAGE="Clojure", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function: check_toolchain clojure, then `echo '#!/bin/bash\nclojure -M cp.clj "$@"' > cp_solver && chmod +x cp_solver`
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Clojure vectors for the grid - they're immutable and will cause massive memory overhead during backtracking
- Do NOT avoid Java arrays in favor of Clojure idioms - the algorithm requires mutable state for correctness
- Do NOT use Clojure's atoms/refs for individual cells - use plain Java arrays with aget/aset for performance
- Do NOT try to use core.logic or other Clojure constraint libraries - we need exact C algorithm replication
- Do NOT skip type hints - reflection will make bitset operations very slow and may cause type errors
</action>
  <verify>cd Algorithms/CP/Clojure && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP implementation runs successfully with clojure, produces exactly 67 iterations, output format matches C reference, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd Algorithms/DLX/Clojure && ./runMe.sh ../../../Matrices/1.matrix` produces exactly 43 iterations
- [ ] `cd Algorithms/CP/Clojure && ./runMe.sh ../../../Matrices/1.matrix` produces exactly 67 iterations
- [ ] Both implementations run successfully
- [ ] Output format matches C reference
- [ ] metrics.json files created for both implementations
</verification>

<success_criteria>

- Both DLX and CP algorithms implemented in Clojure
- Iteration counts verified: DLX=43, CP=67 for Matrix 1
- Both implementations integrated into benchmark system
- Successful execution with clojure runtime
- Output format matches established conventions
- Phase 8 complete: All 5 JVM languages (Java, Kotlin, Scala, Groovy, Clojure) have DLX and CP implementations
</success_criteria>

<output>
After completion, create `.planning/phases/08-jvm-languages/08-05-SUMMARY.md`:

# Phase 8 Plan 5: Clojure Algorithms Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- Ported DLX algorithm to Clojure with mutable deftype
- Ported CP algorithm to Clojure with Java array interop
- Verified iteration counts match C reference (DLX: 43, CP: 67)
- Integrated both algorithms into benchmark system
- **Phase 8 complete**: All 5 JVM languages now have DLX and CP implementations

## Files Created/Modified

- `Algorithms/DLX/Clojure/dlx.clj` - Description
- `Algorithms/DLX/Clojure/runMe.sh` - Description
- `Algorithms/CP/Clojure/cp.clj` - Description
- `Algorithms/CP/Clojure/runMe.sh` - Description

## Decisions Made

[Key decisions about mutable state in Clojure, Java interop choices, etc.]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 9: Scripting Languages - Part 1 ready to begin
</output>
