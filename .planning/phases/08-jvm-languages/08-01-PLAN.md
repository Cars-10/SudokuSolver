---
phase: 08-jvm-languages
plan: 01
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Java/DLX.java, Algorithms/DLX/Java/runMe.sh, Algorithms/CP/Java/CP.java, Algorithms/CP/Java/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Java, establishing the first JVM language algorithm implementations.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms from C reference to Java, following established patterns from Phase 7. Java serves as the baseline JVM implementation that other JVM languages can reference.
Output: Working DLX and CP implementations for Java with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-c-family-languages/07-01-SUMMARY.md
@.planning/phases/07-c-family-languages/07-02-SUMMARY.md
@Algorithms/DLX/C/dlx.h
@Algorithms/DLX/C/dlx_core.c
@Algorithms/DLX/C/dlx_sudoku.c
@Algorithms/DLX/C/runMe.sh
@Algorithms/CP/C/cp.h
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp_sudoku.c
@Algorithms/CP/C/runMe.sh
@Algorithms/BruteForce/Java/Sudoku.java

**Tech stack available**: Java JDK (already present for BruteForce), javac compiler, standard Java class structure
**Established patterns**: Mechanical translation from C to preserve algorithm correctness, verification via iteration count matching, runMe.sh integration with common.sh
**Constraining decisions**:
- Phase 7: Strict mechanical translation approach ensures algorithmic correctness
- Phase 7: Use native language features (classes/objects) for data structures but keep algorithm logic identical
- Phase 7: Verify iteration counts match C reference exactly (DLX: 43, CP: 67 for Matrix 1)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in Java</name>
  <files>Algorithms/DLX/Java/DLX.java, Algorithms/DLX/Java/runMe.sh</files>
  <action>
Create Algorithms/DLX/Java/ directory structure. Port the DLX algorithm from C to Java:

**DLX.java structure**:
- Create DlxNode class with fields: left, right, up, down, column, row (references to other nodes)
- Create DlxColumn class extending DlxNode with size field and name
- Implement coverColumn(DlxColumn c) - exact same logic as C (unlink column and all rows)
- Implement uncoverColumn(DlxColumn c) - exact reversal of cover operation
- Implement search(int k) - recursive backtracking with Algorithm X
- Implement buildExactCoverMatrix() - create 324 columns for Sudoku constraints (81 cell constraints, 81 row constraints, 81 column constraints, 81 box constraints)
- Implement parseMatrix(String filename) - read .matrix file and create constraint rows
- Main method that calls parseMatrix, search, and prints results

**Critical requirements**:
- Use ArrayList or arrays for node pool management (avoid creating millions of small objects)
- Maintain circular doubly-linked list structure exactly as in C (DlxColumn.right loops back to root)
- Print output format: puzzle state, then "Solved in Iterations=43" (must be exactly 43 for Matrix 1)
- Use same exact cover mapping: row*81 + col*9 + digit for each placement

**runMe.sh**:
- Set LANGUAGE="Java", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh (note: DLX is 2 levels deep, not 3 like BruteForce)
- compile() function: check_toolchain javac, then javac -d . DLX.java && create dlx_solver wrapper script that runs java -cp . DLX
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Java's built-in LinkedList or similar - we need manual pointer manipulation for cover/uncover operations to work correctly
- Do NOT optimize the search order or add heuristics - must match C reference exactly for iteration count verification
- Do NOT use 0-indexed printing - Sudoku uses 1-9 values, empty cells print as 0
</action>
  <verify>cd Algorithms/DLX/Java && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43" and produces correctly solved puzzle</verify>
  <done>DLX implementation compiles cleanly, produces exactly 43 iterations for Matrix 1, output format matches C reference, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in Java</name>
  <files>Algorithms/CP/Java/CP.java, Algorithms/CP/Java/runMe.sh</files>
  <action>
Create Algorithms/CP/Java/ directory structure. Port the CP algorithm from C to Java:

**CP.java structure**:
- Create CPGrid class with fields: cells (9x9 array of int for placed values), candidates (9x9 array of short for candidate bitsets)
- Define bitset operations: SET_BIT(mask, bit), CLEAR_BIT(mask, bit), TEST_BIT(mask, bit), COUNT_BITS(mask)
- Implement initializeGrid() - set all empty cells to have candidates 0x1FF (bits 1-9 set)
- Implement assign(grid, row, col, value) - place value and propagate constraints (clear that bit from row/col/box peers)
- Implement eliminate(grid, row, col, candidates) - remove impossible candidates and propagate
- Implement propagate(grid) - apply constraint propagation until quiescence (no more eliminations possible)
- Implement findMRV() - find empty cell with Minimum Remaining Values (fewest candidates)
- Implement solve(grid) - recursive search with propagation: propagate, find MRV cell, try each candidate value
- Implement parseMatrix(String filename) and main method with iteration counter

**Critical requirements**:
- Use short (16-bit) for candidate bitsets (bits 1-9 represent values 1-9, bit 0 unused)
- Count every assignment attempt in iterations counter (before validity check)
- Use MRV (Minimum Remaining Values) heuristic for cell selection - this is what produces 67 iterations
- Propagate constraints after each assignment (eliminate candidates from peers)
- Print output format: puzzle state, then "Solved in Iterations=67" (must be exactly 67 for Matrix 1)

**runMe.sh**:
- Set LANGUAGE="Java", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function: check_toolchain javac, then javac -d . CP.java && create cp_solver wrapper script that runs java -cp . CP
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Java's BitSet class - we need 16-bit bitsets (short) for memory efficiency and exact bit manipulation matching C
- Do NOT skip propagation steps - each assignment must propagate constraints to maintain the 67 iteration count
- Do NOT change MRV tie-breaking - must select first cell found with minimum candidates (row-major order) to match C reference
</action>
  <verify>cd Algorithms/CP/Java && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67" and produces correctly solved puzzle</verify>
  <done>CP implementation compiles cleanly, produces exactly 67 iterations for Matrix 1, output format matches C reference, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd Algorithms/DLX/Java && ./runMe.sh ../../../Matrices/1.matrix` produces exactly 43 iterations
- [ ] `cd Algorithms/CP/Java && ./runMe.sh ../../../Matrices/1.matrix` produces exactly 67 iterations
- [ ] Both implementations compile without errors
- [ ] Output format matches C reference (puzzle state + "Solved in Iterations=N")
- [ ] metrics.json files created for both implementations
</verification>

<success_criteria>

- Both DLX and CP algorithms implemented in Java
- Iteration counts verified: DLX=43, CP=67 for Matrix 1
- Both implementations integrated into benchmark system (runMe.sh + metrics.json)
- Compilation successful with standard javac
- Output format matches established conventions
</success_criteria>

<output>
After completion, create `.planning/phases/08-jvm-languages/08-01-SUMMARY.md`:

# Phase 8 Plan 1: Java Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- Ported DLX algorithm to Java
- Ported CP algorithm to Java
- Verified iteration counts match C reference (DLX: 43, CP: 67)
- Integrated both algorithms into benchmark system

## Files Created/Modified

- `Algorithms/DLX/Java/DLX.java` - Description
- `Algorithms/DLX/Java/runMe.sh` - Description
- `Algorithms/CP/Java/CP.java` - Description
- `Algorithms/CP/Java/runMe.sh` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 08-02-PLAN.md (Kotlin)
</output>
