---
phase: 15-shell-and-esoteric-languages
plan: 02
type: execute
depends_on: ["15-01"]
files_modified: [
  Algorithms/DLX/PowerShell/dlx.ps1,
  Algorithms/DLX/PowerShell/runMe.sh,
  Algorithms/CP/PowerShell/cp.ps1,
  Algorithms/CP/PowerShell/runMe.sh
]
---

<objective>
Implement DLX and CP algorithms for PowerShell

Purpose: Leverage PowerShell's object-oriented capabilities and .NET integration to implement advanced algorithms. PowerShell has richer data structures than BASH (hashtables, PSCustomObject, arrays) and native bitwise operators, making it well-suited for DLX and CP implementations.
Output: Working PowerShell implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-shell-and-esoteric-languages/15-01-SUMMARY.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/DLX/C/dlx.h
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp.h
@Algorithms/BruteForce/PowerShell/Sudoku.ps1
@Algorithms/common.sh

**From Plan 01:**
- BASH implementations established shell-based patterns for DLX/CP
- Array index-based approach proven for simulating pointer structures
- Bitwise operations verified for shell environments

**PowerShell Capabilities:**
- Object-oriented: `[PSCustomObject]@{}` for node structures
- Hashtables: `@{}` for associative arrays
- Arrays: `@()` for indexed arrays, `System.Collections.ArrayList` for dynamic arrays
- Native bitwise: `-band`, `-bor`, `-bxor`, `-shl`, `-shr`, `-bnot`
- .NET integration: Access to System.Collections classes if needed
- Strong typing available: `[int]`, `[uint16]`, `[hashtable]`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in PowerShell</name>
  <files>Algorithms/DLX/PowerShell/dlx.ps1, Algorithms/DLX/PowerShell/runMe.sh, Algorithms/DLX/PowerShell/metrics.json</files>
  <action>
Create DLX Algorithm X implementation in PowerShell following the C reference.

**Implementation Strategy:**
- Use `[PSCustomObject]` for node structures with properties: `left`, `right`, `up`, `down`, `column`, `row_id`, `size`
- Store nodes in arrays, use array indices as "pointers" (same as BASH approach, or use direct object references)
- Consider using object references directly (PowerShell allows this): `$node.left = $otherNode`
- Pre-allocate node array (2916 nodes) or use ArrayList for dynamic allocation
- Implement cover/uncover operations using object property manipulation
- Global `$dlx_iterations` variable, increment in `Search` function
- Follow exact C reference logic: column selection (minimum size), row iteration order

**Critical Details:**
- PowerShell script structure: functions defined before use, or use `function` keyword
- Parameters: `param($row, $col, $val)` at function start
- Return values: `return $value` or implicit return (last expression)
- Arrays: `$arr = @()` (empty), `$arr = @(1, 2, 3)` (initialized)
- Object creation: `$node = [PSCustomObject]@{ left=$null; right=$null; ... }`
- Property access: `$node.left`, `$node.left = $other`
- Global variables: `$script:dlx_iterations` for script-level scope

**Avoid:**
- NEVER use CmdletBinding features unnecessarily - keep it simple
- NEVER use Write-Host for output data - use Write-Output or echo
- NEVER assume Unix line endings will work on Windows - let PowerShell handle it
- NEVER skip the shebang in runMe.sh - PowerShell must be invoked correctly

**runMe.sh Pattern:**
```bash
#!/bin/bash
cd "$(dirname "$0")"
LANGUAGE="PowerShell"
SOLVER_BINARY="pwsh dlx.ps1"
METRICS_FILE="metrics.json"
TIMEOUT_SECONDS=300
source ../../common.sh

compile() {
    check_toolchain pwsh
    return $?
}

main "$@"
```

**Output Format:**
Must match C reference exactly.
  </action>
  <verify>
```bash
cd Algorithms/DLX/PowerShell
./runMe.sh ../../Matrices/1.matrix
```
Check output shows "Iterations=43".
  </verify>
  <done>
- `dlx.ps1` implements complete DLX Algorithm X in PowerShell
- `runMe.sh` checks pwsh availability and runs solver
- Execution on Matrix 1 produces exactly 43 iterations
- `metrics.json` contains verified benchmark results
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in PowerShell</name>
  <files>Algorithms/CP/PowerShell/cp.ps1, Algorithms/CP/PowerShell/runMe.sh, Algorithms/CP/PowerShell/metrics.json</files>
  <action>
Create Constraint Propagation algorithm implementation in PowerShell following the C reference.

**Implementation Strategy:**
- Use arrays for grid: `$grid = @(0) * 81`, `$candidates = @(0x3FE) * 81`
- Use PowerShell's native bitwise operators: `-band`, `-bor`, `-bxor`, `-shl`, `-shr`, `-bnot`
- Implement bitset helper functions: `Set-Bit`, `Clear-Bit`, `Has-Bit`, `Count-Bits`, `Get-FirstBit`
- Implement `Eliminate` function to remove candidate and propagate
- Implement `Assign` function (increments `$script:iterations`) to place value
- Implement MRV heuristic: find cell with minimum candidates
- Recursive `Search` function for backtracking
- Initialize grid with clues, then propagate constraints

**Critical Details:**
- PowerShell bitwise operators use hyphen prefix: `-band`, `-bor`, `-shl`, `-shr`
- Type casting: `[uint16]$value` for explicit 16-bit unsigned integers
- Array multiplication creates references (not copies): use `0..80 | ForEach-Object { 0x3FE }` for independent values
- Script-level variable: `$script:iterations = 0` (accessible from functions)
- Array indexing: `$grid[$idx]`
- Arithmetic: `$result = $a + $b` (no special syntax needed)

**Avoid:**
- NEVER use `@(0) * 81` for candidate array - creates shared references, use loop instead
- NEVER use floating-point for bitsets - use `[int]` or `[uint16]`
- NEVER skip propagation after assignment
- NEVER count iterations in Eliminate - only in Assign

**runMe.sh Pattern:**
```bash
#!/bin/bash
cd "$(dirname "$0")"
LANGUAGE="PowerShell"
SOLVER_BINARY="pwsh cp.ps1"
METRICS_FILE="metrics.json"
TIMEOUT_SECONDS=300
source ../../common.sh

compile() {
    check_toolchain pwsh
    return $?
}

main "$@"
```

**Output Format:**
Must match C reference exactly.
  </action>
  <verify>
```bash
cd Algorithms/CP/PowerShell
./runMe.sh ../../Matrices/1.matrix
```
Check output shows "Iterations=67".
  </verify>
  <done>
- `cp.ps1` implements complete CP algorithm in PowerShell
- `runMe.sh` checks pwsh availability and runs solver
- Execution on Matrix 1 produces exactly 67 iterations
- `metrics.json` contains verified benchmark results
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] PowerShell DLX implementation produces 43 iterations on Matrix 1
- [ ] PowerShell CP implementation produces 67 iterations on Matrix 1
- [ ] Both implementations work with pwsh (PowerShell Core)
- [ ] Both runMe.sh scripts check pwsh availability
- [ ] Both metrics.json files contain valid benchmark data
</verification>

<success_criteria>

- Both tasks completed
- All verification checks pass
- PowerShell implementations verified with correct iteration counts
- Object-oriented approach documented for other languages
- Ready for Plan 03 (Awk)
  </success_criteria>

<output>
After completion, create `.planning/phases/15-shell-and-esoteric-languages/15-02-SUMMARY.md`
</output>
