---
phase: 05.1-tier2-languages
plan: 06
type: execute
---

<objective>
Implement F# and Elixir Sudoku solvers with exact algorithm match and C reference output format.

Purpose: Add .NET functional and Erlang VM languages to the Tier 2 benchmark suite
Output: Working F# and Elixir solvers passing all 5 matrix validations with exact iteration counts
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior phases establishing pattern:**
@.planning/phases/05-jvm-modern-languages/05-05-SUMMARY.md (C# .NET pattern)

**Reference implementation:**
@Languages/C/Sudoku.c
@Languages/C_Sharp/Sudoku.cs (.NET pattern)

**Existing code directories:**
@Languages/F_Sharp/
@Languages/Elixir/

**Reference iteration counts:**
- Matrix 1: 656
- Matrix 2: 439,269
- Matrix 3: 98,847
- Matrix 4: 9,085
- Matrix 5: 445,778

**Language notes:**
- F#: .NET functional, ML-family, can use mutable for imperative algorithm
- Elixir: Erlang VM, functional, immutable - need process/agent for counter
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement F# solver</name>
  <files>Languages/F_Sharp/Sudoku.fs, Languages/F_Sharp/Sudoku.fsproj, Languages/F_Sharp/runMe.sh, Languages/F_Sharp/README.md</files>
  <action>
    1. Create Sudoku.fs:
       - F# is ML-family but allows mutable when needed
       - let mutable puzzle = Array2D.zeroCreate<int> 9 9
       - let mutable count = 0
       - let readMatrixFile (filename: string) = ...
       - let printPuzzle () = ...
       - let isValid row col value = ...
       - let rec solve () =
           for value = 1 to 9 do
             count <- count + 1  // increment before validity
             if isValid row col value then ...
       - Use System.Diagnostics.Stopwatch for timing

    2. Create Sudoku.fsproj:
       <Project Sdk="Microsoft.NET.Sdk">
         <PropertyGroup>
           <OutputType>Exe</OutputType>
           <TargetFramework>net8.0</TargetFramework>
         </PropertyGroup>
         <ItemGroup>
           <Compile Include="Sudoku.fs" />
         </ItemGroup>
       </Project>

    3. Create runMe.sh:
       - LANGUAGE="F#"
       - COMPILE_CMD="dotnet build -c Release"
       - SOLVER_BINARY="dotnet run --no-build -c Release --"
       - Or compile to binary: "dotnet publish -c Release -o out"
       - Source ../common.sh

    4. Create README.md
  </action>
  <verify>
    cd Languages/F_Sharp && dotnet run -- ../../Matrices/1.matrix | grep "Iterations=656"
  </verify>
  <done>F# solver matches C reference output format and iteration count (656)</done>
</task>

<task type="auto">
  <name>Task 2: Validate F# on all matrices</name>
  <files>Languages/F_Sharp/metrics.json</files>
  <action>
    1. Run F# solver on all 5 matrices:
       cd Languages/F_Sharp && ./runMe.sh ../../Matrices/{1,2,3,4,5}.matrix

    2. Verify iteration counts match exactly

    3. Update README.md with .NET notes
  </action>
  <verify>
    grep -o '"iterations": [0-9]*' Languages/F_Sharp/metrics.json | head -5
  </verify>
  <done>F# validated on all 5 matrices</done>
</task>

<task type="auto">
  <name>Task 3: Implement Elixir solver</name>
  <files>Languages/Elixir/sudoku.exs, Languages/Elixir/runMe.sh, Languages/Elixir/README.md</files>
  <action>
    1. Create sudoku.exs (Elixir script):
       - Elixir is immutable, need Agent or Process for mutable counter
       - Use Agent.start_link(fn -> 0 end) for counter
       - Agent.update(counter, &(&1 + 1)) to increment
       - def read_matrix_file(filename) do ... end
       - def print_puzzle(puzzle) do ... end
       - def is_valid(puzzle, row, col, value) do ... end
       - def solve(puzzle, counter) do
           for value <- 1..9 do
             Agent.update(counter, &(&1 + 1))
             if is_valid(puzzle, row, col, value) do ...
           end
         end

    2. Elixir data structures:
       - Use list of lists or tuple of tuples for puzzle
       - Updating requires rebuilding (functional style)

    3. Create runMe.sh:
       - LANGUAGE="Elixir"
       - SOLVER_BINARY="elixir sudoku.exs"
       - Source ../common.sh
       - check_toolchain elixir

    4. Create README.md

    Note: Elixir may be slower due to immutable data structure updates.
    Focus on correctness (iteration count) over performance.
  </action>
  <verify>
    cd Languages/Elixir && elixir sudoku.exs ../../Matrices/1.matrix | grep "Iterations=656"
  </verify>
  <done>Elixir solver matches C reference for Matrix 1</done>
</task>

<task type="auto">
  <name>Task 4: Validate Elixir (may be slow)</name>
  <files>Languages/Elixir/metrics.json</files>
  <action>
    1. Run Elixir solver on Matrix 1 first:
       cd Languages/Elixir && ./runMe.sh ../../Matrices/1.matrix

    2. Verify Matrix 1 iteration count: 656

    3. Attempt larger matrices:
       - Elixir's immutable updates may be slow
       - May timeout on Matrix 2-5

    4. If timeouts occur, document in README.md:
       - "Functional language with immutable data"
       - "Iteration count correct, performance limited by paradigm"

    5. Alternative: Use ETS (Erlang Term Storage) for faster mutable state
  </action>
  <verify>
    grep -o '"iterations": [0-9]*' Languages/Elixir/metrics.json | head -1
  </verify>
  <done>Elixir validated on Matrix 1, performance documented</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] F# solver matches C output format and all 5 iteration counts
- [ ] Elixir solver matches C output format for Matrix 1
- [ ] Both metrics.json files populated
- [ ] Both README.md files document validation status
- [ ] Both runMe.sh scripts follow common.sh pattern
</verification>

<success_criteria>
- F# fully validated on all 5 matrices
- Elixir validated on at least Matrix 1 (timeout on larger acceptable)
- Both use common.sh benchmark pattern
- Documentation complete
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-tier2-languages/05.1-06-SUMMARY.md`
</output>
