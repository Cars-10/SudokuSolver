---
phase: 05.1-tier2-languages
plan: 07
type: execute
---

<objective>
Implement Fortran and Ada Sudoku solvers with exact algorithm match and C reference output format.

Purpose: Add classic compiled languages to the Tier 2 benchmark suite
Output: Working Fortran and Ada solvers passing all 5 matrix validations with exact iteration counts
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Reference implementation:**
@Languages/C/Sudoku.c

**Existing code directories:**
@Languages/Fortran/
@Languages/Ada/

**Reference iteration counts:**
- Matrix 1: 656
- Matrix 2: 439,269
- Matrix 3: 98,847
- Matrix 4: 9,085
- Matrix 5: 445,778

**Language notes:**
- Fortran: Scientific computing heritage, column-major by default (CRITICAL!)
- Ada: Safety-critical systems, strong typing, verbose syntax
- Both are compiled, should be fast like C
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Fortran solver</name>
  <files>Languages/Fortran/Sudoku.f90, Languages/Fortran/runMe.sh, Languages/Fortran/README.md</files>
  <action>
    1. Create/fix Sudoku.f90 (Modern Fortran):
       - CRITICAL: Fortran uses column-major order by default
       - Must iterate row-major to match C: do r=1,9; do c=1,9
       - integer :: puzzle(9,9)  ! (row, col) indexing
       - integer :: count = 0
       - subroutine read_matrix_file(filename)
       - subroutine print_puzzle()
       - logical function is_valid(row, col, val)
       - recursive logical function solve()
         do val = 1, 9
           count = count + 1  ! increment before validity check
           if (is_valid(row, col, val)) then ...
         end do

    2. Fortran I/O format:
       - Use formatted write: write(*,'(9(I1,1X))') puzzle(r,:)
       - Or: write(*,'(I1,A)') puzzle(r,c), ' '

    3. Fortran 1-based indexing:
       - Similar to Julia/R, adjust box calculation
       - box_row = ((row-1)/3)*3 + 1

    4. Create runMe.sh:
       - LANGUAGE="Fortran"
       - COMPILE_CMD="gfortran -O2 -o Sudoku Sudoku.f90"
       - SOLVER_BINARY="./Sudoku"
       - Source ../common.sh

    5. Create README.md
  </action>
  <verify>
    cd Languages/Fortran && gfortran -O2 -o Sudoku Sudoku.f90 && ./Sudoku ../../Matrices/1.matrix | grep "Iterations=656"
  </verify>
  <done>Fortran solver matches C reference output format and iteration count (656)</done>
</task>

<task type="auto">
  <name>Task 2: Validate Fortran on all matrices</name>
  <files>Languages/Fortran/metrics.json</files>
  <action>
    1. Run Fortran solver on all 5 matrices:
       cd Languages/Fortran && ./runMe.sh ../../Matrices/{1,2,3,4,5}.matrix

    2. Verify iteration counts match exactly:
       - 656, 439269, 98847, 9085, 445778

    3. Debug if counts don't match:
       - Most likely cause: column-major vs row-major iteration
       - Fortran arrays are column-major, ensure explicit row-first loops

    4. Update README.md with validation results
  </action>
  <verify>
    grep -o '"iterations": [0-9]*' Languages/Fortran/metrics.json | head -5
  </verify>
  <done>Fortran validated on all 5 matrices</done>
</task>

<task type="auto">
  <name>Task 3: Fix Ada solver</name>
  <files>Languages/Ada/Sudoku.adb, Languages/Ada/runMe.sh, Languages/Ada/README.md</files>
  <action>
    1. Review/fix existing Sudoku.adb:
       - Ada has verbose syntax but compiles efficiently
       - type Puzzle_Type is array (1..9, 1..9) of Integer;
       - Count : Integer := 0;
       - procedure Read_Matrix_File(Filename : String);
       - procedure Print_Puzzle;
       - function Is_Valid(Row, Col, Val : Integer) return Boolean;
       - function Solve return Boolean is
           for Val in 1..9 loop
             Count := Count + 1;  -- increment before check
             if Is_Valid(Row, Col, Val) then ...
           end loop;

    2. Ada 1-based indexing like Fortran

    3. Ada output:
       - Put(Integer'Image(puzzle(r,c)));  -- has leading space
       - Or use Text_IO for formatted output

    4. Create runMe.sh:
       - LANGUAGE="Ada"
       - COMPILE_CMD="gnatmake -O2 -o Sudoku Sudoku.adb"
       - SOLVER_BINARY="./Sudoku"
       - Source ../common.sh

    5. Create/update README.md
  </action>
  <verify>
    cd Languages/Ada && gnatmake -O2 -o Sudoku Sudoku.adb && ./Sudoku ../../Matrices/1.matrix | grep "Iterations=656"
  </verify>
  <done>Ada solver matches C reference for Matrix 1</done>
</task>

<task type="auto">
  <name>Task 4: Validate Ada on all matrices</name>
  <files>Languages/Ada/metrics.json</files>
  <action>
    1. Run Ada solver on all 5 matrices:
       cd Languages/Ada && ./runMe.sh ../../Matrices/{1,2,3,4,5}.matrix

    2. Verify iteration counts match exactly

    3. Update README.md with validation results
  </action>
  <verify>
    grep -o '"iterations": [0-9]*' Languages/Ada/metrics.json | head -5
  </verify>
  <done>Ada validated on all 5 matrices</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Fortran solver matches C output format and all 5 iteration counts
- [ ] Ada solver matches C output format and all 5 iteration counts
- [ ] Both metrics.json files populated
- [ ] Both README.md files document validation status
- [ ] Both runMe.sh scripts follow common.sh pattern
- [ ] Row-major iteration order verified in both languages
</verification>

<success_criteria>
- Fortran and Ada fully validated on all 5 matrices
- Both should perform similarly to C (compiled languages)
- Both use common.sh benchmark pattern
- Documentation complete
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-tier2-languages/05.1-07-SUMMARY.md`
</output>
