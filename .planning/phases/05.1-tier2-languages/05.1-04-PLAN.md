---
phase: 05.1-tier2-languages
plan: 04
type: execute
---

<objective>
Implement Julia and R Sudoku solvers with exact algorithm match and C reference output format.

Purpose: Add scientific computing languages to the Tier 2 benchmark suite
Output: Working Julia and R solvers passing all 5 matrix validations with exact iteration counts
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior phases establishing pattern:**
@.planning/phases/03-scripting-languages/03-01-SUMMARY.md

**Reference implementation:**
@Languages/C/Sudoku.c
@Languages/Python/Sudoku.py

**Existing code directories:**
@Languages/Julia/
@Languages/R/ (check if exists, may need to create)

**Reference iteration counts:**
- Matrix 1: 656
- Matrix 2: 439,269
- Matrix 3: 98,847
- Matrix 4: 9,085
- Matrix 5: 445,778

**Language notes:**
- Julia: JIT compiled, fast after warmup, MATLAB-like syntax
- R: Statistical computing, interpreted, may be slow
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Julia solver</name>
  <files>Languages/Julia/Sudoku.jl, Languages/Julia/runMe.sh, Languages/Julia/README.md</files>
  <action>
    1. Create/fix Sudoku.jl:
       - Julia uses 1-based indexing (adjust for 0-based logic!)
       - Use Matrix{Int} or Array{Int,2} for puzzle
       - Global count::Int = 0 for iterations
       - function readMatrixFile(filename::String)
       - function printPuzzle()
       - function isValid(row::Int, col::Int, val::Int)::Bool
         * Remember: Julia is 1-indexed, so box calc differs
       - function solve()::Bool - brute-force
         * global count += 1 for every attempt
       - Use @elapsed or time_ns() for timing

    2. CRITICAL: Julia 1-indexing conversion:
       - Cell scanning: for r in 1:9, for c in 1:9
       - Box calculation: box_row = ((r-1) รท 3) * 3 + 1

    3. Create runMe.sh:
       - LANGUAGE="Julia"
       - SOLVER_BINARY="julia Sudoku.jl"
       - Source ../common.sh
       - check_toolchain julia

    4. Create README.md
  </action>
  <verify>
    cd Languages/Julia && julia Sudoku.jl ../../Matrices/1.matrix | grep "Iterations=656"
  </verify>
  <done>Julia solver matches C reference for Matrix 1</done>
</task>

<task type="auto">
  <name>Task 2: Validate Julia on all matrices</name>
  <files>Languages/Julia/metrics.json</files>
  <action>
    1. Run Julia solver on all 5 matrices:
       cd Languages/Julia && ./runMe.sh ../../Matrices/{1,2,3,4,5}.matrix

    2. Verify iteration counts match exactly

    3. Note JIT warmup behavior in README.md
       - First run may be slower due to compilation
       - Subsequent runs show true performance
  </action>
  <verify>
    grep -o '"iterations": [0-9]*' Languages/Julia/metrics.json | head -5
  </verify>
  <done>Julia validated on all 5 matrices</done>
</task>

<task type="auto">
  <name>Task 3: Implement R solver</name>
  <files>Languages/R/Sudoku.R, Languages/R/runMe.sh, Languages/R/README.md</files>
  <action>
    1. Create Languages/R/ directory if needed

    2. Create Sudoku.R:
       - R uses 1-based indexing (like Julia)
       - Use matrix(0, nrow=9, ncol=9) for puzzle
       - count <<- 0 for global counter (<<- for global assignment)
       - readMatrixFile <- function(filename)
       - printPuzzle <- function()
       - isValid <- function(row, col, val)
       - solve <- function() - brute-force recursive
         * count <<- count + 1 for every attempt
       - Use Sys.time() for timing

    3. R-specific notes:
       - Recursive functions in R can be slow
       - May timeout on larger matrices (acceptable)
       - Use cat() for output (not print())

    4. Create runMe.sh:
       - LANGUAGE="R"
       - SOLVER_BINARY="Rscript Sudoku.R"
       - Source ../common.sh
       - check_toolchain Rscript

    5. Create README.md
  </action>
  <verify>
    cd Languages/R && Rscript Sudoku.R ../../Matrices/1.matrix | grep "Iterations=656"
  </verify>
  <done>R solver matches C reference for Matrix 1</done>
</task>

<task type="auto">
  <name>Task 4: Validate R (expect possible timeouts)</name>
  <files>Languages/R/metrics.json</files>
  <action>
    1. Run R solver on Matrix 1 first:
       cd Languages/R && ./runMe.sh ../../Matrices/1.matrix

    2. Verify Matrix 1 iteration count: 656

    3. Attempt larger matrices (may timeout):
       - R is inherently slow for recursive algorithms
       - Matrix 2-5 may not complete in 5 minutes

    4. Document timeout behavior in README.md
       - This is acceptable for interpreted statistical language
  </action>
  <verify>
    grep -o '"iterations": [0-9]*' Languages/R/metrics.json | head -1
  </verify>
  <done>R validated on Matrix 1, timeout behavior documented</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Julia solver matches C output format and all 5 iteration counts
- [ ] R solver matches C output format for Matrix 1 (timeouts acceptable for 2-5)
- [ ] Both metrics.json files populated
- [ ] Both README.md files document validation status
- [ ] Both runMe.sh scripts follow common.sh pattern
</verification>

<success_criteria>
- Julia fully validated on all 5 matrices
- R validated on Matrix 1 (timeout on larger matrices acceptable)
- Both use common.sh benchmark pattern
- Documentation complete with honest performance notes
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-tier2-languages/05.1-04-SUMMARY.md`
</output>
