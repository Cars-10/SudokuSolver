---
phase: 05.1-tier2-languages
plan: 05
type: execute
---

<objective>
Implement Haskell and OCaml Sudoku solvers with exact algorithm match and C reference output format.

Purpose: Add ML-family functional languages to the Tier 2 benchmark suite
Output: Working Haskell and OCaml solvers passing all 5 matrix validations with exact iteration counts
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Reference implementation:**
@Languages/C/Sudoku.c

**Existing code:**
@Languages/Haskell/Sudoku.hs (has partial implementation - needs fixes)
@Languages/OCaml/

**Reference iteration counts:**
- Matrix 1: 656
- Matrix 2: 439,269
- Matrix 3: 98,847
- Matrix 4: 9,085
- Matrix 5: 445,778

**Functional programming challenges:**
- Must simulate mutable state for iteration counting
- Must maintain imperative algorithm order despite functional style
- Haskell: lazy evaluation, use IORef or State monad for counter
- OCaml: strict evaluation, use ref for mutable counter
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Haskell solver</name>
  <files>Languages/Haskell/Sudoku.hs, Languages/Haskell/runMe.sh, Languages/Haskell/README.md</files>
  <action>
    1. Review existing Sudoku.hs - it has partial implementation but:
       - Output format may not match C exactly
       - Iteration counting may not be identical
       - Need to verify row-major scanning order

    2. Fix Sudoku.hs to match C reference:
       - Use IORef Int for mutable counter (or thread count through recursion)
       - Ensure output format: path, raw rows, "Puzzle:" headers, iterations, timing
       - CRITICAL: Count every attempt (1-9 for each empty cell)
       - Row-major scanning: row 0-8 outer, col 0-8 inner

    3. Approach for iteration counting in Haskell:
       Option A: Thread count through solve function (pure)
         solve :: Board -> Int -> (Bool, Board, Int)
       Option B: Use IORef for mutable counter (impure but simpler)
         counter <- newIORef 0
         modifyIORef counter (+1)

    4. Create runMe.sh:
       - LANGUAGE="Haskell"
       - COMPILE_CMD="ghc -O2 -o Sudoku Sudoku.hs"
       - SOLVER_BINARY="./Sudoku"
       - Source ../common.sh

    5. Create/update README.md
  </action>
  <verify>
    cd Languages/Haskell && ghc -O2 -o Sudoku Sudoku.hs && ./Sudoku ../../Matrices/1.matrix | grep "Iterations=656"
  </verify>
  <done>Haskell solver matches C reference output format and iteration count (656)</done>
</task>

<task type="auto">
  <name>Task 2: Validate Haskell on all matrices</name>
  <files>Languages/Haskell/metrics.json</files>
  <action>
    1. Run Haskell solver on all 5 matrices:
       cd Languages/Haskell && ./runMe.sh ../../Matrices/{1,2,3,4,5}.matrix

    2. Verify iteration counts match exactly:
       - 656, 439269, 98847, 9085, 445778

    3. Debug if counts don't match:
       - Haskell lazy evaluation can cause unexpected ordering
       - Ensure strict evaluation where needed (seq, BangPatterns)
       - Verify cell scanning is truly row-major

    4. Update README.md with functional programming notes
  </action>
  <verify>
    grep -o '"iterations": [0-9]*' Languages/Haskell/metrics.json | head -5
  </verify>
  <done>Haskell validated on all 5 matrices</done>
</task>

<task type="auto">
  <name>Task 3: Implement OCaml solver</name>
  <files>Languages/OCaml/Sudoku.ml, Languages/OCaml/runMe.sh, Languages/OCaml/README.md</files>
  <action>
    1. Create/fix Sudoku.ml:
       - OCaml is strict (easier than Haskell for imperative algorithm)
       - Use Array.make_matrix 9 9 0 for puzzle
       - let count = ref 0 for mutable counter
       - let read_matrix_file filename = ...
       - let print_puzzle () = ...
       - let is_valid row col value = ...
       - let rec solve () =
           for val_ = 1 to 9 do
             incr count;  (* increment BEFORE validity check *)
             if is_valid row col val_ then ...
           done
       - Use Unix.gettimeofday() for timing

    2. OCaml output format:
       - Printf.printf for formatted output
       - Ensure exact spacing matches C

    3. Create runMe.sh:
       - LANGUAGE="OCaml"
       - COMPILE_CMD="ocamlfind ocamlopt -package unix -linkpkg -o Sudoku Sudoku.ml"
       - Or simpler: "ocamlopt -o Sudoku unix.cmxa Sudoku.ml"
       - SOLVER_BINARY="./Sudoku"
       - Source ../common.sh

    4. Create README.md
  </action>
  <verify>
    cd Languages/OCaml && ocamlopt -o Sudoku unix.cmxa Sudoku.ml && ./Sudoku ../../Matrices/1.matrix | grep "Iterations=656"
  </verify>
  <done>OCaml solver matches C reference for Matrix 1</done>
</task>

<task type="auto">
  <name>Task 4: Validate OCaml on all matrices</name>
  <files>Languages/OCaml/metrics.json</files>
  <action>
    1. Run OCaml solver on all 5 matrices:
       cd Languages/OCaml && ./runMe.sh ../../Matrices/{1,2,3,4,5}.matrix

    2. Verify iteration counts match exactly

    3. Update README.md with validation results
  </action>
  <verify>
    grep -o '"iterations": [0-9]*' Languages/OCaml/metrics.json | head -5
  </verify>
  <done>OCaml validated on all 5 matrices</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Haskell solver matches C output format and all 5 iteration counts
- [ ] OCaml solver matches C output format and all 5 iteration counts
- [ ] Both metrics.json files populated
- [ ] Both README.md files document validation status
- [ ] Both runMe.sh scripts follow common.sh pattern
- [ ] Functional programming iteration counting verified correct
</verification>

<success_criteria>
- Haskell and OCaml fully validated on all 5 matrices
- Iteration counts match C reference exactly (proves algorithm equivalence)
- Both use common.sh benchmark pattern
- Documentation complete with functional programming notes
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-tier2-languages/05.1-05-SUMMARY.md`
</output>
