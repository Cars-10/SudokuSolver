---
phase: 18-validation-and-integration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified: [Algorithms/CP/Ada/*, Algorithms/CP/CommonLisp/*, Algorithms/CP/EmacsLisp/*, Algorithms/CP/Haskell/*, Algorithms/CP/Racket/*, Algorithms/CP/Scheme/*, Algorithms/CP/SML/*, Algorithms/CP/Clojure/*, Algorithms/CP/Elixir/*, Algorithms/CP/Erlang/*, Algorithms/CP/PowerShell/*, Algorithms/CP/R/*, .planning/phases/18-validation-and-integration/CP-FIXES.md]
autonomous: false
---

<objective>
Investigate and fix 12 CP implementations with incorrect iteration counts or missing metrics.

Purpose: Bring CP implementation coverage to maximum possible level by fixing algorithmic bugs and generating missing metrics files.
Output: Fixed CP implementations with correct iteration counts (67), updated metrics files, and documentation of any unfixable issues.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-algorithm-dancing-links/02-01-SUMMARY.md
@.planning/phases/03-algorithm-constraint-propagation/03-01-SUMMARY.md

Reference CP implementation: Algorithms/CP/C/cp.c with 67 iterations for Matrix 1

**Issues identified (12 total):**

**Wrong iteration counts (7):**
1. Ada: Empty iteration count (malformed output)
2. CommonLisp: 84 iterations (should be 67)
3. EmacsLisp: 84 iterations (should be 67)
4. Haskell: 77 iterations (should be 67)
5. Racket: 84 iterations (should be 67)
6. Scheme: 84 iterations (should be 67)
7. SML: 94 iterations (should be 67)

**Missing metrics (5):**
8. Clojure: No metrics (Phase 8 notes: CP has bugs)
9. Elixir: No metrics (Phase 12 notes: should work but missing)
10. Erlang: No metrics (Phase 12)
11. PowerShell: No metrics (Phase 15: incomplete/research)
12. R: No metrics (Phase 10: should have been completed)

CP algorithm structure (for debugging reference):
- Bitset-based candidate tracking (bits 1-9)
- Constraint propagation with singleton elimination and hidden singles
- MRV (Minimum Remaining Values) heuristic for cell selection
- Backtracking with proper state restoration
- **Iteration counting**: Count each assign() call (not attempts, not propagation steps)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix wrong iteration count implementations (7 languages)</name>
  <files>Algorithms/CP/Ada/cp.adb, Algorithms/CP/CommonLisp/cp.lisp, Algorithms/CP/EmacsLisp/cp.el, Algorithms/CP/Haskell/cp.hs, Algorithms/CP/Racket/cp.rkt, Algorithms/CP/Scheme/cp.scm, Algorithms/CP/SML/cp.sml</files>
  <action>For each of the 7 languages with wrong iteration counts:

  1. **Analyze iteration counting** - Read the implementation and identify where iterations are counted
  2. **Compare to C reference** - Check if counting logic matches C (count assign() calls, not propagation steps)
  3. **Common bug patterns:**
     - Counting propagation steps in addition to assignments
     - Counting failed attempts vs successful assignments
     - Double-counting in recursive calls
     - Counting initial constraint setup
  4. **Fix the bug** - Correct iteration counting to match reference implementation
  5. **Regenerate metrics** - Run `./runMe.sh ../../../Matrices/1.matrix` to create metrics.json
  6. **Verify** - Confirm iteration count is exactly 67

  Priority order: Start with Lisp family (CommonLisp, EmacsLisp, Racket, Scheme) as they likely share the same bug pattern (all showing 84 iterations).

  If a language cannot be fixed due to fundamental issues, document why in CP-FIXES.md and skip to next language.
  </action>
  <verify>Run validation for each fixed language: `grep "Iterations=67" Algorithms/CP/{Language}/metrics.json`</verify>
  <done>All fixable implementations from the 7 languages now produce 67 iterations, metrics files updated</done>
</task>

<task type="auto">
  <name>Task 2: Investigate and fix missing metrics implementations (5 languages)</name>
  <files>Algorithms/CP/Clojure/metrics.json, Algorithms/CP/Elixir/metrics.json, Algorithms/CP/Erlang/metrics.json, Algorithms/CP/PowerShell/metrics.json, Algorithms/CP/R/metrics.json</files>
  <action>For each of the 5 languages without metrics:

  1. **Attempt to run implementation:**
     ```bash
     cd Algorithms/CP/{Language}
     ./runMe.sh ../../../Matrices/1.matrix
     ```

  2. **Diagnose failure mode:**
     - Compilation error: Fix syntax/type issues
     - Runtime error: Fix logic bugs
     - Timeout: Implementation may be inefficient
     - No output: Check output format matches expected pattern
     - Crashes: Investigate stack/memory issues

  3. **For each language:**
     - **Clojure**: Phase 8 notes say "CP has bugs" - investigate DLX pointer issues affecting CP, attempt fix
     - **Elixir**: Phase 12 notes say CP should work - likely just needs metrics regeneration
     - **Erlang**: No known issues - likely just needs execution
     - **PowerShell**: Phase 15 notes say "incomplete/research" - may be fundamentally broken, document if unfixable
     - **R**: Should work (Phase 10) - likely just needs execution

  4. **Fix and regenerate metrics** if possible
  5. **If unfixable**: Document reason in CP-FIXES.md with technical details

  Test each implementation with Matrix 1 first. If it works, verify iteration count is 67.
  </action>
  <verify>For each fixable language: `ls Algorithms/CP/{Language}/metrics.json` and `grep "Iterations=67"`</verify>
  <done>All fixable implementations have metrics.json with correct iteration count (67), unfixable ones documented</done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <decision>How to handle any unfixable CP implementations</decision>
  <context>After attempting fixes for all 12 implementations, some languages may have fundamental issues preventing correct CP algorithm implementation (e.g., language limitations, deep bugs requiring extensive rewrite).

  For any implementations that cannot be fixed:
  - Document the technical reason (bug description, language limitation, etc.)
  - Decide whether to mark as "known issue" or remove from metrics entirely
  - Consider impact on overall milestone completion
  </context>
  <options>
    <option id="document-issues">
      <name>Document as Known Issues</name>
      <pros>Preserves implementation effort, maintains transparency about language limitations, complete coverage tracking</pros>
      <cons>May show lower success rate in reports, requires clear documentation</cons>
    </option>
    <option id="defer-to-future">
      <name>Defer to Future Work</name>
      <pros>Milestone completes with only working implementations, cleaner success metrics</pros>
      <cons>Loses sight of problematic implementations, may never get fixed</cons>
    </option>
  </options>
  <resume-signal>Choose: "document-issues" to keep problematic implementations visible, or "defer-to-future" to mark them out of scope for v1.3. You can also specify "proceed" if all 12 were fixed successfully.</resume-signal>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive fix report</name>
  <files>.planning/phases/18-validation-and-integration/CP-FIXES.md</files>
  <action>Generate detailed report of all fix attempts:

  Report structure:
  1. **Summary Statistics**
     - Total implementations fixed: [count]
     - Still incorrect: [count]
     - Still missing metrics: [count]
     - Unfixable (documented): [count]

  2. **Fixed Implementations**
     For each fixed language:
     - Language name
     - Original issue (wrong count X or missing metrics)
     - Root cause identified
     - Fix applied
     - New iteration count (should be 67)
     - Verification status

  3. **Remaining Issues**
     For any unfixable implementations:
     - Language name
     - Issue description
     - Technical reason why unfixable
     - Attempted fixes
     - Decision (document-issues or defer-to-future)

  4. **Patterns Identified**
     Common bug patterns found across multiple languages

  5. **Recommendations**
     Any suggestions for preventing similar issues in future implementations

  Include commit references for all fixes.
  </action>
  <verify>CP-FIXES.md exists and documents all 12 fix attempts</verify>
  <done>Comprehensive fix report generated with outcomes for all 12 problematic implementations</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 7 wrong-count implementations investigated
- [ ] All 5 missing-metrics implementations investigated
- [ ] Fixes applied where possible
- [ ] Updated metrics files verify with correct iteration count (67)
- [ ] CP-FIXES.md report generated
- [ ] Decision checkpoint resolved for any unfixable implementations
</verification>

<success_criteria>

- Maximum possible number of CP implementations fixed
- All fixable implementations produce correct iteration count (67)
- Unfixable implementations documented with technical reasons
- Comprehensive fix report created
- New metrics files committed to repository
</success_criteria>

<output>
After completion, create `.planning/phases/18-validation-and-integration/18-03-SUMMARY.md`
</output>
