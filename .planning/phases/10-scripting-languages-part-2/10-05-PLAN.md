---
phase: 10-scripting-languages-part-2
plan: 05
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Octave/dlx.m, Algorithms/DLX/Octave/runMe.sh, Algorithms/CP/Octave/cp.m, Algorithms/CP/Octave/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Octave (MATLAB-compatible), completing Phase 10 scripting language algorithm coverage.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms from C reference to Octave, following established patterns. Octave's cell arrays and structs provide flexible structures for DLX nodes.
Output: Working DLX and CP implementations for Octave with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Octave/Sudoku.m

**Tech stack available**: Octave (already present for BruteForce, MATLAB-compatible)
**Established patterns**: Mechanical translation from C, iteration count verification (DLX: 43, CP: 67), runMe.sh integration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in Octave</name>
  <files>Algorithms/DLX/Octave/dlx.m, Algorithms/DLX/Octave/runMe.sh</files>
  <action>
Create Algorithms/DLX/Octave/ directory structure. Port the DLX algorithm from C to Octave:

**dlx.m structure**:
- Use Octave structs for DlxNode: struct('left', ref, 'right', ref, 'up', ref, 'down', ref, 'column', ref, 'row_id', num)
- Use Octave structs for DlxColumn: struct('node', node_ref, 'size', num, 'name', str)
- Implement function cover_column(c) - exact same logic as C (unlink column and all rows)
- Implement function uncover_column(c) - exact reversal of cover operation
- Implement function search(root, k, solution) - recursive backtracking with Algorithm X
- Implement function build_exact_cover_matrix() - create 324 columns for Sudoku constraints
- Implement function parse_matrix(filename) - read .matrix file and create constraint rows
- Main execution that calls parse_matrix, search, and prints results
- Global variable dlx_iterations (use global keyword) incremented at start of search

**Critical requirements**:
- Use Octave structs as object-like structures (MATLAB/Octave native)
- Maintain circular doubly-linked list structure exactly as in C
- Print output format: puzzle state using fprintf() or disp(), then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + digit
- File structure: all code in single dlx.m file, executable via octave dlx.m <matrix_file>
- Add shebang: #!/usr/bin/env octave
- Octave/MATLAB arrays are 1-indexed - adjust all array indexing accordingly
- Use global keyword to declare and access global variables
- Script should handle command-line arguments via argv()

**runMe.sh**:
- Set LANGUAGE="Octave", SOLVER_BINARY="octave --no-gui --no-window-system dlx.m", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function should check_toolchain octave
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use cell arrays for simple node structures - structs are more appropriate
- Do NOT use Octave's matrix operations for node manipulation - need explicit pointer operations
- Do NOT optimize the search order - must match C reference exactly
- Do NOT use Octave packages (pkg load) - keep implementation self-contained
- Do NOT forget Octave uses 1-based indexing - adjust all loops and array accesses
- Do NOT use classes (classdef) - plain structs and functions are sufficient
</action>
  <verify>cd Algorithms/DLX/Octave && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in Octave</name>
  <files>Algorithms/CP/Octave/cp.m, Algorithms/CP/Octave/runMe.sh</files>
  <action>
Create Algorithms/CP/Octave/ directory structure. Port the CP algorithm from C to Octave:

**cp.m structure**:
- Use Octave struct for CPGrid: struct('values', matrix, 'candidates', matrix) (matrices for bitsets)
- Define bitset helper functions:
  - function result = has_candidate(set, digit) - test bit
  - function result = add_candidate(set, digit) - set bit (returns new value)
  - function result = remove_candidate(set, digit) - clear bit (returns new value)
  - function result = count_candidates(set) - popcount
- Implement init_grid(grid, puzzle) - set empty cells to candidates = hex2dec('1FF') (511)
- Implement assign(grid, row, col, value) - place value and propagate constraints
- Implement eliminate(grid, row, col, candidates_to_remove) - remove candidates and propagate
- Implement propagate(grid) - apply constraint propagation until quiescence
- Implement find_mrv_cell(grid) - find cell with Minimum Remaining Values (returns [row, col] or [])
- Implement cp_search(grid) - recursive search with propagation
- Implement parse_matrix(filename) and main execution with global cp_iterations counter
- Add shebang: #!/usr/bin/env octave
- Octave arrays are 1-indexed - adjust all indexing accordingly
- Use global keyword for counter

**Critical requirements**:
- Use Octave integers for bitsets (uint32 or double - both work for bitwise operations)
- Bitset operations: use bitand(), bitor(), bitshift() or bitxor() functions
- Print output format: puzzle state using fprintf() or disp(), then "Solved in Iterations=67"
- Increment cp_iterations at start of cp_search using global variable
- Octave passes structs by value - explicitly return modified grid
- Custom popcount implementation using bitwise operations
- Script should handle command-line arguments via argv()

**runMe.sh**:
- Set LANGUAGE="Octave", SOLVER_BINARY="octave --no-gui --no-window-system cp.m", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function should check_toolchain octave
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Octave cell arrays for candidates - must use bitsets (integers)
- Do NOT add extra constraint propagation techniques
- Do NOT change MRV selection order
- Do NOT use Octave packages (pkg load) - keep implementation self-contained using only built-in functions
- Do NOT forget Octave uses 1-based indexing for matrices
- Do NOT assume pass-by-reference for structs - explicitly return modified grid
</action>
  <verify>cd Algorithms/CP/Octave && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created, Phase 10 complete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] DLX Octave shows exactly 43 iterations for Matrix 1
- [ ] CP Octave shows exactly 67 iterations for Matrix 1
- [ ] Both produce correctly solved puzzles
- [ ] metrics.json files exist for both
- [ ] No Octave syntax errors or warnings
- [ ] 1-based indexing handled correctly
- [ ] Global variables work correctly
- [ ] Phase 10 complete: All 5 scripting languages (PHP, Lua, R, Julia, Octave) have DLX and CP implementations
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match C reference exactly
- Both implementations integrated into benchmark system
- Phase 10 complete
</success_criteria>

<output>
After completion, create `.planning/phases/10-scripting-languages-part-2/10-05-SUMMARY.md`:

# Phase 10 Plan 5: Octave Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.m` - Description
- `path/to/another.m` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 10 complete. Ready for Phase 11: Functional Languages - Part 1 (Haskell, OCaml, F#, SML, Scheme).
</output>
