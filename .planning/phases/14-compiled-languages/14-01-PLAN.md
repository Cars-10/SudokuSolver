---
phase: 14-compiled-languages
plan: 01
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Pascal/dlx.pas, Algorithms/DLX/Pascal/runMe.sh, Algorithms/CP/Pascal/cp.pas, Algorithms/CP/Pascal/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Pascal, leveraging Pascal's pointer-based linked structures and record types.

Purpose: Extend benchmark suite with Pascal implementations of advanced algorithms, demonstrating Pascal's procedural programming capabilities.
Output: Working DLX and CP Pascal implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-systems-languages/13-01-SUMMARY.md
@Algorithms/BruteForce/Pascal/sudoku.pas
@Algorithms/DLX/C/dlx.c
@Algorithms/CP/C/cp.c

**Tech stack available:** Free Pascal Compiler (fpc), record types, pointers
**Established patterns:**
- DLX uses circular doubly-linked lists with pointer-based nodes
- CP uses bitsets for candidate tracking (bits 1-9)
- Pre-cover given clues in DLX before search
- Iteration counting: DLX at cover/uncover operations, CP at assign operations

**Constraining decisions:**
- All implementations must match C reference iteration counts exactly (DLX: 43, CP: 67 for Matrix 1)
- Use existing BruteForce Pascal implementation patterns for I/O and puzzle parsing
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Pascal</name>
  <files>Algorithms/DLX/Pascal/dlx.pas, Algorithms/DLX/Pascal/runMe.sh</files>
  <action>
Create DLX Algorithm X implementation using Pascal's pointer-based linked structures:
- Define DlxNode record type with left, right, up, down, column pointers
- Define DlxColumn record type for constraint columns
- Implement circular doubly-linked list operations (cover, uncover)
- Build exact cover matrix with 324 columns (81 cells Ã— 4 constraints: row-col, row-val, col-val, box-val)
- Pre-cover given clues BEFORE starting Algorithm X search (critical for matching iteration count)
- Count iterations at cover operations (increment BEFORE covering)
- Use ^ for pointer dereferencing
- Create runMe.sh following existing Pascal BruteForce pattern
- Compile with: fpc -O3 dlx.pas
- Output format must match reference (includes "Solved in Iterations=N")
  </action>
  <verify>
cd Algorithms/DLX/Pascal && ./runMe.sh ../../../Matrices/1.matrix 2>&1 | grep "Iterations="
Should show exactly "Iterations=43"
  </verify>
  <done>
- dlx.pas compiles without errors
- Produces exactly 43 iterations for Matrix 1
- Produces valid solved puzzle (all constraints satisfied)
- metrics.json created with iteration count
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Pascal</name>
  <files>Algorithms/CP/Pascal/cp.pas, Algorithms/CP/Pascal/runMe.sh</files>
  <action>
Create Constraint Propagation solver using Pascal record types and bitsets:
- Define CPGrid record with values: array[0..8, 0..8] of Integer and candidates: array[0..8, 0..8] of Word (use Word for 16-bit bitset)
- Candidates use bits 1-9 for digits (bit 0 unused), initialize to $3FE
- Implement constraint propagation: assign() increments iteration counter, eliminate() for singleton and hidden singles
- MRV heuristic: select cell with minimum remaining candidates
- Deep copy grid for backtracking (Pascal records copy by value with := operator)
- Count iterations in assign() function BEFORE propagation
- Create runMe.sh following Pascal patterns
- Compile with: fpc -O3 cp.pas
- Output format must match reference (includes "Solved in Iterations=N")
  </action>
  <verify>
cd Algorithms/CP/Pascal && ./runMe.sh ../../../Matrices/1.matrix 2>&1 | grep "Iterations="
Should show exactly "Iterations=67"
  </verify>
  <done>
- cp.pas compiles without errors
- Produces exactly 67 iterations for Matrix 1
- Produces valid solved puzzle
- metrics.json created with iteration count
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both DLX and CP Pascal implementations compile without errors
- [ ] DLX produces exactly 43 iterations on Matrix 1
- [ ] CP produces exactly 67 iterations on Matrix 1
- [ ] Both metrics.json files created successfully
- [ ] Both implementations produce valid solved puzzles
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match reference implementations exactly
- No compilation errors or warnings
</success_criteria>

<output>
After completion, create `.planning/phases/14-compiled-languages/14-01-SUMMARY.md` following the summary template with:
- Substantive one-liner describing Pascal DLX and CP implementations
- Task commits (feat(14-01) for each algorithm)
- Files created/modified
- Decisions made (pointer patterns, bitset representation)
- Deviations from plan (if any)
- Verification results
</output>
