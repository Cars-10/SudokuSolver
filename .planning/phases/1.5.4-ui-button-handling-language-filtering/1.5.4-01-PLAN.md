---
phase: 1.5.4-ui-button-handling-language-filtering
plan: 01
type: execute
---

<objective>
Unify lock state management and integrate with benchmark runner.

Purpose: Consolidate the dual lock implementations (modal vs dropdown) and ensure benchmark runs respect locked status.
Output: Single source of truth for lock state, benchmark runner skips locked languages.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Relevant source files:**
@Metrics/report_client.js
@server/index.js

**Current state analysis:**

Two conflicting `toggleLock` implementations exist:

1. **Modal toggleLock (line 589):** Uses `/api/lock` API, writes to LanguagesMetadata.json
   ```javascript
   window.toggleLock = async function (event) {
       // ... calls /api/lock
       body: JSON.stringify({ lang: currentEditingLang, locked: newLockState })
   }
   ```

2. **Dropdown toggleLock (line 1221):** Client-only, uses `window.lockedLanguages` Map
   ```javascript
   window.toggleLock = function (lang) {
       if (window.lockedLanguages.has(lang)) {
           window.lockedLanguages.delete(lang);
       } else {
           window.lockedLanguages.set(lang, Date.now());
       }
       // saves to session_state.json
   }
   ```

**The problem:** Modal function overwrites dropdown function. Lock from modal doesn't sync with dropdown state. Session state and metadata file diverge.

**Solution:** Use session_state.json as single source of truth. Remove /api/lock dependency. Make both UI paths update `window.lockedLanguages` consistently.

**Benchmark runner location:**
- `window.runSolver` (line 1490) - runs single matrix
- `window.runAllSolver` (line 1484) - runs all matrices for a language
- Neither checks `window.lockedLanguages` before running
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unify lock state management</name>
  <files>Metrics/report_client.js</files>
  <action>
1. Remove the modal's async toggleLock function (lines 589-614) that uses /api/lock
2. Rename the dropdown's toggleLock to be the single implementation
3. Update modal lock button handler to call the unified toggleLock(currentEditingLang)
4. Update modal lock button UI to reflect current lock state when modal opens:
   - In openModal() or wherever modal populates, check window.lockedLanguages.has(lang)
   - Set button text/style accordingly ('ðŸ”’ Locked' vs 'ðŸ”“ Unlocked')
5. Ensure saveSessionState() is called after any lock change
6. Verify loadSessionState() properly restores lockedLanguages Map on page load

Key code changes:
- Delete lines 589-614 (async toggleLock)
- Keep lines 1221-1230 (sync toggleLock) as the single implementation
- Add modal-specific wrapper if needed: toggleLockFromModal(event) that calls toggleLock(currentEditingLang) and updates button UI
  </action>
  <verify>
1. Open language modal, click lock button - should toggle lock state
2. Check dropdown - same language should show locked status
3. Refresh page - lock state should persist
4. Lock from dropdown - modal should show correct state when opened
  </verify>
  <done>Single toggleLock function used by both modal and dropdown. Lock state persists in session_state.json only. No /api/lock calls.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate lock checking with benchmark runner</name>
  <files>Metrics/report_client.js</files>
  <action>
1. Modify window.runSolver to check locked status at start:
   ```javascript
   window.runSolver = async function (lang, matrix, event) {
       if (event) event.stopPropagation();

       // Check if language is locked
       if (window.lockedLanguages.has(lang)) {
           console.log(`Skipping ${lang} - locked`);
           // Optionally show brief notification
           return { skipped: true, reason: 'locked' };
       }

       // ... rest of existing code
   }
   ```

2. Modify window.runAllSolver similarly (though it just calls runSolver)

3. Add visual feedback when attempting to run locked language:
   - Brief toast/notification: "Skipped [Lang] - locked"
   - Or highlight the lock icon momentarily

4. Update run buttons in table to show disabled state for locked languages:
   - In applyTableVisibility or a new function, check each row's lang against lockedLanguages
   - Add 'disabled' class or style to run buttons for locked rows
   - Update this when lock state changes

5. Consider: Should clicking run on locked language unlock it, or just skip?
   Decision: Skip with notification (user must explicitly unlock first)
  </action>
  <verify>
1. Lock a language via dropdown or modal
2. Click run button for that language - should show "skipped - locked" message, not run
3. Unlock the language
4. Click run button - should run normally
5. Check console for skip messages when running locked languages
  </verify>
  <done>Benchmark runner checks locked status before running. Locked languages display skip notification. Run buttons show disabled state for locked languages.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Lock from modal syncs with dropdown display
- [ ] Lock from dropdown syncs with modal display
- [ ] Lock state persists across page refresh
- [ ] Running locked language shows skip notification
- [ ] Run buttons visually indicate locked state
- [ ] No console errors during lock/unlock/run operations
- [ ] No /api/lock calls in network tab (removed dependency)
</verification>

<success_criteria>
- Single toggleLock implementation used everywhere
- Lock state stored only in session_state.json
- Benchmark runner skips locked languages with user feedback
- Visual consistency between modal and dropdown lock states
</success_criteria>

<output>
After completion, create `.planning/phases/1.5.4-ui-button-handling-language-filtering/1.5.4-01-SUMMARY.md`
</output>
