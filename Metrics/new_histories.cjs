module.exports = {
    "C": `Born in 1972 at Bell Labs, Dennis Ritchie designed C to implement the Unix operating system. It was created to provide a flexible, efficient alternative to assembly language, offering high-level structure without sacrificing low-level hardware control. Today, C remains the bedrock of modern computing, powering operating systems, embedded devices, and high-performance kernels. In this benchmark, it serves as the "Gold Standard" baseline (1.0x), setting the bar for raw execution speed and memory efficiency against which all other languages are judged.`,

    "C++": `Bjarne Stroustrup created C++ in 1985 at Bell Labs to add object-oriented features to C's raw power. Motivated by the need for better software organization in large systems without incurring performance penalties, it introduced the concept of "zero-cost abstractions." It is the industry giant for game engines, high-frequency trading systems, and real-time simulations where performance is non-negotiable. This benchmark tests whether its complex template metaprogramming and class structures can match the raw speed of its predecessor.`,

    "Rust": `Emerging from Mozilla in 2010, Graydon Hoare designed Rust to solve the age-old dilemma of safety versus speed. It was created to replace C++ in systems programming by guaranteeing memory safety without a garbage collector, using a novel "borrow checker." Ideally suited for high-reliability systems, browser engines, and critical infrastructure, Rust challenges C's dominance. Here, it seeks to prove that strict compile-time safety checks impose zero runtime cost on recursive algorithms.`,

    "Go": `Google engineers Robert Griesemer, Rob Pike, and Ken Thompson unleashed Go in 2009 to tackle the complexity of modern server software. Born from frustration with C++'s build times and complexity, Go emphasizes simplicity, fast compilation, and built-in concurrency. It has become the language of the cloud, powering microservices, containers (Docker), and distributed systems. This benchmark evaluates how its garbage collector and simple type system handle CPU-bound recursion compared to manual memory management.`,

    "Java": `James Gosling at Sun Microsystems introduced Java in 1995 with the promise of "Write Once, Run Anywhere." Designed for portability across diverse consumer electronics, it evolved into the backbone of enterprise computing. Java dominates backend systems, Android development, and big data processing. The benchmark tests the effectiveness of its Just-In-Time (JIT) compiler, seeing if the JVM can optimize bytecode dynamically to rival native compilation speeds after a warm-up period.`,

    "Python": `Guido van Rossum released Python in 1991 as a successor to the ABC language, prioritizing code readability and developer productivity above all else. Its "batteries included" philosophy and clean syntax made it the lingua franca of data science, machine learning, and education. While not designed for raw speed, its massive ecosystem drives modern AI. This benchmark serves as a baseline for interpreted languages, measuring the "Python Tax"—the runtime cost of its dynamic nature and Global Interpreter Lock (GIL).`,

    "JavaScript": `Created in just 10 days by Brendan Eich at Netscape in 1995, JavaScript was meant to be a simple scripting language for browsers. It defied its humble origins to become the universal language of the web, running everything from interactive UIs to server-side Node.js applications. Driven by massive investment in the V8 engine, it is now a highly optimized JIT-compiled language. This test pushes V8 to its limits, seeing if a language designed for the DOM can crunch numbers efficiently.`,

    "TypeScript": `Microsoft introduced TypeScript in 2012 to bring sanity to large-scale JavaScript development. By adding static typing to JS, it enables tooling and safety previously reserved for languages like Java or C#. It compiles down to JavaScript, powering vast enterprise web applications. The benchmark checks if the transpilation process introduces any overhead, or if it simply serves as a safer gateway to the raw speed of the JavaScript engine.`,

    "Zig": `Andrew Kelley started Zig in 2016 to be a modern, pragmatic replacement for C. It rejects hidden control flow and preprocessor magic in favor of explicit, manual memory management and powerful compile-time execution. Gaining traction in systems programming and game development, Zig aims to be the new standard for robust, optimal software. This benchmark tests if its "comptime" features and modern compiler architecture can edge out the decades of optimization in GCC and Clang.`,

    "Assembly": `Assembly is the raw, mnemonic representation of machine code, dating back to the dawn of computing in the late 1940s. It grants the programmer absolute control over every processor cycle and register, bypassing all compiler abstractions. While rarely used for entire applications today, it is essential for bootloaders, firmware, and extreme optimization. In this benchmark, it represents the theoretical speed limit—the fastest possible implementation allowed by the hardware, provided the human programmer can outsmart modern compilers.`,

    "Ada": `Developed in 1980 by Jean Ichbiah for the US Department of Defense, Ada was engineered for safety-critical and real-time systems where failure is not an option. It powers avionics, air traffic control, and railway systems with its strict typing and built-in concurrency. The benchmark puts its heavy safety checks to the test, determining if the overhead of ensuring correctness impacts the execution speed of a raw logic puzzle.`,

    "Fortran": `John Backus at IBM created FORTRAN (Formula Translation) in 1957 as the first high-level programming language. Designed specifically for numeric computation and scientific computing, it revolutionized the field by allowing scientists to write readable code that compiled to efficient machine instructions. It remains the king of supercomputing and physics simulations. This benchmark sees if its legendary array processing prowess translates to recursive backtracking algorithms.`,

    "Pascal": `Niklaus Wirth designed Pascal in 1970 to encourage structured programming and rigorous data typing. Intended initially as a teaching tool, its clarity and efficiency led to widespread adoption in the early PC era (Turbo Pascal) and embedded systems. It laid the groundwork for modern strong typing. Here, it stands as a testament to the efficiency of structured, compiled languages, often surprising observers with performance that rivals C.`,

    "Perl": `Larry Wall released Perl in 1987 as a "Swiss Army chainsaw" for text processing and system administration. Famous for its expressiveness and "There's More Than One Way To Do It" philosophy, it became the glue of the early web. While its usage has waned in favor of Python, it remains powerful for legacy systems and heavy text manipulation. This benchmark tests the speed of its highly optimized, regex-centric interpreter on a purely logical problem.`,

    "PHP": `Rasmus Lerdorf created PHP in 1995 as a simple set of tools for maintaining his personal homepage. It grew organically into the dominant server-side language of the web, powering WordPress and Facebook. Despite criticism of its design inconsistencies, modern PHP (8.0+) features a JIT compiler and significant performance improvements. This test evaluates if a language optimized for request-response web cycles can sustain performance in a CPU-intensive loop.`,

    "Ruby": `Yukihiro Matsumoto released Ruby in 1995 with a focus on developer happiness and the principle of least surprise. Blending Smalltalk's pure object-oriented model with Perl's practicality, it gained massive popularity via the Rails framework. It is a staple of web startups and rapid prototyping. The benchmark measures the cost of its "everything is an object" philosophy and dynamic flexibility against raw computational speed.`,

    "Swift": `Apple introduced Swift in 2014 to replace Objective-C for iOS and macOS development. It was designed to be "fast, safe, and expressive," combining modern language features with a high-performance LLVM-based compiler. It uses Automatic Reference Counting (ARC) instead of a garbage collector. This benchmark tests how ARC handles the rapid allocation and deallocation inherent in recursive solving, comparing it against manual memory management.`,

    "Kotlin": `JetBrains unveiled Kotlin in 2011 to fix the verbosity and design flaws of Java while maintaining 100% interoperability. It has since become the preferred language for Android development. By adding modern features like null safety and coroutines, it aims to be a "better Java." This benchmark checks if these developer-friendly abstractions impose any runtime penalty over standard Java bytecode.`,

    "Scala": `Martin Odersky created Scala in 2004 to fuse object-oriented and functional programming on the Java Virtual Machine. It powers massive data engineering frameworks like Spark. Scala allows for concise, immutable code that compiles to JVM bytecode. The benchmark evaluates the performance cost of its high-level functional idioms and rich type system compared to the more imperative style of Java.`,

    "Haskell": `Standardized in 1990, Haskell is the flagship of purely functional programming. It enforces strict immutability and uses lazy evaluation, meaning code is only executed when its result is needed. Widely used in academia and high-frequency trading for its correctness guarantees, it approaches problems differently. This benchmark challenges Haskell to solve a mutable array problem (Sudoku) using immutable structures, testing the efficiency of its advanced compiler (GHC).`,

    "OCaml": `Developing from the ML family in 1996 at INRIA, OCaml balances functional programming with pragmatic imperative features. It is known for its lightning-fast compiler and strong type inference, finding use in financial trading firms (Jane Street) and static analysis tools. OCaml aims to prove that functional languages can produce native code that rivals C in speed, without the strict purity of Haskell.`,

    "C_Sharp": `Anders Hejlsberg at Microsoft launched C# in 2000 as the cornerstone of the .NET framework. Originally similar to Java, it has evolved into a feature-rich multi-paradigm language supporting everything from enterprise backends to Unity game development. It relies on the CLR (Common Language Runtime). This benchmark tests the efficiency of the .NET JIT compiler and its ability to optimize complex, modern object-oriented code.`,

    "F_Sharp": `Don Syme at Microsoft Research created F# in 2005 to bring functional-first programming to .NET. It allows developers to write concise, robust code for data analysis and financial modeling while retaining access to the vast .NET ecosystem. The benchmark compares its functional approach on the CLR against the imperative style of C#, revealing the cost of functional abstractions on a shared runtime.`,

    "Erlang": `Ericsson developed Erlang in 1986 to build fault-tolerant telephone exchanges. It prioritizes massive concurrency and system reliability ("Let it crash") over raw single-threaded speed. It powers the backbone of messaging apps like WhatsApp. Since Sudoku is a CPU-bound task typically solved on a single core, this benchmark often highlights the trade-off Erlang makes: sacrificing raw computation speed for unparalleled system stability and concurrency.`,

    "Elixir": `José Valim created Elixir in 2011 to bring the power of the Erlang VM (BEAM) to a wider audience with a friendly, Ruby-like syntax. It powers scalable web applications (Phoenix) and distributed systems. Like Erlang, it is not designed for number crunching. This benchmark measures the overhead of the BEAM virtual machine when forced to perform intensive logic operations instead of its usual message-passing duties.`,

    "Julia": `Launched in 2012 at MIT, Julia was designed to solve the "two-language problem"—providing the ease of Python with the speed of C for scientific computing. It uses aggressive JIT compilation and multiple dispatch to generate highly optimized machine code. Ideally suited for math and simulations, this benchmark tests if its startup time (JIT latency) outweighs its raw execution speed on short tasks.`,

    "R": `R appeared in 1993 as an open-source implementation of the S language, focusing on statistical computing and graphics. It is the standard tool for statisticians and data miners. While powerful for vectorized operations on large datasets, R is notoriously slow at scalar loops and recursive functions. This benchmark exposes the performance gap between vectorized statistical code and general-purpose algorithmic logic in R.`,

    "Lua": `Created in 1993 at PUC-Rio in Brazil, Lua was designed as a lightweight, embeddable scripting language. It found a massive niche in the video game industry (World of Warcraft, Roblox) due to its speed and simplicity. The LuaJIT implementation is widely considered the fastest JIT compiler for a dynamic language. This benchmark tests if Lua's minimalist design allows it to punch above its weight class against heavier systems languages.`,

    "Nim": `Andreas Rumpf started Nim in 2008 to combine the readability of Python with the performance of C. It compiles directly to C (or C++), allowing it to leverage existing optimizing compilers like GCC. It offers powerful metaprogramming and memory management options. This benchmark verifies if Nim truly delivers on its promise of "Python-like syntax, C-like speed," potentially matching the baseline.`,

    "D": `Walter Bright released D in 2001 as a re-engineering of C++, keeping the performance but simplifying the syntax and adding safety features. It allows for high-level modeling with low-level control. Despite its technical merits, it has remained a niche player. This benchmark tests its capacity to act as a modern systems language, comparing its execution efficiency directly against its forebears, C and C++.`,

    "Crystal": `Ary Borenszweig created Crystal in 2014 to give Ruby developers a compiled, statically typed alternative. It uses the LLVM backend to achieve C-like performance while maintaining Ruby's elegant syntax. It targets web services and low-level tools. The benchmark tests the efficiency of its LLVM-generated code, seeing if it can deliver systems-level performance with a high-level scripting syntax.`,

    "Dart": `Google released Dart in 2011, initially as a web replacement for JavaScript, but it found its true calling powering the Flutter UI framework. It supports both JIT (for development) and AOT (Ahead-of-Time) compilation for production. This benchmark evaluates the performance of its Dart VM, testing whether a language optimized for UI rendering can also handle raw algorithmic complexity efficiently.`,

    "Bash": `The Bourne Again SHell (Bash) was released by Brian Fox in 1989 as the default shell for the GNU project. It is the glue that holds Unix systems together, designed for launching processes and file manipulation, not computation. Using it to solve Sudoku is a torture test; it forces a command-line interface to perform logic it was never meant to handle. It serves as a "control" for how slow a language can possibly be.`,

    "Awk": `Aho, Weinberger, and Kernighan created Awk at Bell Labs in 1977 for text processing. It views the world as a stream of records and fields. While designed for data extraction, it is a Turing-complete language. This benchmark tests its surprising capability to perform general-purpose logic, often outperforming purely interpreted shells like Bash despite being optimized for text strings, not grids.`,

    "Powershell": `Microsoft developed PowerShell in 2006 to bring object-oriented automation to the Windows command line. Built on .NET, it passes objects rather than text. While powerful for administration, its object overhead is significant. This benchmark measures the cost of wrapping every variable in a .NET object compared to the raw text streams of Unix shells or the native types of compiled languages.`,

    "SQL": `Developed at IBM in 1974, SQL is the standard for managing relational databases. It is declarative—you tell it what you want, not how to get it. However, using Recursive Common Table Expressions (CTEs), it is possible to write a Sudoku solver. This benchmark is a fascinating test of a database query optimizer's ability to execute a pure logic puzzle, turning a query plan into a backtracking algorithm.`,

    "Cobol": `COBOL was designed in 1959 by a committee including Grace Hopper to handle business data processing. Famous for its verbosity and English-like syntax, it runs the world's financial systems to this day. It was never intended for mathematical puzzles. This benchmark tests the legacy performance of a language built for batch transaction processing when forced to perform recursive logic.`,

    "Tcl": `John Ousterhout created Tcl (Tool Command Language) in 1988 to be easily embedded into applications. Its defining feature is that "everything is a string," which allows for powerful dynamic substitution but imposes runtime overhead. Often paired with the Tk toolkit for GUIs, this benchmark tests how Tcl's string-centric internal representation copes with the integer-heavy logic of Sudoku.`,

    "Smalltalk": `Developed at Xerox PARC in 1972, Smalltalk pioneered object-oriented programming. In Smalltalk, everything is an object, and computing happens via message passing. It influenced nearly every modern OO language. This benchmark tests the overhead of its pure object model and dynamic message dispatch system against the static function calls of procedural languages.`,

    "Racket": `Racket evolved from Scheme in 1995 as a platform for language creation and education. It is a programmable programming language, famous for its macro system. As a Lisp dialect, it relies heavily on tail-call optimization for loops. This benchmark tests the efficiency of its runtime and garbage collector when handling the deep recursion required to solve the puzzle.`,

    "Scheme": `Gerald Jay Sussman and Guy L. Steele Jr. created Scheme at MIT in 1975 as a minimalist dialect of Lisp. It emphasizes a small core standard and functional programming elegance. It is widely used in computer science education. The benchmark uses Scheme to demonstrate the performance of a clean, minimal Lisp implementation relying on recursion and immutable lists (or vectors).`,

    "CommonLisp": `Standardized in 1984, Common Lisp unified various Lisp dialects into an industrial-strength language. It supports multiple paradigms, macros, and dynamic typing, often compiling to efficient machine code. It has been used for AI, prototyping, and complex systems (like NASA's Deep Space 1). This test checks if its powerful compiler can optimize dynamic code to rival static languages.`,

    "Prolog": `Developed in 1972 in France, Prolog is the primary logic programming language. Unlike other languages in this benchmark, Prolog uses a built-in inference engine and backtracking search to find solutions—essentially, the Sudoku solving algorithm is part of the language itself. This benchmark tests the efficiency of Prolog's native solver against the hand-written solvers in imperative languages.`,

    "Vimscript": `Vimscript was created in 1991 by Bram Moolenaar as the internal scripting language for the Vim text editor. It allows users to automate editor tasks and write plugins. It was never meant for general-purpose computing. Including it here is a "just because we can" challenge, measuring the performance of an editor's internal interpreter on a task completely outside its design domain.`,

    "EmacsLisp": `Richard Stallman adopted Lisp for the Emacs editor in 1985, creating a programmable environment where the editor itself is mutable. Emacs Lisp (Elisp) allows users to extend the editor's functionality indefinitely. Like Vimscript, this is a test of an embedded editor language, but one with the full power of Lisp behind it.`,

    "VisualBasic": `Microsoft introduced Visual Basic in 1991 to make Windows application development accessible to everyone. Its drag-and-drop design and plain-English syntax launched a revolution in Rapid Application Development (RAD). While often derided by purists, it powered enterprise desktop apps for a decade. This benchmark tests the performance of the classic BASIC syntax running on modern .NET (via VB.NET) or Mono runtimes.`,

    "Vala": `Jürg Billeter created Vala in 2006 to bring modern language features like classes and interfaces to C developers without the overhead of a runtime like Java's. It compiles to C code and uses the GObject system, integrating perfectly with the GNOME desktop stack. This benchmark tests the efficiency of its C code generation and the GObject type system.`,

    "Verilog": `Created in 1984, Verilog is a Hardware Description Language (HDL) used to model electronic systems. It describes circuits, not software instructions. Running a Sudoku solver in Verilog usually involves simulating a hardware circuit that solves the puzzle. This benchmark is unique: it measures the simulation time of a hardware design, offering a glimpse into the world of FPGA and ASIC engineering.`,

    "Brainfuck": `Urban Müller created Brainfuck in 1993 as a minimal Turing-complete language. It has only 8 commands and a memory tape. It is an esoteric language designed to challenge programmers and test the limits of minimalism. Solving Sudoku in Brainfuck is a heroic feat of mental endurance; this benchmark measures the interpreter's ability to run thousands of cryptic instructions to perform simple logic.`,

    "Befunge": `Chris Pressey created Befunge in 1993 to be as difficult to compile as possible. The code is laid out on a 2D grid, and the instruction pointer can move in four directions, allowing for self-modifying, multi-dimensional control flow. It is purely recreational. This benchmark tests the performance of a 2D-grid interpreter, representing the esoteric and "fun" side of programming.`,

    "Wren": `Bob Nystrom developed Wren in 2013 as a small, fast, class-based concurrent scripting language. Think "Smalltalk meets Lua." It is designed to be embedded in applications and games. This benchmark tests if its novel bytecode VM and "fiber" based concurrency model offer a performance edge over established scripting languages like Lua.`,

    "Red": `Nenad Rakocevic released Red in 2011 as a modern take on Rebol. It is a full-stack language that can act as both a low-level system language and a high-level DSL. It aims to be a single executable that can build operating systems or GUIs. This benchmark tests its unique architecture, seeing if a language designed for symbolic flexibility can also handle raw iterative speed.`,

    "Pike": `Developed in 1994 in Sweden, Pike is a dynamic language that looks like C. It powered the early internet servers of Roxen and is optimized for long-running processes and concurrency. It is a precursor to modern async I/O. This benchmark evaluates the performance of this lesser-known but historically significant server-side language.`,

    "Fennel": `Calvin Rose created Fennel in 2016 to bring the syntax of Lisp to the speed and simplicity of Lua. It compiles to Lua code and runs on the LuaJIT or standard Lua runtime. It allows Lisp macros and REPL-driven development in contexts where Lua is standard (like games). This benchmark tests if the abstraction of Lisp syntax adds any cost to Lua's raw speed.`,

    "Janet": `Janet, created by Calvin Rose in 2017, is a functional and imperative language inspired by Clojure and Lua. It is designed for embedding, systems scripting, and rapid prototyping. It features structured data types and a small, efficient C runtime. This benchmark tests the performance of a modern, clean Lisp-like design on a standard algorithm.`,

    "Io": `Steve Dekorte created Io in 2002 as an experiment in pure object orientation. In Io, everything is a message, and concurrency is handled by coroutines. It is known for its simplicity and flexibility. This benchmark tests the cost of extreme dynamism, where every operation involves message passing and dynamic dispatch.`,

    "Factor": `Slava Pestov created Factor in 2003. It is a concatenative, stack-based language, similar to Forth but with high-level features like garbage collection and an optimizing compiler. It encourages small, reusable functions. This benchmark tests if a modern stack language can optimize high-level logic as effectively as register-based languages.`,

    "Icon": `Ralph Griswold created Icon in 1977 at the University of Arizona. It is famous for "goal-directed execution," where expressions succeed or fail, and generators produce sequences of values. This backtracking behavior is built into the language, making it uniquely suited for solving puzzles like Sudoku. This benchmark tests the efficiency of this native backtracking mechanism.`,

    "Raku": `Larry Wall announced Perl 6 (now Raku) in 2000, but it wasn't released until 2015. It is a distinct language from Perl, designed to fix every flaw and add every feature imaginable. It supports gradual typing, grammars, and concurrency. This benchmark tests the "MoarVM" runtime, seeing if the immense power and complexity of Raku can be harnessed for a simple speed test.`,

    "V": `Alexander Medvednikov released V in 2019 to improve upon Go and C. It aims to be simple, fast, and safe, compiling to C for maximum portability and speed. It features automatic memory management without a heavy GC. This benchmark tests if V's promise of C-like performance holds true for recursive algorithms, positioning it as a contender for the next systems language.`,

    "Haxe": `Nicolas Cannasse created Haxe in 2005 as a universal toolkit. It is a strictly typed language that cross-compiles to C++, C#, Java, Python, Lua, and more. It is widely used in game development to target multiple platforms. This benchmark typically compiles Haxe to C++ or HashLink, testing the efficiency of its cross-compilation pipeline compared to writing native code.`
};