# Milestone v1.1: Algorithmic Expansion

**Status:** âœ… SHIPPED 2026-01-13
**Phases:** 1-3
**Total Plans:** 6

## Overview

Expanded the Sudoku Solver benchmark with advanced algorithms (Dancing Links and Constraint Propagation) and enriched language metadata while maintaining the integrity of the core brute-force benchmark. This milestone established a multi-algorithm architecture allowing performance comparisons across different solving approaches.

## Phases

### Phase 1: Metadata Enrichment

**Goal**: Update `metadata.json` to include descriptions, categorization, and history tracking for all 15+ languages.
**Depends on**: Nothing (first phase)
**Plans**: 1 plan

Plans:

- [x] 01-01: Metadata Enrichment (audit, standardize schema, populate fields)

**Details:**

Successfully enriched metadata for ~80 languages with 100% coverage. Created audit scripts to identify missing fields, standardized schema by moving long history entries to descriptions, and populated all languages (A-M and N-Z batches) with paradigm, type system, and concise history information.

**Key artifacts:**
- scripts/audit_metadata.js (verification tool)
- scripts/fix_metadata.js (one-off schema fixer)
- scripts/enrich_metadata_AM.js and enrich_metadata_NZ.js (population scripts)

---

### Phase 2: Algorithm - Dancing Links

**Goal**: Establish `Algorithms/DLX` structure and implement the reference C solver using Algorithm X.
**Depends on**: Phase 1 (conceptually independent)
**Plans**: 3 plans

Plans:

- [x] 02-01: Scaffolding (Create dir structure, build script, headers)
- [x] 02.1: Refactor Structure (INSERTED - Unify directory structure to Algorithms/)
- [x] 02-02: Implementation (Core search algo, Sudoku mapping)

**Details:**

Implemented complete DLX (Dancing Links) solver using Knuth's Algorithm X. Established `Algorithms/DLX/C` structure with build integration. Transformed Sudoku into 324-column exact cover problem (81 position + 81 row + 81 column + 81 box constraints).

**Phase 2.1 (INSERTED)**: Mid-phase discovery that directory structure needed unification. Moved all brute-force solvers from Languages/ to Algorithms/BruteForce/ to align with multi-algorithm architecture. Updated all infrastructure (metrics, docs, tooling) to use new paths.

**Performance**: DLX achieves 43 iterations vs 656 for brute-force on Matrix 1 (15x faster).

**Key decisions:**
- Memory allocation strategy: Pre-allocated node pool (729*4 nodes) for performance
- Iteration counting: Count every dlx_search() call for benchmarking consistency
- Solution tracking: Store row_id (not pointers) for simplified extraction

---

### Phase 3: Algorithm - Constraint Propagation

**Goal**: Establish `Algorithms/CP` structure and implement the reference C solver using Constraint Propagation.
**Depends on**: Phase 2
**Plans**: 2 plans

Plans:

- [x] 03-01: Scaffolding (Create dir structure, build script, headers, data structures)
- [x] 03-02: Implementation (Core propagation, backtracking search, I/O integration)

**Details:**

Implemented full Constraint Propagation solver with two strategies (singleton elimination + hidden singles) and backtracking search using MRV (Minimum Remaining Values) heuristic. Used bitset-based candidate tracking (uint16_t) for efficient operations.

**Performance**: CP achieves 67 iterations vs 656 for brute-force on Matrix 1 (9.8x faster), demonstrating the power of constraint propagation with minimal backtracking.

**Key decisions:**
- Bitset representation: uint16_t for CandidateSet (9 bits for digits 1-9)
- Iteration counting placement: In assign() function, counting every assignment attempt
- Backtracking strategy: Simple memcpy-based state save/restore for CPGrid structure
- MRV heuristic: Select cell with minimum candidate count to minimize branching

---

## Milestone Summary

**Decimal Phases:**

- Phase 2.1: Refactor Structure (inserted after Phase 2 scaffolding to unify directory architecture)

**Key Decisions:**

- Algorithm Separation: Maintain "Red Pill" purity by keeping new algorithms in `Algorithms/[Type]/` separate from brute-force baseline
- Metadata constraints: Keep descriptions < 50 chars for UI cleanliness
- Unified Directory Structure: All brute-force solvers in `Algorithms/BruteForce/`, common.sh at `Algorithms/` level
- DLX Structure: Exact cover formulation with 324 columns, pre-allocated node pool
- CP Structure: Bitset-based candidate tracking with MRV heuristic

**Issues Resolved:**

- Directory structure fragmentation: Unified under Algorithms/ with clear separation by algorithm type
- Metadata incompleteness: Achieved 100% coverage for all ~80 languages
- DLX solution extraction bug: Fixed by adding row_id field to track row membership

**Issues Deferred:**

None - all planned work completed successfully.

**Technical Debt Incurred:**

None significant - clean implementation following established patterns.

---

## Algorithm Performance Comparison

| Matrix | BruteForce | DLX | CP | CP vs BF | DLX vs BF |
|--------|-----------|-----|-------|----------|-----------|
| 1      | 656       | 43  | 67    | 9.8x faster | 15x faster |
| 2      | 439,269   | ~50 | 87,180 | 5.0x faster | ~8800x faster |
| 4      | 9,085     | ~45 | 1,787 | 5.1x faster | ~200x faster |

**Key Insight**: The three algorithms now provide a complete spectrum of Sudoku solving approaches:
1. **BruteForce**: Baseline, no optimizations, simple backtracking (656 iterations)
2. **CP**: Constraint propagation with intelligent search ordering (67 iterations, 9.8x reduction)
3. **DLX**: Exact cover via dancing links, highly optimized (43 iterations, 15x reduction)

---

_For current project status, see .planning/ROADMAP.md_
