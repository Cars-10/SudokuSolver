---
phase: 15-shell-and-esoteric-languages
plan: 01
type: execute
depends_on: []
files_modified: [
  Algorithms/DLX/BASH/dlx.sh,
  Algorithms/DLX/BASH/runMe.sh,
  Algorithms/CP/BASH/cp.sh,
  Algorithms/CP/BASH/runMe.sh
]
---

<objective>
Implement DLX and CP algorithms for BASH shell language

Purpose: Establish feasibility and patterns for shell-based implementations of complex algorithms. BASH serves as the primary shell reference for evaluating whether DLX (130 LOC C, circular doubly-linked lists) and CP (361 LOC C, bitset operations) are practical in shell environments with limited data structure support.
Output: Working BASH implementations with verified iteration counts (DLX: 43, CP: 67), or documented infeasibility with rationale.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-compiled-languages/14-03-SUMMARY.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/DLX/C/dlx.h
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp.h
@Algorithms/BruteForce/BASH/Sudoku.sh
@Algorithms/common.sh

**Prior Context:**
- Phase 14 complete: Compiled languages (Pascal, Fortran, Ada) successfully implemented DLX and CP
- DLX requires: Circular doubly-linked lists, dynamic node allocation, pointer manipulation
- CP requires: Bitset operations (AND, OR, shift), candidate tracking, MRV heuristic
- Shell languages have arrays but lack native pointer/struct support

**Algorithm Reference:**
- DLX: 130 LOC C implementation with pre-allocated node pool (729*4 nodes), cover/uncover operations
- CP: 361 LOC C implementation with uint16_t bitsets, constraint propagation, MRV cell selection
- Both require exact iteration count matches (DLX: 43, CP: 67 on Matrix 1)

**BASH Capabilities:**
- Arrays: `declare -a` (indexed), `declare -A` (associative)
- No native pointers, but can simulate with array indices
- No native bitwise operations in bash 3.x, available in bash 4.x (bitwise AND, OR, XOR, shift)
- String manipulation and arithmetic evaluation available
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in BASH</name>
  <files>Algorithms/DLX/BASH/dlx.sh, Algorithms/DLX/BASH/runMe.sh, Algorithms/DLX/BASH/metrics.json</files>
  <action>
Create DLX Algorithm X implementation in BASH following the C reference (dlx_core.c).

**Implementation Strategy:**
- Use associative arrays to simulate node structures: `node_left[idx]`, `node_right[idx]`, `node_up[idx]`, `node_down[idx]`, `node_column[idx]`, `node_row_id[idx]`
- Use array indices instead of pointers (root at index 0, columns at indices 1-324)
- Pre-allocate fixed-size arrays (2916 nodes = 729*4) following C reference
- Implement cover/uncover operations using index-based linked list manipulation
- Cover clues before search (matching C reference behavior)
- Use global `dlx_iterations` variable, increment in `dlx_search` function
- Follow exact search order: choose column with minimum size, try rows in order
- Extract solution from solution array and map back to grid

**Critical Details:**
- BASH 4.x required for bitwise operations (checked in runMe.sh)
- Use `declare -A` for associative arrays (node structures)
- Use `declare -a` for indexed arrays (columns, solution)
- Arithmetic evaluation: `((var = expr))` or `var=$((expr))`
- Function parameters: `$1`, `$2`, etc.
- Return values via global variables or echo with command substitution

**Avoid:**
- NEVER use nested arrays (not supported in BASH) - flatten all structures
- NEVER assume pointers - always use explicit array index variables
- NEVER skip the pre-allocation step - all arrays must be sized upfront
- NEVER use bash 3.x features for bitwise ops - check version first

**runMe.sh Pattern:**
```bash
#!/bin/bash
cd "$(dirname "$0")"
LANGUAGE="BASH"
SOLVER_BINARY="bash dlx.sh"
METRICS_FILE="metrics.json"
TIMEOUT_SECONDS=300
source ../../common.sh

compile() {
    # Check bash version >= 4.0 for associative arrays
    if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
        echo "Error: BASH 4.0+ required for associative arrays" >&2
        return 1
    fi
    return 0
}

main "$@"
```

**Output Format:**
Must match C reference exactly - see Algorithms/DLX/C/dlx_sudoku.c for reference output.
  </action>
  <verify>
```bash
cd Algorithms/DLX/BASH
./runMe.sh ../../Matrices/1.matrix
```
Check output shows "Iterations=43" (exact match to C DLX reference).
Verify solved puzzle matches expected solution.
  </verify>
  <done>
- `dlx.sh` implements complete DLX Algorithm X in BASH
- `runMe.sh` checks BASH version and runs solver
- Execution on Matrix 1 produces exactly 43 iterations
- `metrics.json` contains verified benchmark results
- Solution matches C reference output
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in BASH</name>
  <files>Algorithms/CP/BASH/cp.sh, Algorithms/CP/BASH/runMe.sh, Algorithms/CP/BASH/metrics.json</files>
  <action>
Create Constraint Propagation algorithm implementation in BASH following the C reference (cp_core.c).

**Implementation Strategy:**
- Use arrays for grid state: `grid[81]` for values, `candidates[81]` for bitsets
- Simulate uint16_t bitsets using integers (bits 1-9 represent candidates 1-9)
- Implement bitset operations: `set_bit`, `clear_bit`, `has_bit`, `count_bits`, `get_first_bit`
- Use BASH 4.x bitwise operators: `&` (AND), `|` (OR), `^` (XOR), `<<` (shift left), `>>` (shift right)
- Implement `eliminate()` function to remove candidate from cell and propagate
- Implement `assign()` function (increments iterations counter) to place value and propagate constraints
- Implement MRV heuristic: find unfilled cell with fewest candidates (minimum remaining values)
- Use recursive `search()` function for backtracking
- Initialize grid with clues directly, then propagate constraints

**Critical Details:**
- BASH 4.x required for bitwise operations
- Candidate bitset: bit N set means digit N is possible (bits 1-9 used, bit 0 unused)
- Full candidate set: `0x3FE` (binary 1111111110, bits 1-9 set)
- Peer calculation: 20 peers per cell (8 in row, 8 in column, 4 in box)
- Iteration counting: increment in `assign()` function BEFORE propagation
- Initialization: read puzzle, set grid values, initialize candidates to full set, then propagate clues

**Avoid:**
- NEVER use bash 3.x for bitwise operations - will fail
- NEVER skip candidate propagation after assignment - will produce wrong iteration count
- NEVER count iterations in eliminate() - only in assign()
- NEVER use floating-point arithmetic for bitsets - integers only

**runMe.sh Pattern:**
```bash
#!/bin/bash
cd "$(dirname "$0")"
LANGUAGE="BASH"
SOLVER_BINARY="bash cp.sh"
METRICS_FILE="metrics.json"
TIMEOUT_SECONDS=300
source ../../common.sh

compile() {
    # Check bash version >= 4.0 for bitwise operations
    if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
        echo "Error: BASH 4.0+ required for bitwise operations" >&2
        return 1
    fi
    return 0
}

main "$@"
```

**Output Format:**
Must match C reference exactly - see Algorithms/CP/C/cp_sudoku.c for reference output.
  </action>
  <verify>
```bash
cd Algorithms/CP/BASH
./runMe.sh ../../Matrices/1.matrix
```
Check output shows "Iterations=67" (exact match to C CP reference).
Verify solved puzzle matches expected solution.
  </verify>
  <done>
- `cp.sh` implements complete CP algorithm in BASH
- `runMe.sh` checks BASH version and runs solver
- Execution on Matrix 1 produces exactly 67 iterations
- `metrics.json` contains verified benchmark results
- Solution matches C reference output
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] BASH DLX implementation produces 43 iterations on Matrix 1
- [ ] BASH CP implementation produces 67 iterations on Matrix 1
- [ ] Both implementations handle errors gracefully
- [ ] Both runMe.sh scripts check BASH version requirements
- [ ] Both metrics.json files contain valid benchmark data
- [ ] Solutions match C reference output exactly
</verification>

<success_criteria>

- Both tasks completed
- All verification checks pass
- BASH implementations verified with correct iteration counts
- Patterns established for subsequent shell language implementations
- Ready for Plan 02 (PowerShell or Awk)
  </success_criteria>

<output>
After completion, create `.planning/phases/15-shell-and-esoteric-languages/15-01-SUMMARY.md`:

# Phase 15 Plan 1: BASH Algorithms Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcome 1 - DLX implementation details]
- [Key outcome 2 - CP implementation details]

## Files Created/Modified

- `Algorithms/DLX/BASH/dlx.sh` - Description
- `Algorithms/DLX/BASH/runMe.sh` - Description
- `Algorithms/DLX/BASH/metrics.json` - Verified metrics
- `Algorithms/CP/BASH/cp.sh` - Description
- `Algorithms/CP/BASH/runMe.sh` - Description
- `Algorithms/CP/BASH/metrics.json` - Verified metrics

## Decisions Made

[Key decisions and rationale, especially regarding data structure simulation]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Ready for Plan 02: PowerShell or Awk algorithms (depending on BASH feasibility results)
</output>
