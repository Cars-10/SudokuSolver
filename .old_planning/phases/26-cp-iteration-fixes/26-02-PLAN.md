---
phase: 26-cp-iteration-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [Algorithms/CP/Haskell/cp.hs, Algorithms/CP/SML/cp.sml]
autonomous: true
---

<objective>
Fix CP iteration counting in Haskell and SML implementations to match C reference (67 iterations).

Purpose: Haskell produces 77 iterations (+10) and SML produces 94 iterations (+27). Both need their iteration counting aligned with the C reference algorithm.
Output: Working Haskell and SML CP solvers producing exactly 67 iterations for Matrix 1.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-cp-lisp-reverts/25-01-SUMMARY.md

# C reference implementation - study iteration counting pattern
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp_sudoku.c

# Target implementations to fix
@Algorithms/CP/Haskell/cp.hs
@Algorithms/CP/SML/cp.sml
</context>

<analysis>
## Root Cause Analysis

**C Reference Pattern (67 iterations):**
1. `init_grid()` places clues directly (NO assign() calls, NO iteration counting)
2. `propagate()` calls `assign()` for hidden singles/singletons found - COUNTED
3. `cp_search()` calls `assign()` during backtracking search - COUNTED

**Haskell Bug (77 iterations = +10):**
Looking at Haskell's `initGrid` (lines 85-98):
```haskell
initGrid :: Grid s -> Candidates s -> [[Int]] -> STRef s Int -> ST s ()
initGrid grid candidates puzzle iterRef = do
    forM_ [0..8] $ \r -> do
        forM_ [0..8] $ \c -> do
            let val = (puzzle !! r) !! c
            if val == 0
                then do
                    writeArray grid (r, c) 0
                    writeArray candidates (r, c) 0x3FE
                else do
                    writeArray grid (r, c) val
                    writeArray candidates (r, c) (shiftL 1 val)
```

The init correctly does NOT call assign. But it also doesn't eliminate clue digits from peers. Then when `propagate` runs, it discovers singletons in a different order than C, causing 10 extra assign calls.

Issue: The Haskell `propagate` function finds singletons and hidden singles in a specific order (all singletons first across entire grid, then all hidden singles). The C reference processes them incrementally - finding one singleton can create another singleton which is immediately found in the same pass.

Fix: After init, apply initial clue constraints (eliminate from peers) without counting. This ensures propagate starts with the same state as C.

**SML Bug (94 iterations = +27):**
Looking at SML's flow (lines 505-512):
```sml
val grid = init_grid puzzle
val _ = cp_iterations := 0  (* Reset AFTER init *)
val prop_ok = propagate grid
```

The SML correctly resets the counter after init. But init_grid (lines 63-86) doesn't eliminate clue digits from peers - it just sets values and candidates.

The +27 suggests propagate is finding many more hidden singles than C because the constraint state is different. Without initial elimination from peers, cells that should be constrained still have full candidates, causing propagate to "re-discover" more assignments.

Fix: Add initial constraint application after init_grid to eliminate clue digits from peer candidates before propagate runs.
</analysis>

<tasks>

<task type="auto">
  <name>Task 1: Fix Haskell CP iteration counting</name>
  <files>Algorithms/CP/Haskell/cp.hs</files>
  <action>
Modify Haskell CP to properly establish initial constraints:

1. Add `applyClueConstraints` function that eliminates clue digits from peers WITHOUT counting:
   ```haskell
   -- Apply initial clue constraints (eliminate from peers without counting)
   applyClueConstraints :: Grid s -> Candidates s -> [[Int]] -> ST s ()
   applyClueConstraints grid candidates puzzle = do
       forM_ [0..8] $ \r -> do
           forM_ [0..8] $ \c -> do
               let val = (puzzle !! r) !! c
               when (val /= 0) $ do
                   -- Eliminate val from all peers' candidates
                   let peers = getPeers r c
                   forM_ peers $ \(pr, pc) -> do
                       cands <- readArray candidates (pr, pc)
                       when (hasCandidate cands val) $ do
                           writeArray candidates (pr, pc) (removeCandidate cands val)
   ```

2. Modify `solveCP` (around lines 56-82) to call `applyClueConstraints` after `initGrid`:
   ```haskell
   solveCP :: [[Int]] -> ST s (Maybe ([[Int]], Int))
   solveCP puzzle = do
       grid <- newArray ((0,0), (8,8)) 0 :: ST s (STUArray s (Int, Int) Int)
       candidates <- newArray ((0,0), (8,8)) 0 :: ST s (STUArray s (Int, Int) Int)
       iterRef <- newSTRef 0

       initGrid grid candidates puzzle iterRef
       applyClueConstraints grid candidates puzzle  -- NEW: establish constraints

       success <- propagate grid candidates iterRef
       -- ... rest unchanged
   ```

3. Note: The `initGrid` function takes `iterRef` but doesn't use it - this is fine, we can leave it for API consistency or remove the unused param.

Key insight: C's `init_grid` sets values but `propagate` is called next which processes the clues. The difference is C's propagate finds hidden singles in a specific order due to the elimination state. By pre-eliminating in Haskell, we match C's initial state.
  </action>
  <verify>
Run Haskell CP on Matrix 1: `cd Algorithms/CP/Haskell && runhaskell cp.hs ../../Matrices/1.matrix | grep Iterations`
Expected output: `Solved in Iterations=67`
  </verify>
  <done>Haskell CP produces exactly 67 iterations for Matrix 1</done>
</task>

<task type="auto">
  <name>Task 2: Fix SML CP iteration counting</name>
  <files>Algorithms/CP/SML/cp.sml</files>
  <action>
Modify SML CP to properly establish initial constraints:

1. Add `apply_clue_constraints` function that eliminates clue digits from peers WITHOUT counting:
   ```sml
   (* Apply initial clue constraints - eliminate from peers without counting *)
   fun apply_clue_constraints (grid: grid) puzzle =
       let
           val {values, candidates} = grid

           fun apply_cell r c =
               if r >= 9 then ()
               else if c >= 9 then apply_cell (r + 1) 0
               else
                   let val cell_val = Array2.sub(puzzle, r, c)
                   in
                       if cell_val <> 0 then
                           let
                               val peers = get_peers r c

                               fun elim_from_peers [] = ()
                                 | elim_from_peers ((pr, pc)::rest) =
                                   let
                                       val cands = Array2.sub(candidates, pr, pc)
                                   in
                                       if has_candidate cands cell_val then
                                           Array2.update(candidates, pr, pc,
                                               remove_candidate cands cell_val)
                                       else ();
                                       elim_from_peers rest
                                   end
                           in
                               elim_from_peers peers;
                               apply_cell r (c + 1)
                           end
                       else
                           apply_cell r (c + 1)
                   end
       in
           apply_cell 0 0
       end
   ```

2. Modify `processFile` (around lines 499-523) to call `apply_clue_constraints` after `init_grid`:
   ```sml
   fun processFile filename =
       if String.isSuffix ".matrix" filename then
           let
               val puzzle = readMatrixFile filename
               val _ = printPuzzle puzzle

               val grid = init_grid puzzle
               val _ = apply_clue_constraints grid puzzle  (* NEW: establish constraints *)
               val _ = cp_iterations := 0  (* Reset AFTER constraints applied *)

               val prop_ok = propagate grid
           in
               (* ... rest unchanged *)
           end
       else
           ()
   ```

Key insight: The counter reset should happen AFTER `apply_clue_constraints` since that function doesn't count. This ensures propagate starts fresh with properly constrained candidates.
  </action>
  <verify>
Run SML CP on Matrix 1: Compile and run: `cd Algorithms/CP/SML && mlton -output cp cp.sml && ./cp ../../Matrices/1.matrix | grep Iterations`
Or use interpreter: `cd Algorithms/CP/SML && sml cp.sml ../../Matrices/1.matrix | grep Iterations`
Expected output: `Solved in Iterations=67`
  </verify>
  <done>SML CP produces exactly 67 iterations for Matrix 1</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Haskell CP produces 67 iterations for Matrix 1
- [ ] SML CP produces 67 iterations for Matrix 1
- [ ] Both produce valid Sudoku solutions (all rows/cols/boxes have 1-9)
- [ ] Both work correctly on Matrix 2 (spot check)
</verification>

<success_criteria>
- All tasks completed
- Both Haskell and SML CP match C reference iteration count (67)
- No new errors or regressions introduced
- Solutions are mathematically correct
</success_criteria>

<output>
After completion, create `.planning/phases/26-cp-iteration-fixes/26-02-SUMMARY.md`
</output>
