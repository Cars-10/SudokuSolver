---
phase: 26-cp-iteration-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [Algorithms/CP/Elixir/cp.exs, Algorithms/CP/Racket/cp.rkt]
autonomous: true
---

<objective>
Fix CP iteration counting in Elixir and Racket implementations to match C reference (67 iterations).

Purpose: Elixir produces 84 iterations (+17) and Racket produces 59 iterations (-8). Both need their iteration counting aligned with the C reference algorithm.
Output: Working Elixir and Racket CP solvers producing exactly 67 iterations for Matrix 1.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-cp-lisp-reverts/25-01-SUMMARY.md

# C reference implementation - study iteration counting pattern
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp_sudoku.c

# Target implementations to fix
@Algorithms/CP/Elixir/cp.exs
@Algorithms/CP/Racket/cp.rkt
</context>

<analysis>
## Root Cause Analysis

**C Reference Pattern (67 iterations):**
1. `init_grid()` places clues directly (NO assign() calls, NO iteration counting)
2. `propagate()` calls `assign()` for hidden singles/singletons found - COUNTED
3. `cp_search()` calls `assign()` during backtracking search - COUNTED

**Elixir Bug (84 iterations = +17):**
The `assign_clues()` function at line 107-119 explicitly calls `assign()` for EVERY initial clue:
```elixir
defp assign_clues(puzzle, grid_agent, cand_agent, counter) do
  Enum.with_index(puzzle)
  |> Enum.each(fn {row, r} ->
    Enum.with_index(row)
    |> Enum.each(fn {digit, c} ->
      if digit != 0 do
        case assign(grid_agent, cand_agent, counter, r, c, digit) do  # BUG: counts clue assignments
```
Fix: Elixir should set clue values directly in `init_grid()` WITHOUT calling `assign()`.

**Racket Bug (59 iterations = -8):**
The initialization at lines 64-74 correctly places clues without calling `assign!`:
```racket
(define (init-grid! g puzzle)
  (for ([r (in-range 9)])
    (for ([c (in-range 9)])
      (define v (vector-ref (vector-ref puzzle r) c))
      (if (= v 0)
          (begin
            (set-val! g r c 0)
            (set-cand! g r c #x3FE))
          (begin
            (set-val! g r c v)
            (set-cand! g r c (arithmetic-shift 1 v)))))))
```

But clues are set without eliminating from peers, which means propagation may not find the same singletons/hidden singles. The C reference doesn't call assign() during init either, but it DOES run propagate() which finds hidden singles.

The issue is likely in how initial constraints are established. After init, we need to eliminate clue values from peers manually before propagate can work correctly. Currently Racket relies on propagate to find clues as "hidden singles" but since candidates aren't properly constrained by clues, propagate behaves differently.

Fix: After setting clue values in init, eliminate the clue digit from all peer candidates (without counting iterations), THEN run propagate().
</analysis>

<tasks>

<task type="auto">
  <name>Task 1: Fix Elixir CP iteration counting</name>
  <files>Algorithms/CP/Elixir/cp.exs</files>
  <action>
Modify Elixir CP to NOT count initial clue assignments:

1. Modify `init_grid/1` to accept the puzzle and place clue values directly:
   ```elixir
   defp init_grid(puzzle) do
     for {row, r} <- Enum.with_index(puzzle) do
       for {digit, _c} <- Enum.with_index(row) do
         digit
       end
     end
   end
   ```

2. Modify `init_candidates/1` to place clue candidates (single bit) and full candidates for empty cells:
   ```elixir
   defp init_candidates(puzzle) do
     for {row, _r} <- Enum.with_index(puzzle) do
       for {digit, _c} <- Enum.with_index(row) do
         if digit == 0, do: 0x3FE, else: 1 <<< digit
       end
     end
   end
   ```

3. Create `apply_initial_constraints/3` that eliminates clue digits from peers WITHOUT incrementing counter:
   ```elixir
   defp apply_initial_constraints(puzzle, grid_agent, cand_agent) do
     Enum.with_index(puzzle)
     |> Enum.each(fn {row, r} ->
       Enum.with_index(row)
       |> Enum.each(fn {digit, c} ->
         if digit != 0 do
           # Eliminate digit from all peers without counting
           eliminate_from_peers_no_count(cand_agent, grid_agent, r, c, digit)
         end
       end)
     end)
   end
   ```

4. Add `eliminate_from_peers_no_count/5` that calls `eliminate_no_count/5` which does NOT call assign:
   ```elixir
   defp eliminate_no_count(cand_agent, _grid_agent, _counter, row, col, digit) do
     cand = Agent.get(cand_agent, fn candidates ->
       Enum.at(Enum.at(candidates, row), col)
     end)
     if not has_candidate?(cand, digit) do
       :ok
     else
       Agent.update(cand_agent, fn candidates ->
         List.update_at(candidates, row, fn r ->
           List.update_at(r, col, fn c -> remove_candidate(c, digit) end)
         end)
       end)
       :ok  # Don't recurse into assign
     end
   end
   ```

5. Remove the `assign_clues/4` function call from `solve_puzzle/1`. Replace with:
   ```elixir
   apply_initial_constraints(puzzle, grid_agent, cand_agent)
   ```

6. Add `propagate/3` function that finds and assigns naked/hidden singles (WITH counting):
   ```elixir
   defp propagate(grid_agent, cand_agent, counter) do
     # Loop until no changes
     case find_and_assign_singles(grid_agent, cand_agent, counter) do
       {:changed, :ok} -> propagate(grid_agent, cand_agent, counter)
       {:changed, :error} -> :error
       {:unchanged, _} -> :ok
     end
   end
   ```

7. Call `propagate/3` before `search/3` in solve_puzzle.

Key insight: The counter should only increment when `assign/6` is called during propagation and search, NOT during initial constraint setup.
  </action>
  <verify>
Run Elixir CP on Matrix 1: `cd Algorithms/CP/Elixir && elixir cp.exs ../../Matrices/1.matrix | grep Iterations`
Expected output: `Solved in Iterations=67`
  </verify>
  <done>Elixir CP produces exactly 67 iterations for Matrix 1</done>
</task>

<task type="auto">
  <name>Task 2: Fix Racket CP iteration counting</name>
  <files>Algorithms/CP/Racket/cp.rkt</files>
  <action>
Modify Racket CP to properly establish initial constraints:

1. After `init-grid!` places clue values, add constraint elimination for clue digits from peers.
   Create `apply-clue-constraints!` that eliminates clue digits without counting:

   ```racket
   (define (apply-clue-constraints! g puzzle)
     (for ([r (in-range 9)])
       (for ([c (in-range 9)])
         (define v (vector-ref (vector-ref puzzle r) c))
         (when (> v 0)
           ;; Eliminate v from all peers' candidates (no iteration counting)
           (for ([peer (get-peers r c)])
             (define pr (car peer))
             (define pc (cdr peer))
             (define cand (get-cand g pr pc))
             (when (has-cand? cand v)
               (set-cand! g pr pc (rem-cand cand v))))))))
   ```

2. Modify the main section (around line 294) to call `apply-clue-constraints!` after `init-grid!`:
   ```racket
   (init-grid! g puz)
   (apply-clue-constraints! g puz)  ;; NEW: establish constraints from clues
   (print-grid g)
   ```

3. The propagate! function already calls assign! correctly (with counting), so hidden singles and naked singles found during propagation will be counted.

4. Verify the issue: The current code relies on `propagate!` to "discover" the initial clues as hidden singles, but since peer candidates aren't eliminated, the propagation logic may find different patterns.

Key insight: C reference sets clue values AND establishes constraints (eliminates from peers) during init, but without counting. Then propagate finds additional singletons (counted). Racket must do the same.
  </action>
  <verify>
Run Racket CP on Matrix 1: `cd Algorithms/CP/Racket && racket cp.rkt ../../Matrices/1.matrix | grep Iterations`
Expected output: `Solved in Iterations=67`
  </verify>
  <done>Racket CP produces exactly 67 iterations for Matrix 1</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Elixir CP produces 67 iterations for Matrix 1
- [ ] Racket CP produces 67 iterations for Matrix 1
- [ ] Both produce valid Sudoku solutions (all rows/cols/boxes have 1-9)
- [ ] Both work correctly on Matrix 2 (spot check)
</verification>

<success_criteria>
- All tasks completed
- Both Elixir and Racket CP match C reference iteration count (67)
- No new errors or regressions introduced
- Solutions are mathematically correct
</success_criteria>

<output>
After completion, create `.planning/phases/26-cp-iteration-fixes/26-01-SUMMARY.md`
</output>
