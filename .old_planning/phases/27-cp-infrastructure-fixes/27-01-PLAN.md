---
phase: 27-cp-infrastructure-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Algorithms/CP/PowerShell/cp.ps1
  - Algorithms/CP/PowerShell/metrics.json
  - Algorithms/CP/Clojure/runMe.sh
  - Algorithms/CP/Clojure/cp_solver
  - Algorithms/CP/Clojure/metrics.json
autonomous: true
---

<objective>
Fix PowerShell CP initialization bug and resolve Clojure CP path resolution issue.

Purpose: Complete the CP infrastructure fixes to achieve correct iteration counts for the remaining broken implementations.

Output: Both PowerShell and Clojure CP implementations producing correct solutions with 67 iterations (or close).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference implementations:
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp_sudoku.c
@Algorithms/CP/Python/cp.py

# Current broken implementations:
@Algorithms/CP/PowerShell/cp.ps1
@Algorithms/CP/Clojure/cp.clj
@Algorithms/CP/Clojure/runMe.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix PowerShell CP initialization logic</name>
  <files>Algorithms/CP/PowerShell/cp.ps1</files>
  <action>
  The root cause: PowerShell calls `Assign()` during clue initialization (lines 444-458), which triggers constraint propagation cascades. This fills cells before all clues are loaded, causing contradictions when later clues try to assign to already-filled cells.

  Fix by following C reference pattern:

  1. **Remove Assign() calls during initialization** - Replace the clue assignment loop (lines 444-459) with direct value/candidate setting:
     ```powershell
     # Initialize clues WITHOUT propagation
     for ($r = 0; $r -lt 9; $r++) {
         for ($c = 0; $c -lt 9; $c++) {
             if ($puzzle[$r,$c] -ne 0) {
                 $digit = $puzzle[$r,$c]
                 $grid_values[$r,$c] = $digit
                 $grid_candidates[$r,$c] = [uint16](1 -shl $digit)
             }
         }
     }
     ```

  2. **Add initial propagation for clue constraints** - After setting clues, eliminate clue values from their peers:
     ```powershell
     # Eliminate clue values from peers (without calling Assign)
     for ($r = 0; $r -lt 9; $r++) {
         for ($c = 0; $c -lt 9; $c++) {
             if ($grid_values[$r,$c] -ne 0) {
                 $digit = $grid_values[$r,$c]
                 $peers = Get-Peers $r $c
                 foreach ($peer in $peers) {
                     $grid_candidates[$peer.r,$peer.c] = Remove-Bit $grid_candidates[$peer.r,$peer.c] $digit
                 }
             }
         }
     }
     ```

  3. **Reset iteration counter AFTER initialization** - Set `$script:iterations = 0` after clue setup, before calling Propagate.

  4. **Remove the already-assigned check in Assign()** - Since we no longer call Assign during initialization, we can simplify Assign() to match C reference (lines 117-139 of cp_core.c). Remove the "already assigned" check at lines 121-132.

  5. **Remove DEBUG output statements** - Clean up debug prints for production run.

  Key insight: The C reference's `init_grid()` sets clues directly WITHOUT calling `assign()`, then calls `propagate()` which handles singleton elimination and hidden singles. PowerShell must follow this pattern.
  </action>
  <verify>
  Run in Docker:
  ```bash
  docker-compose exec -T app bash -c "cd /app/Algorithms/CP/PowerShell && pwsh cp.ps1 /app/Matrices/1.matrix"
  ```
  Expected: Solution found with Iterations=67 (or close)
  </verify>
  <done>PowerShell CP produces correct solution without "Contradiction at clue" errors, iterations close to 67</done>
</task>

<task type="auto">
  <name>Task 2: Fix Clojure CP path resolution</name>
  <files>Algorithms/CP/Clojure/runMe.sh, Algorithms/CP/Clojure/cp_solver</files>
  <action>
  The issue: The cp_solver wrapper script passes relative paths to Clojure, but Clojure's working directory differs from where the script is invoked, causing FileNotFoundException.

  Fix:

  1. **Update cp_solver wrapper** to convert relative paths to absolute:
     ```bash
     #!/bin/bash
     cd "$(dirname "$0")"
     MATRIX_FILE="$1"
     # Convert relative path to absolute
     if [[ ! "$MATRIX_FILE" = /* ]]; then
         MATRIX_FILE="$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"
     fi
     clojure -M cp.clj "$MATRIX_FILE"
     ```

  2. **Alternative simpler fix** - Use absolute path directly in wrapper:
     ```bash
     #!/bin/bash
     SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
     cd "$SCRIPT_DIR"
     # Resolve matrix file path
     MATRIX="$1"
     if [[ "$MATRIX" = "../"* ]] || [[ "$MATRIX" = "./"* ]]; then
         MATRIX="$(cd "$(dirname "$MATRIX")" 2>/dev/null && pwd)/$(basename "$MATRIX")"
     fi
     clojure -M cp.clj "$MATRIX"
     ```

  The wrapper script at `cp_solver` is regenerated by runMe.sh's compile() function. May need to update the heredoc in runMe.sh that generates cp_solver.
  </action>
  <verify>
  Run in Docker:
  ```bash
  docker-compose exec -T app bash -c "cd /app/Algorithms/CP/Clojure && ./runMe.sh /app/Matrices/1.matrix"
  ```
  Expected: Solution found with iterations output (67 expected)
  </verify>
  <done>Clojure CP runs successfully and produces correct solution with 67 iterations</done>
</task>

<task type="auto">
  <name>Task 3: Run full benchmark and validate</name>
  <files>Algorithms/CP/PowerShell/metrics.json, Algorithms/CP/Clojure/metrics.json</files>
  <action>
  Run benchmarks for both fixed implementations:

  1. **PowerShell benchmark** (in Docker):
     ```bash
     docker-compose exec -T app bash -c "cd /app/Algorithms/CP/PowerShell && ./runMe.sh"
     ```

  2. **Clojure benchmark** (in Docker):
     ```bash
     docker-compose exec -T app bash -c "cd /app/Algorithms/CP/Clojure && ./runMe.sh"
     ```

  3. **Validate results** - Check metrics.json files for:
     - Status: "success" for Matrix 1
     - Iterations: 67 (or documented acceptable variation)
     - No errors in output

  4. **Regenerate HTML report** if both succeed:
     ```bash
     cd Metrics && npx ts-node generate_report_only.ts
     ```
  </action>
  <verify>
  ```bash
  # Check PowerShell metrics
  cat Algorithms/CP/PowerShell/metrics.json | grep -A5 '"matrix": "1"'

  # Check Clojure metrics
  cat Algorithms/CP/Clojure/metrics.json | grep -A5 '"matrix": "1"'
  ```
  Both should show status: success and iterations close to 67.
  </verify>
  <done>Both implementations benchmarked with metrics.json updated, iteration counts validated</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] PowerShell CP runs without "Contradiction at clue" errors
- [ ] PowerShell CP produces correct Sudoku solution for Matrix 1
- [ ] PowerShell CP iteration count is 67 (or documented acceptable variation)
- [ ] Clojure CP runs without FileNotFoundException
- [ ] Clojure CP produces correct Sudoku solution for Matrix 1
- [ ] Clojure CP iteration count is 67 (or documented acceptable variation)
- [ ] Both metrics.json files updated with successful results
</verification>

<success_criteria>

- Both PowerShell and Clojure CP implementations produce correct solutions
- Iteration counts match reference (67) or are within acceptable documented variation
- No runtime errors or contradictions during solving
- metrics.json files show "success" status for Matrix 1
</success_criteria>

<output>
After completion, create `.planning/phases/27-cp-infrastructure-fixes/27-01-SUMMARY.md`
</output>
