---
phase: 17-specialized-languages-part-2
plan: 04
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Haxe/DLX.hx, Algorithms/DLX/Haxe/runMe.sh, Algorithms/CP/Haxe/CP.hx, Algorithms/CP/Haxe/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Haxe language, leveraging Haxe's cross-platform toolkit features and strong typing with type inference.

Purpose: Extend the benchmark suite with Haxe implementations of advanced algorithms, demonstrating Haxe's ability to compile to native code while providing modern language features and maintaining algorithm correctness.
Output: Working DLX and CP Haxe implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference implementations
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Haxe/Sudoku.hx

# Prior phase patterns
@.planning/phases/16-specialized-languages-part-1/16-01-SUMMARY.md
@.planning/phases/16-specialized-languages-part-1/16-02-SUMMARY.md

**Tech stack available**: Haxe compiler targeting C++/HL/interp, class-based OOP, strong typing
**Established patterns**:
- DLX uses circular doubly-linked lists with class-based mutable nodes
- CP uses mutable arrays with bitsets for candidates (Int for bits 1-9)
- Target iteration counts: DLX=43, CP=67
- Haxe provides Java/C#-like syntax that compiles to multiple targets

**Key decisions from previous phases**:
- Use class DlxNode with nullable references for circular structure
- Use Array<Array<Int>> or Vector for grid storage
- Matrix 1 verification is mandatory before considering implementation correct
- Haxe's type system is similar to TypeScript/Java with strong inference
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Haxe with class-based nodes</name>
  <files>Algorithms/DLX/Haxe/DLX.hx, Algorithms/DLX/Haxe/runMe.sh</files>
  <action>
Create Algorithms/DLX/Haxe/ directory structure. Port DLX from C to Haxe:

**DLX.hx structure**:
- Use `class DlxNode` with nullable references for circular doubly-linked structure
- Fields: `public var left:Null<DlxNode>`, `public var right:Null<DlxNode>`, `public var up:Null<DlxNode>`, `public var down:Null<DlxNode>`, `public var column:Null<DlxNode>`, `public var size:Int = 0`, `public var rowId:Int = -1`, `public var colId:Int = -1`
- Implement `coverColumn()` and `uncoverColumn()` methods for Algorithm X
- Implement `search()` method with recursion, use static `var iterations:Int = 0` counter
- Build exact cover matrix for Sudoku (324 columns: 81 cell, 81 row, 81 col, 81 box constraints)
- Parse .matrix file from Sys.args()[0]
- Iteration counter: increment at start of search method (before trying each row)
- Use Array of header nodes created during initialization
- Use `static function main()` as entry point

**Critical requirements**:
- Class for nodes (reference semantics needed for circular structure)
- Nullable types (Null<T>) for optional references
- Public var fields for mutable state
- Print output format: puzzle, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + (digit-1)
- **Avoid**: Don't use abstract types unnecessarily. Don't use Haxe macros (keep it straightforward).

**runMe.sh**:
```bash
#!/bin/bash
cd "$(dirname "$0")"
LANGUAGE="Haxe"
SOLVER_BINARY="./DLX"
METRICS_FILE="metrics.json"
TIMEOUT_SECONDS=300
source ../../common.sh

compile() {
    check_toolchain haxe
    haxe --main DLX --cpp out -D HXCPP_OPTIMIZATION_LEVEL=2
    cp out/DLX ./DLX
}

main "$@"
```
- Note: Compile to C++ for best performance
- Ensure runMe.sh is executable (chmod +x)
  </action>
  <verify>cd Algorithms/DLX/Haxe && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX Haxe implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Haxe with bitset-based constraint propagation</name>
  <files>Algorithms/CP/Haxe/CP.hx, Algorithms/CP/Haxe/runMe.sh</files>
  <action>
Create Algorithms/CP/Haxe/ directory structure. Port CP from C to Haxe:

**CP.hx structure**:
- Use `var grid:Array<Array<Int>>` initialized with nested arrays for puzzle
- Use `var candidates:Array<Array<Int>>` for bitsets (Int type, bits 1-9 represent digits)
- Implement `function propagate(row:Int, col:Int, digit:Int):Void` to eliminate candidates
- Implement `function solve():Bool` with backtracking recursion
- Use static `var iterations:Int = 0` counter, increment BEFORE validity check
- Parse .matrix file from Sys.args()[0]
- Initialize candidates: for empty cells, set to 0x3FE (bits 1-9), for filled cells set to 0
- Use `static function main()` as entry point

**Bitwise operations**:
- Check if digit available: `(candidates[row][col] & (1 << digit)) != 0`
- Remove candidate: `candidates[row][col] &= ~(1 << digit)`
- Add candidate back: `candidates[row][col] |= (1 << digit)`
- Count candidates: iterate bits 1-9 and check each with bitwise AND

**Critical requirements**:
- Haxe's bitwise operators: & (AND), | (OR), ~ (NOT), << (left shift)
- Must propagate constraints to row, column, and 3x3 box
- Backtracking must restore candidate sets correctly
- Print output format: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't use Map<Int,Bool> for candidates (bitset is faster and matches reference). Don't use Haxe-specific optimizations (keep it portable).

**runMe.sh**:
```bash
#!/bin/bash
cd "$(dirname "$0")"
LANGUAGE="Haxe"
SOLVER_BINARY="./CP"
METRICS_FILE="metrics.json"
TIMEOUT_SECONDS=300
source ../../common.sh

compile() {
    check_toolchain haxe
    haxe --main CP --cpp out -D HXCPP_OPTIMIZATION_LEVEL=2
    cp out/CP ./CP
}

main "$@"
```
- Note: Compile to C++ for best performance
- Ensure runMe.sh is executable (chmod +x)
  </action>
  <verify>cd Algorithms/CP/Haxe && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP Haxe implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `cd Algorithms/DLX/Haxe && ./runMe.sh ../../../Matrices/1.matrix` outputs exactly 43 iterations
- [ ] `cd Algorithms/CP/Haxe && ./runMe.sh ../../../Matrices/1.matrix` outputs exactly 67 iterations
- [ ] Both implementations compile without errors
- [ ] metrics.json files created in both directories
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- DLX implementation: 43 iterations for Matrix 1
- CP implementation: 67 iterations for Matrix 1
- Both runMe.sh scripts executable and working
- Phase 17 complete, ready for Phase 18
</success_criteria>

<output>
After completion, create `.planning/phases/17-specialized-languages-part-2/17-04-SUMMARY.md`:

# Phase 17 Plan 4: Haxe Algorithms (DLX + CP) Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `Algorithms/DLX/Haxe/DLX.hx` - DLX implementation with class-based circular nodes
- `Algorithms/DLX/Haxe/runMe.sh` - Build and benchmark script
- `Algorithms/CP/Haxe/CP.hx` - CP implementation with bitset candidates
- `Algorithms/CP/Haxe/runMe.sh` - Build and benchmark script

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 17 complete, ready for Phase 18 (Validation and Integration)
</output>
