---
phase: 14-compiled-languages
plan: 02
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Fortran/dlx.f90, Algorithms/DLX/Fortran/runMe.sh, Algorithms/DLX/Fortran/Makefile, Algorithms/CP/Fortran/cp.f90, Algorithms/CP/Fortran/runMe.sh, Algorithms/CP/Fortran/Makefile]
---

<objective>
Implement DLX and CP algorithms for Fortran, leveraging Fortran's array-based structures and derived types.

Purpose: Extend benchmark suite with Fortran implementations of advanced algorithms, demonstrating Fortran's computational capabilities.
Output: Working DLX and CP Fortran implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-systems-languages/13-02-SUMMARY.md
@Algorithms/BruteForce/Fortran/Sudoku.f90
@Algorithms/BruteForce/Fortran/Makefile
@Algorithms/DLX/C/dlx.c
@Algorithms/CP/C/cp.c

**Tech stack available:** gfortran compiler, derived types, allocatable arrays
**Established patterns:**
- DLX uses circular doubly-linked lists (represented via array indices in Fortran)
- CP uses integer arrays for candidate bitsets
- Pre-cover given clues in DLX before search
- Iteration counting: DLX at cover/uncover, CP at assign

**Constraining decisions:**
- All implementations must match C reference iteration counts exactly (DLX: 43, CP: 67)
- Follow existing Fortran BruteForce patterns for I/O
- Use Makefile for build (gfortran -O3)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Fortran</name>
  <files>Algorithms/DLX/Fortran/dlx.f90, Algorithms/DLX/Fortran/Makefile, Algorithms/DLX/Fortran/runMe.sh</files>
  <action>
Create DLX Algorithm X implementation using Fortran 90 derived types and array-based linked structures:
- Define DlxNode derived type with left, right, up, down, column indices (INTEGER)
- Use allocatable arrays for node storage (array-based linked lists, not pointers)
- Implement circular doubly-linked lists via integer indices
- Build exact cover matrix with 324 columns for Sudoku constraints
- Pre-cover given clues before Algorithm X search
- Count iterations at cover operations (increment BEFORE covering)
- Create Makefile with target: gfortran -O3 -o dlx_solver dlx.f90
- Create runMe.sh following Fortran BruteForce pattern
- Output format must match reference (includes "Solved in Iterations=N")
  </action>
  <verify>
cd Algorithms/DLX/Fortran && ./runMe.sh ../../../Matrices/1.matrix 2>&1 | grep "Iterations="
Should show exactly "Iterations=43"
  </verify>
  <done>
- dlx.f90 compiles without errors
- Produces exactly 43 iterations for Matrix 1
- Produces valid solved puzzle
- metrics.json created
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Fortran</name>
  <files>Algorithms/CP/Fortran/cp.f90, Algorithms/CP/Fortran/Makefile, Algorithms/CP/Fortran/runMe.sh</files>
  <action>
Create Constraint Propagation solver using Fortran derived types and integer arrays:
- Define CPGrid derived type with values(0:8, 0:8) :: INTEGER and candidates(0:8, 0:8) :: INTEGER(KIND=2) for 16-bit bitsets
- Initialize candidates to Z'03FE' (hex for bits 1-9 set)
- Implement propagation: assign() increments iterations, eliminate() for singleton and hidden singles
- MRV heuristic for cell selection
- Use assignment for deep copy (Fortran copies derived types by value)
- Count iterations in assign() before propagation
- Create Makefile: gfortran -O3 -o cp_solver cp.f90
- Create runMe.sh following Fortran patterns
- Output format must match reference
  </action>
  <verify>
cd Algorithms/CP/Fortran && ./runMe.sh ../../../Matrices/1.matrix 2>&1 | grep "Iterations="
Should show exactly "Iterations=67"
  </verify>
  <done>
- cp.f90 compiles without errors
- Produces exactly 67 iterations for Matrix 1
- Produces valid solved puzzle
- metrics.json created
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both DLX and CP Fortran implementations compile without errors
- [ ] DLX produces exactly 43 iterations on Matrix 1
- [ ] CP produces exactly 67 iterations on Matrix 1
- [ ] Both metrics.json files created successfully
- [ ] Both implementations produce valid solved puzzles
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match reference implementations exactly
- No compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-compiled-languages/14-02-SUMMARY.md` following the summary template.
</output>
