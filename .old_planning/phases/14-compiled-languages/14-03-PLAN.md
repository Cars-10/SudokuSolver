---
phase: 14-compiled-languages
plan: 03
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Ada/dlx.adb, Algorithms/DLX/Ada/runMe.sh, Algorithms/CP/Ada/cp.adb, Algorithms/CP/Ada/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Ada, leveraging Ada's strong typing and access types for linked structures.

Purpose: Extend benchmark suite with Ada implementations of advanced algorithms, demonstrating Ada's type-safe programming model.
Output: Working DLX and CP Ada implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-systems-languages/13-03-SUMMARY.md
@Algorithms/BruteForce/Ada/Sudoku.adb
@Algorithms/DLX/C/dlx.c
@Algorithms/CP/C/cp.c

**Tech stack available:** GNAT Ada compiler (gnatmake), access types, record types
**Established patterns:**
- DLX uses circular doubly-linked lists with access types (pointers)
- CP uses modular types for candidate bitsets
- Pre-cover given clues in DLX before search
- Iteration counting: DLX at cover/uncover, CP at assign

**Constraining decisions:**
- All implementations must match C reference iteration counts exactly (DLX: 43, CP: 67)
- Use existing Ada BruteForce implementation patterns for I/O
- Compile with gnatmake -O3
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Ada</name>
  <files>Algorithms/DLX/Ada/dlx.adb, Algorithms/DLX/Ada/runMe.sh</files>
  <action>
Create DLX Algorithm X implementation using Ada access types and record structures:
- Define DlxNode record type with Left, Right, Up, Down, Column access types (pointers)
- Define DlxColumn record type for constraint columns
- Use "type DlxNode_Access is access DlxNode;" for pointer types
- Implement circular doubly-linked lists (Cover, Uncover procedures)
- Build exact cover matrix with 324 columns for Sudoku constraints
- Pre-cover given clues before Algorithm X search
- Count iterations at Cover operations (increment BEFORE covering)
- Use "new DlxNode'(...)" for allocation
- Create runMe.sh following Ada BruteForce pattern
- Compile with: gnatmake -O3 dlx.adb
- Output format must match reference (includes "Solved in Iterations=N")
  </action>
  <verify>
cd Algorithms/DLX/Ada && ./runMe.sh ../../../Matrices/1.matrix 2>&1 | grep "Iterations="
Should show exactly "Iterations=43"
  </verify>
  <done>
- dlx.adb compiles without errors
- Produces exactly 43 iterations for Matrix 1
- Produces valid solved puzzle
- metrics.json created
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Ada</name>
  <files>Algorithms/CP/Ada/cp.adb, Algorithms/CP/Ada/runMe.sh</files>
  <action>
Create Constraint Propagation solver using Ada record types and modular types for bitsets:
- Define CPGrid record with Values: array(0..8, 0..8) of Integer and Candidates: array(0..8, 0..8) of Interfaces.Unsigned_16
- Use modular type for bitsets (bits 1-9 for digits), initialize to 16#03FE#
- Implement propagation: Assign procedure increments iterations, Eliminate for singleton/hidden singles
- MRV heuristic for cell selection
- Use assignment for deep copy (Ada records copy by value)
- Count iterations in Assign procedure before propagation
- Create runMe.sh following Ada patterns
- Compile with: gnatmake -O3 cp.adb
- Output format must match reference
  </action>
  <verify>
cd Algorithms/CP/Ada && ./runMe.sh ../../../Matrices/1.matrix 2>&1 | grep "Iterations="
Should show exactly "Iterations=67"
  </verify>
  <done>
- cp.adb compiles without errors
- Produces exactly 67 iterations for Matrix 1
- Produces valid solved puzzle
- metrics.json created
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both DLX and CP Ada implementations compile without errors
- [ ] DLX produces exactly 43 iterations on Matrix 1
- [ ] CP produces exactly 67 iterations on Matrix 1
- [ ] Both metrics.json files created successfully
- [ ] Both implementations produce valid solved puzzles
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match reference implementations exactly
- No compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-compiled-languages/14-03-SUMMARY.md` following the summary template.
</output>
