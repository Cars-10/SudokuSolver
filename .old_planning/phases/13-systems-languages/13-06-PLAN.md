---
phase: 13-systems-languages
plan: 06
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Crystal/dlx.cr, Algorithms/DLX/Crystal/runMe.sh, Algorithms/CP/Crystal/cp.cr, Algorithms/CP/Crystal/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Crystal, leveraging Crystal's Ruby-like syntax with static typing and C-level performance.

Purpose: Extend the benchmark suite with Crystal implementations of advanced algorithms, demonstrating Crystal's combination of expressive syntax and compiled efficiency.
Output: Working DLX and CP Crystal implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STRUCTURE.md

# Reference implementations
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Crystal/Sudoku.cr

**Tech stack available**: Crystal compiler (crystal build) with class-based objects and static typing
**Established patterns**:
- DLX uses class-based nodes with instance variables for circular lists
- CP uses Array(Array(Int32)) with UInt16 bitsets for candidates
- Target iteration counts: DLX=43, CP=67
- Crystal's syntax is similar to Ruby but with compile-time type checking

**Key decisions from previous phases**:
- Use class DlxNode with nullable references (@left : DlxNode?)
- Use Array(Array(Int32)) for grid storage
- Matrix 1 verification is mandatory
- Crystal compiles to native code via LLVM
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Crystal with class-based nodes</name>
  <files>Algorithms/DLX/Crystal/dlx.cr, Algorithms/DLX/Crystal/runMe.sh</files>
  <action>
Create Algorithms/DLX/Crystal/ directory. Port DLX from C to Crystal:

**dlx.cr structure**:
- Class DlxNode: property left, right, up, down, column : DlxNode?; property size, row_id, col_id : Int32
- Global @@dlx_iterations = 0
- Methods:
  - def cover_column(c : DlxNode): remove column and rows from matrix
  - def uncover_column(c : DlxNode): restore column and rows
  - def choose_column(root : DlxNode) : DlxNode?: find column with min size
  - def dlx_search(root : DlxNode, k : Int32, solution : Array(Int32)) : Bool: Algorithm X
  - def build_sudoku_matrix : DlxNode: create 324 columns + constraint rows
  - def parse_matrix_file(filename : String) : Array(Array(Int32)): read puzzle
- Main block at end: ARGV.each { |file| solve and print }
- Increment @@dlx_iterations at start of dlx_search

**Critical requirements**:
- Use property for readable/writable instance variables
- Use DlxNode? for nullable references
- Use .not_nil! to assert non-null when needed (or if checks)
- Initialize circular lists: root.left = root; root.right = root
- Print output: puzzle, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + (digit-1)
- **Avoid**: Don't use untyped variables. Crystal requires explicit types for class properties.

**runMe.sh**:
- Set LANGUAGE="Crystal", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain crystal; crystal build --release -o dlx_solver dlx.cr`
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/Crystal && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX Crystal implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Crystal with Array-based grid</name>
  <files>Algorithms/CP/Crystal/cp.cr, Algorithms/CP/Crystal/runMe.sh</files>
  <action>
Create Algorithms/CP/Crystal/ directory. Port CP from C to Crystal:

**cp.cr structure**:
- Type alias: alias CandidateSet = UInt16
- Class CPGrid: property values : Array(Array(Int32)); property candidates : Array(Array(CandidateSet))
- Global @@cp_iterations : Int64 = 0
- Helper methods:
  - def has_cand(cs : CandidateSet, digit : Int32) : Bool: (cs & (1_u16 << digit)) != 0
  - def count_cand(cs : CandidateSet) : Int32: cs.popcount
  - def get_peers(row : Int32, col : Int32) : Array(Tuple(Int32, Int32)): return 20 peer coordinates
- Main methods:
  - def init_grid(puzzle : Array(Array(Int32))) : CPGrid: allocate and set candidates to 0x3FE_u16 for empty
  - def propagate(grid : CPGrid, row : Int32, col : Int32, digit : Int32) : Bool: eliminate from peers
  - def assign(grid : CPGrid, row : Int32, col : Int32, digit : Int32) : Bool: place and propagate, increment @@cp_iterations
  - def search(grid : CPGrid) : Bool: find MRV cell, try digits 1-9, backtrack
  - def parse_matrix_file(filename : String) : Array(Array(Int32)): read puzzle
- Main block: ARGV.each { |file| solve and print }

**Critical requirements**:
- Use Array(Array(Int32)) for values, Array(Array(UInt16)) for candidates
- Initialize with Array(Array(Int32)).new(9) { Array(Int32).new(9, 0) }
- CandidateSet as UInt16 with bits 1-9 (bit 0 unused)
- Use _u16 suffix for UInt16 literals (0x3FE_u16)
- Iteration counting in assign() before propagation
- Deep copy grid for backtracking: use .dup for shallow copy or map { |row| row.dup } for deep
- Print output: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't shallow copy arrays. Use proper deep copy for backtracking.

**runMe.sh**:
- Set LANGUAGE="Crystal", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain crystal; crystal build --release -o cp_solver cp.cr`
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/Crystal && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP Crystal implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both DLX and CP Crystal implementations compile without errors
- [ ] DLX produces exactly 43 iterations on Matrix 1
- [ ] CP produces exactly 67 iterations on Matrix 1
- [ ] Both metrics.json files created successfully
- [ ] Both implementations produce valid solved puzzles
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No compilation errors
- Iteration counts match reference implementations exactly
- Both algorithms fully functional
- Phase 13 complete (all 6 systems languages implemented)
</success_criteria>

<output>
After completion, create `.planning/phases/13-systems-languages/13-06-SUMMARY.md`:

# Phase 13 Plan 6: Crystal Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.cr` - Description
- `path/to/another.cr` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 13 complete. Ready for Phase 14 (Compiled Languages) per roadmap.
</output>
