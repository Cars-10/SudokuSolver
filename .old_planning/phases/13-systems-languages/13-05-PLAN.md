---
phase: 13-systems-languages
plan: 05
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Nim/dlx.nim, Algorithms/DLX/Nim/runMe.sh, Algorithms/CP/Nim/cp.nim, Algorithms/CP/Nim/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Nim, leveraging Nim's Python-like syntax with C-level performance and ref types for mutable data structures.

Purpose: Extend the benchmark suite with Nim implementations of advanced algorithms, demonstrating Nim's unique position as a statically-typed, compiled language with expressive syntax.
Output: Working DLX and CP Nim implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STRUCTURE.md

# Reference implementations
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Nim/Sudoku.nim

**Tech stack available**: Nim compiler (nim c) with ref object types and sequences
**Established patterns**:
- DLX uses ref object types for circular doubly-linked lists
- CP uses seq[seq[int]] with uint16 bitsets for candidates
- Target iteration counts: DLX=43, CP=67
- Nim's ref types provide GC-managed mutable references similar to classes

**Key decisions from previous phases**:
- Use ref object for DlxNode with mutable fields
- Use seq[seq[int]] for dynamic grid storage
- Matrix 1 verification is mandatory
- Nim compiles to C and achieves C-like performance
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Nim with ref object nodes</name>
  <files>Algorithms/DLX/Nim/dlx.nim, Algorithms/DLX/Nim/runMe.sh</files>
  <action>
Create Algorithms/DLX/Nim/ directory. Port DLX from C to Nim:

**dlx.nim structure**:
- Import: import os, strutils, sequtils
- Type DlxNode = ref object: left, right, up, down, column: DlxNode; size, rowId, colId: int
- Global var dlxIterations = 0
- Procedures:
  - proc coverColumn(c: DlxNode): remove column and rows from matrix
  - proc uncoverColumn(c: DlxNode): restore column and rows
  - proc chooseColumn(root: DlxNode): DlxNode: find column with min size
  - proc dlxSearch(root: DlxNode, k: int, solution: var seq[int]): bool: Algorithm X
  - proc buildSudokuMatrix(): DlxNode: create 324 columns + constraint rows
  - proc parseMatrixFile(filename: string): seq[seq[int]]: read puzzle
- when isMainModule: parse args, solve puzzle, print result with iteration count
- Increment dlxIterations at start of dlxSearch

**Critical requirements**:
- Use ref object for automatic GC management
- Initialize circular lists: root.left = root; root.right = root
- Use new(DlxNode) or DlxNode(...) constructor
- Print output: puzzle, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + (digit-1)
- **Avoid**: Don't use ptr (unmanaged pointers). Use ref object for safety.

**runMe.sh**:
- Set LANGUAGE="Nim", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain nim; nim c -d:release -o:dlx_solver dlx.nim`
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/Nim && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX Nim implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Nim with sequence-based grid</name>
  <files>Algorithms/CP/Nim/cp.nim, Algorithms/CP/Nim/runMe.sh</files>
  <action>
Create Algorithms/CP/Nim/ directory. Port CP from C to Nim:

**cp.nim structure**:
- Import: import os, strutils, sequtils, bitops
- Type CandidateSet = uint16
- Type CPGrid = object: values, candidates: seq[seq[int or uint16]]
- Global var cpIterations: int64 = 0
- Helper procedures:
  - proc hasCand(cs: CandidateSet, digit: int): bool: (cs and (1'u16 shl digit)) != 0
  - proc countCand(cs: CandidateSet): int: countSetBits(cs) or manual loop
  - proc getPeers(row, col: int): seq[(int, int)]: return 20 peer coordinates
- Main procedures:
  - proc initGrid(puzzle: seq[seq[int]]): CPGrid: allocate and set candidates to 0x3FE for empty
  - proc propagate(grid: var CPGrid, row, col, digit: int): bool: eliminate from peers
  - proc assign(grid: var CPGrid, row, col, digit: int): bool: place and propagate, increment cpIterations
  - proc search(grid: var CPGrid): bool: find MRV cell, try digits 1-9, backtrack
  - proc parseMatrixFile(filename: string): seq[seq[int]]: read puzzle
- when isMainModule: solve puzzle, print result

**Critical requirements**:
- Use seq[seq[int]] for values, seq[seq[uint16]] for candidates
- Initialize with newSeqWith(9, newSeq[int](9)) or similar
- CandidateSet as uint16 with bits 1-9 (bit 0 unused)
- Use var for mutable parameters
- Iteration counting in assign() before propagation
- Deep copy grid for backtracking: use assignment (Nim copies by default for value types)
- Print output: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't forget 'u16 suffix for uint16 literals. Nim is type-strict.

**runMe.sh**:
- Set LANGUAGE="Nim", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain nim; nim c -d:release -o:cp_solver cp.nim`
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/Nim && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP Nim implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both DLX and CP Nim implementations compile without errors
- [ ] DLX produces exactly 43 iterations on Matrix 1
- [ ] CP produces exactly 67 iterations on Matrix 1
- [ ] Both metrics.json files created successfully
- [ ] Both implementations produce valid solved puzzles
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No compilation errors
- Iteration counts match reference implementations exactly
- Both algorithms fully functional
</success_criteria>

<output>
After completion, create `.planning/phases/13-systems-languages/13-05-SUMMARY.md`:

# Phase 13 Plan 5: Nim Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.nim` - Description
- `path/to/another.nim` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for next plan in Phase 13 (13-06: Crystal Algorithms)
</output>
