---
phase: 13-systems-languages
plan: 01
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Rust/dlx.rs, Algorithms/DLX/Rust/runMe.sh, Algorithms/DLX/Rust/Cargo.toml, Algorithms/CP/Rust/cp.rs, Algorithms/CP/Rust/runMe.sh, Algorithms/CP/Rust/Cargo.toml]
---

<objective>
Implement DLX and CP algorithms for Rust, leveraging Rust's ownership system and safe mutation patterns for efficient algorithm implementation.

Purpose: Extend the benchmark suite with Rust implementations of advanced algorithms, demonstrating Rust's zero-cost abstractions and memory safety guarantees while maintaining algorithm performance.
Output: Working DLX and CP Rust implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STRUCTURE.md

# Reference implementations
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Rust/Sudoku/src/main.rs

**Tech stack available**: Rust compiler (rustc/cargo) with Vec, Box, RefCell for mutable structures
**Established patterns**:
- DLX uses circular doubly-linked lists with mutable references
- CP uses mutable arrays with bitsets for candidates (u16 for bits 1-9)
- Target iteration counts: DLX=43, CP=67
- Both algorithms require careful mutation patterns in Rust's ownership system

**Key decisions from previous phases**:
- Use RefCell<> or raw pointers for circular DLX node structures
- Use Vec<Vec<>> or flat Vec with indexing for grid storage
- Matrix 1 verification is mandatory before considering implementation correct
- Rust's borrow checker requires special patterns for self-referential structures
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Rust with RefCell-based nodes</name>
  <files>Algorithms/DLX/Rust/dlx.rs, Algorithms/DLX/Rust/runMe.sh, Algorithms/DLX/Rust/Cargo.toml</files>
  <action>
Create Algorithms/DLX/Rust/ directory structure. Port DLX from C to Rust:

**Project structure**:
- Create Cargo.toml with name="dlx_solver", edition="2021"
- Create src/main.rs as dlx.rs

**dlx.rs structure**:
- Use Rc<RefCell<Node>> for mutable shared ownership of DLX nodes
- Struct DlxNode: { left, right, up, down, column: Option<Rc<RefCell<DlxNode>>>, size: usize, row_id: i32, col_id: i32 }
- Implement cover_column and uncover_column using borrow_mut() for mutations
- Implement search with Algorithm X recursion, use global mutable static or pass counter by reference
- Build exact cover matrix for Sudoku (324 columns: 81 cell, 81 row, 81 col, 81 box constraints)
- Parse .matrix file from command line args
- Global iteration counter: use static AtomicI32 or Cell<i32>, incremented at start of search
- Use arena allocation pattern with Vec<Rc<RefCell<Node>>> to avoid lifetime issues

**Critical requirements**:
- Use std::rc::Rc and std::cell::RefCell for circular structure
- Clone Rc pointers when creating links (Rc::clone(&node))
- Use .borrow() for reads, .borrow_mut() for writes
- Print output: puzzle, then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + (digit-1)
- **Avoid**: Don't use raw pointers unless RefCell approach fails. Don't fight the borrow checker with unsafe unless absolutely necessary.

**Cargo.toml**:
```toml
[package]
name = "dlx_solver"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "dlx_solver"
path = "src/main.rs"

[profile.release]
opt-level = 3
```

**runMe.sh**:
- Set LANGUAGE="Rust", SOLVER_BINARY="./target/release/dlx_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain cargo; cargo build --release --quiet`
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/Rust && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX Rust implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Rust with Vec-based grid</name>
  <files>Algorithms/CP/Rust/cp.rs, Algorithms/CP/Rust/runMe.sh, Algorithms/CP/Rust/Cargo.toml</files>
  <action>
Create Algorithms/CP/Rust/ directory structure. Port CP from C to Rust:

**Project structure**:
- Create Cargo.toml with name="cp_solver", edition="2021"
- Create src/main.rs as cp.rs

**cp.rs structure**:
- Data structures using standard Rust types:
  - Grid values: Vec<Vec<i32>> for 9x9 cells (or [[i32; 9]; 9])
  - Candidates: Vec<Vec<u16>> for bitsets (bit 1-9 for digits)
- Type alias: type CandidateSet = u16;
- Macros for bitset ops: `macro_rules! has_candidate { ($cs:expr, $d:expr) => { ($cs & (1 << $d)) != 0 } }`
- Functions:
  - init_grid: initialize candidates to 0x3FE for empty cells
  - propagate_constraints: eliminate candidates from peers
  - assign: place digit, propagate, recurse (increment iteration counter here)
  - search: find cell with MRV, try candidates 1-9
  - get_peers: return Vec of (row,col) tuples for 20 peers
- Global iteration counter: static AtomicI64 or pass &mut counter
- Parse .matrix file from args, print solution and iteration count

**Critical requirements**:
- Use bitwise ops for candidate manipulation: & (and), | (or), ^ (xor), << (shift)
- CandidateSet as u16 with bits 1-9 (bit 0 unused)
- Iteration counting in assign() function before propagation
- Deep copy grid state before backtracking (clone())
- Print output: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't over-engineer with traits/generics. Keep it simple and mechanical port from C.

**Cargo.toml**:
```toml
[package]
name = "cp_solver"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "cp_solver"
path = "src/main.rs"

[profile.release]
opt-level = 3
```

**runMe.sh**:
- Set LANGUAGE="Rust", SOLVER_BINARY="./target/release/cp_solver", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain cargo; cargo build --release --quiet`
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/Rust && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP Rust implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both DLX and CP Rust implementations compile without warnings
- [ ] DLX produces exactly 43 iterations on Matrix 1
- [ ] CP produces exactly 67 iterations on Matrix 1
- [ ] Both metrics.json files created successfully
- [ ] Both implementations produce valid solved puzzles
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No compilation errors or warnings
- Iteration counts match reference implementations exactly
- Both algorithms fully functional
</success_criteria>

<output>
After completion, create `.planning/phases/13-systems-languages/13-01-SUMMARY.md`:

# Phase 13 Plan 1: Rust Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.rs` - Description
- `path/to/another.rs` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for next plan in Phase 13 (13-02: Go Algorithms)
</output>
