---
phase: 11-functional-languages-part-1
plan: 05
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Scheme/dlx.scm, Algorithms/DLX/Scheme/runMe.sh, Algorithms/CP/Scheme/cp.scm, Algorithms/CP/Scheme/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Scheme using vectors for mutable indexed containers.

Purpose: Port Dancing Links and Constraint Propagation from C to Scheme, using vectors to avoid deprecated set-car!/set-cdr! operations.
Output: Working DLX and CP implementations with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-functional-languages-part-1/11-RESEARCH.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Scheme/Sudoku.scm

**Tech stack available:** Scheme interpreter (check existing BruteForce for dialect - likely Guile or Chicken)
**Established patterns:** Mechanical C translation, iteration count verification
**Research findings:** Modern Scheme uses vectors, avoid deprecated set-car!/set-cdr!, use vector-set! for mutation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX algorithm in Scheme using vectors</name>
  <files>Algorithms/DLX/Scheme/dlx.scm, Algorithms/DLX/Scheme/runMe.sh</files>
  <action>
Create Algorithms/DLX/Scheme/ directory. Port DLX from C to Scheme:

**dlx.scm structure**:
- Node representation: vectors with indices
  - `(define (make-dlx-node left right up down column size row col) (vector left right up down column size row col))`
  - Accessors: `(define (node-left n) (vector-ref n 0))` and mutators: `(define (set-node-left! n v) (vector-set! n 0 v))`
- Implement `cover-column` and `uncover-column` with vector-set! operations
- Implement `search` with Algorithm X recursion
- Build exact cover matrix (324 columns) - store nodes in a vector or list
- Parse .matrix file
- Global iteration counter: `(define dlx-iterations 0)` then `(set! dlx-iterations (+ dlx-iterations 1))` at start of search
- Main: `(define (main args) ...)` with command-line args processing
- Shebang: `#!/usr/bin/env scheme` or match existing BruteForce

**Critical requirements**:
- Check existing Scheme BruteForce to determine dialect (Guile, Chicken, Racket, etc.)
- Use vectors, NOT cons cells with set-car!/set-cdr! (deprecated in modern Scheme)
- Print output: puzzle, then "Solved in Iterations=43"
- Same exact cover mapping: row*81 + col*9 + digit
- **Avoid**: Don't use set-car!/set-cdr! (removed in Racket, discouraged elsewhere). Use vectors with vector-set!

**runMe.sh**:
- Set LANGUAGE="Scheme", SOLVER_BINARY determined by checking BruteForce (likely "guile dlx.scm" or "csi -s dlx.scm"), METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: Check dialect from BruteForce, set appropriate interpreter command
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/Scheme && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX Scheme implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP algorithm in Scheme with vectors for grid</name>
  <files>Algorithms/CP/Scheme/cp.scm, Algorithms/CP/Scheme/runMe.sh</files>
  <action>
Create Algorithms/CP/Scheme/ directory. Port CP from C to Scheme:

**cp.scm structure**:
- Grid representation: vector of vectors (9x9)
  - `(define grid (make-vector 9))` then fill with `(vector-set! grid i (make-vector 9 0))`
  - Access: `(vector-ref (vector-ref grid r) c)`
  - Set: `(vector-set! (vector-ref grid r) c value)`
- Candidates: similar vector-of-vectors structure (bitsets as integers)
- Bitset helpers:
  - `(define (has-candidate set digit) (not (= (bitwise-and set (arithmetic-shift 1 digit)) 0)))`
  - Use `bitwise-and`, `bitwise-ior`, `bitwise-not`, `arithmetic-shift` for bit operations
  - Implement popcount with recursive bit counting
- Implement `init-grid`, `assign`, `eliminate`, `propagate`
- Implement `find-mrv-cell` returning #f or (row . col) pair
- Implement `cp-search` with recursive backtracking (copy grid for backtracking using vector-copy or manual copy)
- Global iteration counter: `(define cp-iterations 0)` then `(set! cp-iterations (+ cp-iterations 1))` at start of cp-search
- Main: process command-line args

**Critical requirements**:
- Bitset initial: #x1FF (511) in hex notation
- Propagate: singleton elimination, hidden singles, MRV
- Output: puzzle, then "Solved in Iterations=67"
- Match dialect from existing Scheme BruteForce
- **Avoid**: Don't use lists for grid (inefficient for random access). Use vectors.

**runMe.sh**:
- Set LANGUAGE="Scheme", SOLVER_BINARY determined by checking BruteForce, METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: Set appropriate interpreter command based on dialect
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/Scheme && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP Scheme implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] DLX Scheme shows exactly 43 iterations for Matrix 1
- [ ] CP Scheme shows exactly 67 iterations for Matrix 1
- [ ] Both run without errors
- [ ] Both produce correctly solved puzzles
- [ ] metrics.json files exist for both
- [ ] Scheme dialect matches existing BruteForce
- [ ] Modern vector-based approach used (no deprecated set-car!/set-cdr!)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match C reference exactly
- Both implementations integrated into benchmark system
- Plan 11-05 complete
- Phase 11 complete (all 5 languages implemented)
</success_criteria>

<output>
After completion, create `.planning/phases/11-functional-languages-part-1/11-05-SUMMARY.md`:

# Phase 11 Plan 5: Scheme Algorithms Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [DLX implementation details]
- [CP implementation details]

## Files Created/Modified

- `Algorithms/DLX/Scheme/dlx.scm` - Description
- `Algorithms/DLX/Scheme/runMe.sh` - Description
- `Algorithms/CP/Scheme/cp.scm` - Description
- `Algorithms/CP/Scheme/runMe.sh` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 11 complete. All 5 functional languages (Haskell, OCaml, F#, SML, Scheme) now have DLX and CP implementations. Ready for Phase 12: Functional Languages - Part 2.
</output>
