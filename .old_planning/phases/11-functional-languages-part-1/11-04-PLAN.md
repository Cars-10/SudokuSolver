---
phase: 11-functional-languages-part-1
plan: 04
type: execute
depends_on: []
files_modified: [Algorithms/BruteForce/SML/Sudoku.sml, Algorithms/BruteForce/SML/runMe.sh, Algorithms/DLX/SML/dlx.sml, Algorithms/DLX/SML/runMe.sh, Algorithms/CP/SML/cp.sml, Algorithms/CP/SML/runMe.sh]
---

<objective>
Implement BruteForce, DLX, and CP algorithms for Standard ML (SML) using refs and arrays.

Purpose: Port all three algorithms from C to SML. SML is missing BruteForce baseline, so implement it first, then DLX and CP.
Output: Working BruteForce (656 iterations), DLX (43 iterations), and CP (67 iterations) implementations.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-functional-languages-part-1/11-RESEARCH.md
@Algorithms/BruteForce/C/Sudoku.c
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c

**Tech stack available:** SML compiler (mlton or smlnj), refs, Array.array, Array2.array
**Established patterns:** Mechanical C translation, iteration count verification
**Research findings:** SML similar to OCaml - use refs and datatypes with ref fields
**Note:** SML BruteForce missing - implement first to establish baseline
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BruteForce algorithm in SML to establish baseline</name>
  <files>Algorithms/BruteForce/SML/Sudoku.sml, Algorithms/BruteForce/SML/runMe.sh</files>
  <action>
Create Algorithms/BruteForce/SML/ directory. Port BruteForce from C to SML:

**Sudoku.sml structure**:
- Type: `type board = int Array2.array` (9x9 array)
- Implement `isValid` checking row, column, box constraints
- Implement `solve` with backtracking recursion
  - Search row-major order (row 0-8, col 0-8)
  - Try digits 1-9 in ascending order
  - Increment counter BEFORE validity check
- Global iteration counter: `val iterations = ref 0` incremented before each placement attempt
- Parse .matrix file
- Main: process command-line args

**Critical requirements**:
- Array2 operations: `Array2.sub(board, r, c)` for access, `Array2.update(board, r, c, value)` for assignment
- Use `!` for ref dereference, `:=` for ref assignment
- Print output: puzzle, then "Solved in Iterations=656" for Matrix 1
- **Avoid**: Don't use 0-based to 1-based conversion (SML arrays are 0-based like C).

**runMe.sh**:
- Set LANGUAGE="SML", SOLVER_BINARY="./Sudoku", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../../common.sh
- compile() function: `check_toolchain mlton || check_toolchain smlnj; if command -v mlton; then mlton -output Sudoku Sudoku.sml; else smlnj < build.sml; fi`
- Call main "$@"
  </action>
  <verify>cd Algorithms/BruteForce/SML && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=656"</verify>
  <done>BruteForce SML implementation runs cleanly, produces exactly 656 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement DLX algorithm in SML with refs and datatype</name>
  <files>Algorithms/DLX/SML/dlx.sml, Algorithms/DLX/SML/runMe.sh</files>
  <action>
Create Algorithms/DLX/SML/ directory. Port DLX from C to SML:

**dlx.sml structure**:
- Type definitions:
  - `datatype dlx_node = DNode of { left: dlx_node ref, right: dlx_node ref, up: dlx_node ref, down: dlx_node ref, column: dlx_node ref, size: int ref, row_id: int, col_id: int }`
- Implement `cover_column` and `uncover_column` with ref operations
- Implement `search` with Algorithm X recursion
- Build exact cover matrix (324 columns)
- Parse .matrix file
- Global iteration counter: `val dlx_iterations = ref 0` incremented at start of search
- Main: process args

**Critical requirements**:
- Ref operations: `!ref` for dereference, `ref := value` for assignment
- Pattern matching: `case node of DNode {left, right, ...} => ...`
- Print output: puzzle, then "Solved in Iterations=43"
- Same exact cover mapping: row*81 + col*9 + digit
- **Avoid**: Don't forget to dereference refs before pattern matching on node structure.

**runMe.sh**:
- Set LANGUAGE="SML", SOLVER_BINARY="./dlx", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain mlton || check_toolchain smlnj; if command -v mlton; then mlton -output dlx dlx.sml; else smlnj < build_dlx.sml; fi`
- Call main "$@"
  </action>
  <verify>cd Algorithms/DLX/SML && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX SML implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 3: Implement CP algorithm in SML with Array2 and refs</name>
  <files>Algorithms/CP/SML/cp.sml, Algorithms/CP/SML/runMe.sh</files>
  <action>
Create Algorithms/CP/SML/ directory. Port CP from C to SML:

**cp.sml structure**:
- Type definitions:
  - Grid: `val grid = Array2.array(9, 9, 0)` (mutable 2D array)
  - Candidates: `val candidates = Array2.array(9, 9, 0)` (bitsets as ints)
- Bitset helpers using `Word` module:
  - `fun has_candidate set digit = Word.andb(set, Word.<<(0w1, Word.fromInt digit)) <> 0w0`
  - Implement remove, count operations
- Implement `init_grid`, `assign`, `eliminate`, `propagate`
- Implement `find_mrv_cell` returning option type
- Implement `cp_search` with recursive backtracking (copy array for backtracking)
- Global iteration counter: `val cp_iterations = ref 0` incremented at start of cp_search
- Main: process args

**Critical requirements**:
- Array2 operations: `Array2.sub`, `Array2.update`
- Bitwise operations via Word module
- Bitset initial: 0x1FF (511)
- Propagate: singleton elimination, hidden singles, MRV
- Output: puzzle, then "Solved in Iterations=67"
- **Avoid**: Don't use integer bitwise operators directly (SML requires Word module for bit operations).

**runMe.sh**:
- Set LANGUAGE="SML", SOLVER_BINARY="./cp", METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- compile() function: `check_toolchain mlton || check_toolchain smlnj; if command -v mlton; then mlton -output cp cp.sml; else smlnj < build_cp.sml; fi`
- Call main "$@"
  </action>
  <verify>cd Algorithms/CP/SML && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP SML implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] BruteForce SML shows exactly 656 iterations for Matrix 1
- [ ] DLX SML shows exactly 43 iterations for Matrix 1
- [ ] CP SML shows exactly 67 iterations for Matrix 1
- [ ] All three compile without errors or warnings
- [ ] All produce correctly solved puzzles
- [ ] metrics.json files exist for all three
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match C reference exactly
- All three implementations integrated into benchmark system
- Plan 11-04 complete
</success_criteria>

<output>
After completion, create `.planning/phases/11-functional-languages-part-1/11-04-SUMMARY.md`:

# Phase 11 Plan 4: SML Algorithms Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [BruteForce implementation details]
- [DLX implementation details]
- [CP implementation details]

## Files Created/Modified

- `Algorithms/BruteForce/SML/Sudoku.sml` - Description
- `Algorithms/BruteForce/SML/runMe.sh` - Description
- `Algorithms/DLX/SML/dlx.sml` - Description
- `Algorithms/DLX/SML/runMe.sh` - Description
- `Algorithms/CP/SML/cp.sml` - Description
- `Algorithms/CP/SML/runMe.sh` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for parallel execution with other Phase 11 plans
</output>
