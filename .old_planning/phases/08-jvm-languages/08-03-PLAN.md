---
phase: 08-jvm-languages
plan: 03
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Scala/DLX.scala, Algorithms/DLX/Scala/runMe.sh, Algorithms/CP/Scala/CP.scala, Algorithms/CP/Scala/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Scala, balancing functional programming features with imperative algorithm requirements.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms to Scala, using Scala's hybrid object-oriented/functional paradigm while maintaining exact algorithmic behavior from C reference.
Output: Working DLX and CP implementations for Scala with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-c-family-languages/07-01-SUMMARY.md
@.planning/phases/07-c-family-languages/07-02-SUMMARY.md
@Algorithms/DLX/C/dlx.h
@Algorithms/DLX/C/dlx_core.c
@Algorithms/DLX/C/dlx_sudoku.c
@Algorithms/CP/C/cp.h
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp_sudoku.c
@Algorithms/BruteForce/Scala/Sudoku.scala

**Tech stack available**: Scala compiler (scalac), Scala standard library, JVM runtime
**Established patterns**: Mechanical translation from C, use mutable structures where needed for algorithm correctness, verify iteration counts
**Constraining decisions**:
- Phase 7: Algorithm correctness trumps language idioms when they conflict
- Phase 8-01 (Java): DLX needs manual pointer manipulation, CP uses 16-bit bitsets
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in Scala</name>
  <files>Algorithms/DLX/Scala/DLX.scala, Algorithms/DLX/Scala/runMe.sh</files>
  <action>
Create Algorithms/DLX/Scala/ directory structure. Port the DLX algorithm to Scala:

**DLX.scala structure**:
- Use Scala classes with mutable var fields (NOT immutable val):
  ```scala
  class DlxNode(var left: DlxNode, var right: DlxNode, var up: DlxNode, var down: DlxNode, var column: DlxColumn, var row: Int)
  class DlxColumn(val name: String, var size: Int) extends DlxNode(...)
  ```
- Implement `def coverColumn(c: DlxColumn): Unit` - exact same logic as C
- Implement `def uncoverColumn(c: DlxColumn): Unit` - exact reversal
- Implement `def search(k: Int): Boolean` - recursive backtracking
- Implement `def buildExactCoverMatrix(): Unit` - 324 columns
- Implement `def parseMatrix(filename: String): Unit` - read .matrix file
- Object with main method: `object DLX { var iterations = 0; def main(args: Array[String]): Unit = ... }`

**Scala-specific considerations**:
- Use `var` (mutable) for node pointers, NOT `val` - the algorithm requires mutation
- Use `scala.io.Source.fromFile(filename).getLines()` for file I/O
- Use Option[DlxNode] for nullable references if beneficial, but verify it doesn't break pointer manipulation
- Use `s"Solved in Iterations=$iterations"` for string interpolation
- Keep imperative style for cover/uncover operations (don't try to make them functional)

**Critical requirements**:
- Maintain circular doubly-linked list structure (mutable pointer manipulation)
- Must produce exactly 43 iterations for Matrix 1
- Use same exact cover matrix construction (324 columns)
- Output format must match: puzzle state + "Solved in Iterations=43"

**runMe.sh**:
- Set LANGUAGE="Scala", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function: check_toolchain scalac, then `scalac DLX.scala && echo '#!/bin/bash\nscala DLX "$@"' > dlx_solver && chmod +x dlx_solver`
- Call main "$@"

**What to avoid and WHY**:
- Do NOT try to use immutable data structures (case classes with copy) - the dancing links algorithm requires in-place mutation for performance and correctness
- Do NOT use Scala collections (List, Vector) for node storage - we need manual pointer manipulation
- Do NOT add functional operations (map, flatMap, for-comprehensions) to search logic - must match C reference exactly
- Do NOT use Scala's lazy evaluation - we need strict evaluation for iteration counting
</action>
  <verify>cd Algorithms/DLX/Scala && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX implementation compiles cleanly with scalac, produces exactly 43 iterations, output format matches C reference, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in Scala</name>
  <files>Algorithms/CP/Scala/CP.scala, Algorithms/CP/Scala/runMe.sh</files>
  <action>
Create Algorithms/CP/Scala/ directory structure. Port the CP algorithm to Scala:

**CP.scala structure**:
- Use Scala class with mutable Arrays:
  ```scala
  class CPGrid(val cells: Array[Array[Int]], val candidates: Array[Array[Short]])
  ```
- Define bitset operations as methods or implicit class:
  ```scala
  implicit class BitOps(val bits: Short) extends AnyVal {
    def setBit(bit: Int): Short = (bits | (1 << bit)).toShort
    def clearBit(bit: Int): Short = (bits & ~(1 << bit)).toShort
    def testBit(bit: Int): Boolean = (bits & (1 << bit)) != 0
    def countBits: Int = Integer.bitCount(bits)
  }
  ```
- Implement `def initializeGrid(): CPGrid` - set empty cells to 0x1FF candidates
- Implement `def assign(grid: CPGrid, row: Int, col: Int, value: Int): Boolean` - place value and propagate
- Implement `def eliminate(grid: CPGrid, row: Int, col: Int, candidates: Short): Boolean` - remove candidates
- Implement `def propagate(grid: CPGrid): Boolean` - constraint propagation
- Implement `def findMRV(grid: CPGrid): Option[(Int, Int)]` - find cell with minimum remaining values
- Implement `def solve(grid: CPGrid): Boolean` - recursive search
- Object with main method and iteration counter

**Scala-specific considerations**:
- Use `Array.ofDim[Int](9, 9)` for 2D arrays
- Use `Option[(Int, Int)]` for MRV return value (None if no empty cells)
- Use implicit class for elegant bitset operations on Short
- Use pattern matching on Option: `findMRV(grid) match { case Some((r, c)) => ... }`
- Keep imperative style for propagation (don't try to make it purely functional)

**Critical requirements**:
- Use Short (16-bit) for candidate bitsets, not Int or Long
- Count every assignment attempt before validity check
- Use MRV heuristic for cell selection (produces 67 iterations)
- Must produce exactly 67 iterations for Matrix 1
- Output format: puzzle state + "Solved in Iterations=67"

**runMe.sh**:
- Set LANGUAGE="Scala", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function: check_toolchain scalac, then `scalac CP.scala && echo '#!/bin/bash\nscala CP "$@"' > cp_solver && chmod +x cp_solver`
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use immutable collections (Vector, List) for the grid - we need mutable Array for in-place updates during backtracking
- Do NOT use Scala's BitSet class - we need Short (16-bit) for memory efficiency matching C
- Do NOT add Scala Futures or parallel collections - algorithm must be synchronous for iteration counting
- Do NOT use tail recursion optimization (@tailrec) if it changes iteration count - verify behavior matches C
</action>
  <verify>cd Algorithms/CP/Scala && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP implementation compiles cleanly with scalac, produces exactly 67 iterations, output format matches C reference, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd Algorithms/DLX/Scala && ./runMe.sh ../../../Matrices/1.matrix` produces exactly 43 iterations
- [ ] `cd Algorithms/CP/Scala && ./runMe.sh ../../../Matrices/1.matrix` produces exactly 67 iterations
- [ ] Both implementations compile without errors
- [ ] Output format matches C reference
- [ ] metrics.json files created for both implementations
</verification>

<success_criteria>

- Both DLX and CP algorithms implemented in Scala
- Iteration counts verified: DLX=43, CP=67 for Matrix 1
- Both implementations integrated into benchmark system
- Compilation successful with scalac
- Output format matches established conventions
</success_criteria>

<output>
After completion, create `.planning/phases/08-jvm-languages/08-03-SUMMARY.md`
</output>
