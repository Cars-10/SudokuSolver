---
phase: 08-jvm-languages
plan: 04
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Groovy/DLX.groovy, Algorithms/DLX/Groovy/runMe.sh, Algorithms/CP/Groovy/CP.groovy, Algorithms/CP/Groovy/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Groovy, leveraging dynamic typing and scripting features while maintaining algorithmic correctness.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms to Groovy, demonstrating how a dynamically-typed JVM language can implement exact algorithms with performance verification.
Output: Working DLX and CP implementations for Groovy with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-c-family-languages/07-01-SUMMARY.md
@.planning/phases/07-c-family-languages/07-02-SUMMARY.md
@Algorithms/DLX/C/dlx.h
@Algorithms/DLX/C/dlx_core.c
@Algorithms/DLX/C/dlx_sudoku.c
@Algorithms/CP/C/cp.h
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp_sudoku.c
@Algorithms/BruteForce/Groovy/Sudoku.groovy

**Tech stack available**: Groovy compiler (groovyc), Groovy runtime, JVM
**Established patterns**: Mechanical translation from C, verify iteration counts, use language features that don't compromise algorithm
**Constraining decisions**:
- Phase 7: Algorithm structure must remain faithful to C reference for iteration count verification
- Phase 8-01 (Java): DLX needs pointer manipulation, CP uses 16-bit bitsets
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in Groovy</name>
  <files>Algorithms/DLX/Groovy/DLX.groovy, Algorithms/DLX/Groovy/runMe.sh</files>
  <action>
Create Algorithms/DLX/Groovy/ directory structure. Port the DLX algorithm to Groovy:

**DLX.groovy structure**:
- Use Groovy classes (dynamically typed but can add optional type hints for clarity):
  ```groovy
  class DlxNode {
      DlxNode left, right, up, down
      DlxColumn column
      int row
  }
  class DlxColumn extends DlxNode {
      String name
      int size = 0
  }
  ```
- Implement `void coverColumn(DlxColumn c)` - exact same logic as C
- Implement `void uncoverColumn(DlxColumn c)` - exact reversal
- Implement `boolean search(int k)` - recursive backtracking
- Implement `void buildExactCoverMatrix()` - 324 columns
- Implement `void parseMatrix(String filename)` - read .matrix file
- Static/global iteration counter and main method

**Groovy-specific features to use**:
- File I/O: `new File(filename).eachLine { line -> ... }` for concise file reading
- String interpolation: `println "Solved in Iterations=${iterations}"`
- Groovy's dynamic method dispatch and duck typing where beneficial
- Default parameter values if helpful
- Elvis operator (?:) for null coalescing if needed

**Critical requirements**:
- Maintain circular doubly-linked list structure (mutable references)
- Must produce exactly 43 iterations for Matrix 1
- Use same exact cover matrix construction (324 columns)
- Output format must match: puzzle state + "Solved in Iterations=43"
- Groovy's dynamic typing shouldn't change algorithm behavior

**runMe.sh**:
- Set LANGUAGE="Groovy", SOLVER_BINARY="./dlx_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function: check_toolchain groovyc, then `groovyc DLX.groovy && echo '#!/bin/bash\ngroovy -cp . DLX "$@"' > dlx_solver && chmod +x dlx_solver`
- Alternatively, can run as script: `echo '#!/usr/bin/env groovy\n' > dlx_solver && cat DLX.groovy >> dlx_solver && chmod +x dlx_solver`
- Call main "$@"

**What to avoid and WHY**:
- Do NOT rely on Groovy's GPath or collection operators for node traversal - we need explicit pointer manipulation
- Do NOT use Groovy's dynamic method_missing for node operations - keep explicit methods for clarity and performance
- Do NOT use Groovy's AST transformations (@Canonical, @Immutable) - we need mutable nodes
- Do NOT use Groovy closures in the search algorithm - keep procedural for exact C matching
</action>
  <verify>cd Algorithms/DLX/Groovy && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX implementation runs successfully with groovy, produces exactly 43 iterations, output format matches C reference, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in Groovy</name>
  <files>Algorithms/CP/Groovy/CP.groovy, Algorithms/CP/Groovy/runMe.sh</files>
  <action>
Create Algorithms/CP/Groovy/ directory structure. Port the CP algorithm to Groovy:

**CP.groovy structure**:
- Use Groovy class with typed arrays:
  ```groovy
  class CPGrid {
      int[][] cells = new int[9][9]
      short[][] candidates = new short[9][9]
  }
  ```
- Define bitset operations as static methods or as methods in CPGrid:
  ```groovy
  static short setBit(short bits, int bit) { (bits | (1 << bit)) as short }
  static short clearBit(short bits, int bit) { (bits & ~(1 << bit)) as short }
  static boolean testBit(short bits, int bit) { (bits & (1 << bit)) != 0 }
  static int countBits(short bits) { Integer.bitCount(bits as int) }
  ```
- Implement `CPGrid initializeGrid()` - set empty cells to 0x1FF candidates
- Implement `boolean assign(CPGrid grid, int row, int col, int value)` - place value and propagate
- Implement `boolean eliminate(CPGrid grid, int row, int col, short candidates)` - remove candidates
- Implement `boolean propagate(CPGrid grid)` - constraint propagation
- Implement `Map findMRV(CPGrid grid)` - return [row: r, col: c] or null
- Implement `boolean solve(CPGrid grid)` - recursive search
- Static iteration counter and main method

**Groovy-specific features to use**:
- File I/O: `new File(filename).readLines()`
- Return Map for MRV: `[row: r, col: c]` (Groovy syntax sugar)
- Null-safe navigation: `findMRV(grid)?.row`
- String interpolation: `"Solved in Iterations=${iterations}"`
- Type coercion with `as` keyword for Short conversion

**Critical requirements**:
- Use short (16-bit) for candidate bitsets, explicitly cast with `as short`
- Count every assignment attempt before validity check
- Use MRV heuristic for cell selection (produces 67 iterations)
- Must produce exactly 67 iterations for Matrix 1
- Output format: puzzle state + "Solved in Iterations=67"

**runMe.sh**:
- Set LANGUAGE="Groovy", SOLVER_BINARY="./cp_solver", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function: check_toolchain groovyc, then `groovyc CP.groovy && echo '#!/bin/bash\ngroovy -cp . CP "$@"' > cp_solver && chmod +x cp_solver`
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Groovy's built-in Collection methods (findAll, collect) for propagation - keep explicit loops for C matching
- Do NOT rely on Groovy's dynamic typing to avoid explicit short casting - bitset operations must use 16-bit shorts
- Do NOT use Groovy's metaprogramming features for grid access - keep straightforward array indexing
- Do NOT use Groovy's spread operator or other syntactic sugar in algorithm core - maintain explicit control flow
</action>
  <verify>cd Algorithms/CP/Groovy && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP implementation runs successfully with groovy, produces exactly 67 iterations, output format matches C reference, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd Algorithms/DLX/Groovy && ./runMe.sh ../../../Matrices/1.matrix` produces exactly 43 iterations
- [ ] `cd Algorithms/CP/Groovy && ./runMe.sh ../../../Matrices/1.matrix` produces exactly 67 iterations
- [ ] Both implementations run successfully
- [ ] Output format matches C reference
- [ ] metrics.json files created for both implementations
</verification>

<success_criteria>

- Both DLX and CP algorithms implemented in Groovy
- Iteration counts verified: DLX=43, CP=67 for Matrix 1
- Both implementations integrated into benchmark system
- Successful execution with groovy runtime
- Output format matches established conventions
</success_criteria>

<output>
After completion, create `.planning/phases/08-jvm-languages/08-04-SUMMARY.md`
</output>
