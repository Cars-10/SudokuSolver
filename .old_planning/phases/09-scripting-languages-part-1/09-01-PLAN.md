---
phase: 09-scripting-languages-part-1
plan: 01
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Python/dlx.py, Algorithms/DLX/Python/runMe.sh, Algorithms/CP/Python/cp.py, Algorithms/CP/Python/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Python, establishing the first scripting language algorithm implementations.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms from C reference to Python, following established patterns from Phase 7-8. Python serves as the baseline scripting language implementation that other scripting languages can reference.
Output: Working DLX and CP implementations for Python with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-c-family-languages/07-01-SUMMARY.md
@.planning/phases/08-jvm-languages/08-01-SUMMARY.md
@Algorithms/DLX/C/dlx.h
@Algorithms/DLX/C/dlx_core.c
@Algorithms/DLX/C/dlx_sudoku.c
@Algorithms/DLX/C/runMe.sh
@Algorithms/CP/C/cp.h
@Algorithms/CP/C/cp_core.c
@Algorithms/CP/C/cp_sudoku.c
@Algorithms/CP/C/runMe.sh
@Algorithms/BruteForce/Python/Sudoku.py

**Tech stack available**: Python 3.x (already present for BruteForce), python3 interpreter
**Established patterns**: Mechanical translation from C to preserve algorithm correctness, verification via iteration count matching, runMe.sh integration with common.sh
**Constraining decisions**:
- Phase 7: Strict mechanical translation approach ensures algorithmic correctness
- Phase 7: Use native language features (classes/objects) for data structures but keep algorithm logic identical
- Phase 8: Verified iteration counts match C reference exactly (DLX: 43, CP: 67 for Matrix 1)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in Python</name>
  <files>Algorithms/DLX/Python/dlx.py, Algorithms/DLX/Python/runMe.sh</files>
  <action>
Create Algorithms/DLX/Python/ directory structure. Port the DLX algorithm from C to Python:

**dlx.py structure**:
- Create DlxNode class with attributes: left, right, up, down, column, row_id (all references to other nodes)
- Create DlxColumn class with DlxNode embedded (composition), plus size field and name
- Implement cover_column(c) function - exact same logic as C (unlink column and all rows)
- Implement uncover_column(c) function - exact reversal of cover operation
- Implement search(root, k, solution) function - recursive backtracking with Algorithm X
- Implement build_exact_cover_matrix() - create 324 columns for Sudoku constraints
- Implement parse_matrix(filename) - read .matrix file and create constraint rows
- Main block that calls parse_matrix, search, and prints results
- Global dlx_iterations counter incremented at start of search

**Critical requirements**:
- Use Python object references naturally (Python's object model handles pointers cleanly)
- Maintain circular doubly-linked list structure exactly as in C (column.node.right loops back to root)
- Print output format: puzzle state, then "Solved in Iterations=43" (must be exactly 43 for Matrix 1)
- Use same exact cover mapping: row*81 + col*9 + digit for each placement
- File structure: all code in single dlx.py file, executable via python3 dlx.py <matrix_file>

**runMe.sh**:
- Set LANGUAGE="Python", SOLVER_BINARY="python3 dlx.py", METRICS_FILE="metrics.json"
- Source ../../common.sh
- No compile() function needed (interpreted language)
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Python's built-in list slicing tricks for node operations - we need explicit pointer manipulation for cover/uncover to work correctly
- Do NOT optimize the search order or add heuristics - must match C reference exactly for iteration count verification
- Do NOT use 0-indexed printing - Sudoku uses 1-9 values, empty cells print as 0
- Do NOT use Python's defaultdict or other clever data structures - maintain explicit node/column structure from C
</action>
  <verify>cd Algorithms/DLX/Python && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43" and produces correctly solved puzzle</verify>
  <done>DLX implementation runs cleanly, produces exactly 43 iterations for Matrix 1, output format matches C reference, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in Python</name>
  <files>Algorithms/CP/Python/cp.py, Algorithms/CP/Python/runMe.sh</files>
  <action>
Create Algorithms/CP/Python/ directory structure. Port the CP algorithm from C to Python:

**cp.py structure**:
- Create CPGrid class with attributes: values (9x9 list of int for placed values), candidates (9x9 list of int for candidate bitsets)
- Define bitset helper functions: has_candidate(set, digit), add_candidate(set, digit), remove_candidate(set, digit), count_candidates(set)
- Implement init_grid(grid, puzzle) - set all empty cells to have candidates with bits 1-9 set (0x1FF)
- Implement assign(grid, row, col, value) - place value and propagate constraints (clear that bit from row/col/box peers)
- Implement eliminate(grid, row, col, candidates_to_remove) - remove impossible candidates and propagate
- Implement propagate(grid) - apply constraint propagation until quiescence
- Implement find_mrv_cell(grid) - find empty cell with Minimum Remaining Values (fewest candidates)
- Implement cp_search(grid) - recursive search with propagation: propagate, find MRV cell, try each candidate value
- Implement parse_matrix(filename) and main block with global cp_iterations counter
- File structure: all code in single cp.py file, executable via python3 cp.py <matrix_file>

**Critical requirements**:
- Use Python integers for bitsets (Python's arbitrary precision handles this naturally)
- Bitset operations: use bit shifting and masking (1 << digit for single bit)
- Print output format: puzzle state, then "Solved in Iterations=67" (must be exactly 67 for Matrix 1)
- Increment cp_iterations at start of cp_search (before propagation check)
- Use bit manipulation for candidate counting: bin(candidates).count('1') or implement popcount

**runMe.sh**:
- Set LANGUAGE="Python", SOLVER_BINARY="python3 cp.py", METRICS_FILE="metrics.json"
- Source ../../common.sh
- No compile() function needed (interpreted language)
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use sets or lists for candidate tracking - must use bitsets for performance and to match C reference semantics
- Do NOT add additional constraint propagation techniques beyond what's in C reference (no naked pairs, hidden singles beyond basic propagation)
- Do NOT change the MRV selection order - must select first cell with minimum candidates (row-major scan)
</action>
  <verify>cd Algorithms/CP/Python && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67" and produces correctly solved puzzle</verify>
  <done>CP implementation runs cleanly, produces exactly 67 iterations for Matrix 1, output format matches C reference, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd Algorithms/DLX/Python && ./runMe.sh ../../../Matrices/1.matrix` shows exactly 43 iterations
- [ ] `cd Algorithms/CP/Python && ./runMe.sh ../../../Matrices/1.matrix` shows exactly 67 iterations
- [ ] Both implementations produce correctly solved puzzles
- [ ] metrics.json files exist for both implementations
- [ ] No Python syntax errors or runtime exceptions
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- DLX iteration count exactly matches C reference (43)
- CP iteration count exactly matches C reference (67)
- Both implementations integrated into benchmark system
</success_criteria>

<output>
After completion, create `.planning/phases/09-scripting-languages-part-1/09-01-SUMMARY.md`:

# Phase 9 Plan 1: Python Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.py` - Description
- `path/to/another.py` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 09-02-PLAN.md (Ruby algorithms)
</output>
