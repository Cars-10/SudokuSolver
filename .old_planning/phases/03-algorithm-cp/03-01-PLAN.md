---
phase: 03-algorithm-cp
plan: 01
type: execute
depends_on: []
files_modified: [Algorithms/CP/C/runMe.sh, Algorithms/CP/C/cp.h, Algorithms/CP/C/cp_core.c, Algorithms/CP/C/cp_sudoku.c]
---

<objective>
Establish Constraint Propagation algorithm scaffolding in C.

Purpose: Create the directory structure, build system, and core data structure definitions for a CP-based Sudoku solver that will complement the existing BruteForce and DLX implementations.
Output: Compilable stub implementation with defined data structures for candidate tracking and constraint propagation.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-algorithm-dancing-links/phase-2-plan-1-scaffolding-SUMMARY.md

**Tech stack available:** C compiler, Bash, Python (for timing), common.sh benchmark harness
**Established patterns:**
- Multi-algorithm structure: `Algorithms/[Algorithm]/[Language]/`
- Each algorithm has `runMe.sh` sourcing `../../common.sh`
- Solver binary naming: `{algorithm}_solver` (e.g., `cp_solver`)
- Standard output format with iteration counting

**Constraining decisions:**
- [Phase 2.1]: Unified directory structure - all algorithms under `Algorithms/`
- [Phase 2]: DLX structure established pattern for new algorithm integration
- [Init]: Algorithm separation - maintain modularity between algorithm types

**CP Algorithm Context (from discovery):**
Two main constraint propagation strategies:
1. **Singleton Elimination**: If a cell has only one possible value, eliminate that value from its 20 peers (same row, column, and 3x3 box)
2. **Hidden Singles**: If a unit (row/column/box) has only one place for a value, assign it there

CP uses candidate tracking (possible values per cell) rather than exact cover matrices. Typically implemented with:
- 9x9 grid of candidate sets (bitsets or arrays)
- Propagate function that iteratively eliminates impossible values
- Backtracking search when propagation alone is insufficient
- Minimum Remaining Values (MRV) heuristic for cell selection

**References:**
- Norvig's approach: https://norvig.com/sudoku.html
- Combines constraint propagation with depth-first search
- Iteration count = assignment attempts (similar to brute-force counting)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create directory structure and build script</name>
  <files>Algorithms/CP/C/runMe.sh</files>
  <action>
Create `Algorithms/CP/C/` directory. Create `runMe.sh` following the established pattern from `Algorithms/DLX/C/runMe.sh`:
- Set LANGUAGE="C", ALGORITHM="CP"
- Set SOLVER_BINARY="./cp_solver"
- Set METRICS_FILE="metrics.json", TIMEOUT_SECONDS=300
- Source ../../common.sh
- Define compile() function that compiles cp_sudoku.c and cp_core.c into cp_solver binary
- Call main "$@"

Use the exact same structure as DLX to maintain consistency across algorithm implementations.
  </action>
  <verify>chmod +x Algorithms/CP/C/runMe.sh && bash -n Algorithms/CP/C/runMe.sh (syntax check)</verify>
  <done>runMe.sh exists, is executable, sources common.sh correctly, defines compile()</done>
</task>

<task type="auto">
  <name>Task 2: Define CP data structures in header file</name>
  <files>Algorithms/CP/C/cp.h</files>
  <action>
Create `Algorithms/CP/C/cp.h` with:

1. **Candidate tracking**: Use bitsets (uint16_t) for efficiency - 9 bits for digits 1-9
   ```c
   typedef uint16_t CandidateSet;  // Bitset for candidates 1-9
   ```

2. **Grid structure**:
   ```c
   typedef struct {
       int values[9][9];           // Assigned values (0 = empty)
       CandidateSet candidates[9][9];  // Possible values per cell
   } CPGrid;
   ```

3. **Function declarations**:
   ```c
   // Initialization
   void init_grid(CPGrid *grid, int puzzle[9][9]);

   // Constraint propagation
   int propagate(CPGrid *grid);
   int eliminate(CPGrid *grid, int row, int col, int digit);
   int assign(CPGrid *grid, int row, int col, int digit);

   // Search
   int cp_search(CPGrid *grid, int *solution);
   int find_mrv_cell(CPGrid *grid, int *row, int *col);

   // Iteration counter (extern)
   extern long long cp_iterations;
   ```

4. **Helper macros** for candidate manipulation:
   ```c
   #define HAS_CANDIDATE(set, digit) ((set) & (1 << (digit)))
   #define ADD_CANDIDATE(set, digit) ((set) |= (1 << (digit)))
   #define REMOVE_CANDIDATE(set, digit) ((set) &= ~(1 << (digit)))
   #define COUNT_CANDIDATES(set) (__builtin_popcount(set))
   ```

Keep the header focused and clean. Avoid complex abstractions - we need efficient, straightforward data structures for Sudoku constraint propagation.
  </action>
  <verify>gcc -fsyntax-only -c Algorithms/CP/C/cp.h (header syntax check)</verify>
  <done>cp.h exists with CPGrid, CandidateSet, function declarations, and candidate macros</done>
</task>

<task type="auto">
  <name>Task 3: Create core algorithm stubs</name>
  <files>Algorithms/CP/C/cp_core.c</files>
  <action>
Create `Algorithms/CP/C/cp_core.c` with:

1. **Include headers**:
   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include "cp.h"
   ```

2. **Global iteration counter**:
   ```c
   long long cp_iterations = 0;
   ```

3. **Function stubs** (empty implementations that compile):
   - `void init_grid(CPGrid *grid, int puzzle[9][9])` - Initialize candidates to all possible (1-9) for empty cells, single value for given clues
   - `int eliminate(CPGrid *grid, int row, int col, int digit)` - Remove digit from candidates[row][col], return 0 if contradiction
   - `int assign(CPGrid *grid, int row, int col, int digit)` - Assign value and propagate, return 0 if contradiction
   - `int propagate(CPGrid *grid)` - Apply singleton elimination and hidden singles until fixpoint, return 0 if contradiction
   - `int find_mrv_cell(CPGrid *grid, int *row, int *col)` - Find cell with minimum remaining values, return 0 if grid complete
   - `int cp_search(CPGrid *grid, int *solution)` - Recursive backtracking with propagation, return 1 if solved

Each stub should:
- Have correct signature matching cp.h
- Return a default value (0 or 1) to make it compilable
- Include a TODO comment: `// TODO: Implement in Plan 2`
  </action>
  <verify>gcc -c Algorithms/CP/C/cp_core.c -o /tmp/cp_core.o (compilation check)</verify>
  <done>cp_core.c exists with all function stubs, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 4: Create main entrypoint stub</name>
  <files>Algorithms/CP/C/cp_sudoku.c</files>
  <action>
Create `Algorithms/CP/C/cp_sudoku.c` with:

1. **Includes**:
   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <sys/time.h>
   #include "cp.h"
   ```

2. **Puzzle I/O stubs** (similar to DLX):
   - `int readMatrixFile(const char *filename, int puzzle[9][9])` - Stub that returns 0
   - `void printPuzzle(int puzzle[9][9])` - Stub that does nothing

3. **main() function**:
   ```c
   int main(int argc, char *argv[]) {
       if (argc != 2) {
           fprintf(stderr, "Usage: %s <matrix_file>\n", argv[0]);
           return 1;
       }

       printf("CP Solver stub - implementation in Plan 2\n");
       return 0;
   }
   ```

Keep it minimal - just enough to link and run without crashing. Full implementation comes in Plan 2.
  </action>
  <verify>gcc Algorithms/CP/C/cp_sudoku.c Algorithms/CP/C/cp_core.c -o /tmp/cp_solver_test (link check)</verify>
  <done>cp_sudoku.c exists with main() stub, links successfully with cp_core.c</done>
</task>

<task type="auto">
  <name>Task 5: Verify compilation through runMe.sh</name>
  <files>Algorithms/CP/C/cp_solver (generated)</files>
  <action>
Run the build script to ensure the complete scaffolding compiles:
```bash
cd Algorithms/CP/C && ./runMe.sh
```

This should:
1. Source common.sh successfully
2. Call the compile() function
3. Produce the cp_solver binary
4. Not crash when trying to run (though it won't solve anything yet)

If compilation fails, debug and fix the issues. The goal is a working build pipeline, not a working solver (that's Plan 2).
  </action>
  <verify>ls -la Algorithms/CP/C/cp_solver && file Algorithms/CP/C/cp_solver</verify>
  <done>cp_solver binary exists, is executable, compilation succeeds without errors</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Directory `Algorithms/CP/C/` exists
- [ ] `runMe.sh` is executable and sources common.sh
- [ ] `cp.h` defines CPGrid, CandidateSet, and function signatures
- [ ] `cp_core.c` has all algorithm stubs
- [ ] `cp_sudoku.c` has main() stub
- [ ] `./runMe.sh` successfully compiles cp_solver binary
- [ ] No compiler errors or warnings
</verification>

<success_criteria>

- All 5 tasks completed
- All verification checks pass
- Scaffolding matches DLX pattern (consistency across algorithms)
- cp_solver binary builds successfully
- Ready for Plan 2 (implementation)
  </success_criteria>

<output>
After completion, create `.planning/phases/03-algorithm-cp/03-01-SUMMARY.md`:

# Phase 3 Plan 1: CP Algorithm Scaffolding Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- Created Algorithms/CP/C directory structure
- Established build system with runMe.sh
- Defined data structures for candidate tracking (bitsets)
- Created compilable stubs for all core functions

## Files Created/Modified

- `Algorithms/CP/C/runMe.sh` - Build script
- `Algorithms/CP/C/cp.h` - Header with CPGrid and function declarations
- `Algorithms/CP/C/cp_core.c` - Algorithm stubs
- `Algorithms/CP/C/cp_sudoku.c` - Main entrypoint stub

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 03-02-PLAN.md (CP implementation)
</output>
