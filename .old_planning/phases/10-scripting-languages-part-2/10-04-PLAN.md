---
phase: 10-scripting-languages-part-2
plan: 04
type: execute
depends_on: []
files_modified: [Algorithms/DLX/Julia/dlx.jl, Algorithms/DLX/Julia/runMe.sh, Algorithms/CP/Julia/cp.jl, Algorithms/CP/Julia/runMe.sh]
---

<objective>
Implement DLX and CP algorithms for Julia, extending algorithm coverage to this high-performance scientific computing language.

Purpose: Port Dancing Links (DLX) and Constraint Propagation (CP) algorithms from C reference to Julia, following established patterns. Julia's mutable structs provide efficient structures for DLX nodes.
Output: Working DLX and CP implementations for Julia with verified iteration counts (DLX: 43, CP: 67).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Algorithms/DLX/C/dlx_core.c
@Algorithms/CP/C/cp_core.c
@Algorithms/BruteForce/Julia/Sudoku.jl

**Tech stack available**: Julia (already present for BruteForce)
**Established patterns**: Mechanical translation from C, iteration count verification (DLX: 43, CP: 67), runMe.sh integration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DLX (Dancing Links) algorithm in Julia</name>
  <files>Algorithms/DLX/Julia/dlx.jl, Algorithms/DLX/Julia/runMe.sh</files>
  <action>
Create Algorithms/DLX/Julia/ directory structure. Port the DLX algorithm from C to Julia:

**dlx.jl structure**:
- Define mutable struct DlxNode with fields: left::Union{DlxNode, DlxColumn, Nothing}, right, up, down, column, row_id::Int
- Define mutable struct DlxColumn with fields: node::DlxNode, size::Int, name::String
- Implement function cover_column!(c::DlxColumn) - exact same logic as C (unlink column and all rows)
- Implement function uncover_column!(c::DlxColumn) - exact reversal of cover operation
- Implement function search!(root::DlxColumn, k::Int, solution::Vector{Int}) - recursive backtracking with Algorithm X
- Implement function build_exact_cover_matrix() - create 324 columns for Sudoku constraints
- Implement function parse_matrix(filename::String) - read .matrix file and create constraint rows
- Main execution that calls parse_matrix, search, and prints results
- Global dlx_iterations::Ref{Int} = Ref(0) incremented at start of search (use Ref for mutable global)

**Critical requirements**:
- Use mutable structs for DlxNode and DlxColumn (Julia's efficient pointer-like structures)
- Use Union types for nullable references (Union{DlxNode, Nothing})
- Maintain circular doubly-linked list structure exactly as in C
- Print output format: puzzle state using println(), then "Solved in Iterations=43"
- Use same exact cover mapping: row*81 + col*9 + digit
- File structure: all code in single dlx.jl file, executable via julia dlx.jl <matrix_file>
- Add shebang: #!/usr/bin/env julia
- Julia arrays are 1-indexed - adjust all array indexing accordingly
- Use ! suffix for functions that mutate (cover_column!, search!)
- Use Ref{Int} for mutable global counter

**runMe.sh**:
- Set LANGUAGE="Julia", SOLVER_BINARY="julia dlx.jl", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function should check_toolchain julia
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use immutable structs - need mutable for pointer manipulation
- Do NOT use Julia's array operations for node manipulation - need explicit pointer operations
- Do NOT optimize the search order - must match C reference exactly
- Do NOT use Julia packages - keep implementation self-contained using only Base
- Do NOT forget Julia uses 1-based indexing - adjust all loops and array accesses
- Do NOT use bare integers for mutable globals - wrap in Ref{Int}
</action>
  <verify>cd Algorithms/DLX/Julia && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=43"</verify>
  <done>DLX implementation runs cleanly, produces exactly 43 iterations for Matrix 1, metrics.json created</done>
</task>

<task type="auto">
  <name>Task 2: Implement CP (Constraint Propagation) algorithm in Julia</name>
  <files>Algorithms/CP/Julia/cp.jl, Algorithms/CP/Julia/runMe.sh</files>
  <action>
Create Algorithms/CP/Julia/ directory structure. Port the CP algorithm from C to Julia:

**cp.jl structure**:
- Define mutable struct CPGrid with fields: values::Matrix{Int}, candidates::Matrix{Int} (matrices for bitsets)
- Define bitset helper functions:
  - has_candidate(set::Int, digit::Int)::Bool - test bit
  - add_candidate(set::Int, digit::Int)::Int - set bit (returns new value)
  - remove_candidate(set::Int, digit::Int)::Int - clear bit (returns new value)
  - count_candidates(set::Int)::Int - popcount using count_ones()
- Implement init_grid!(grid::CPGrid, puzzle::Matrix{Int}) - set empty cells to candidates = 0x1FF
- Implement assign!(grid::CPGrid, row::Int, col::Int, value::Int) - place value and propagate constraints
- Implement eliminate!(grid::CPGrid, row::Int, col::Int, candidates_to_remove::Int) - remove candidates and propagate
- Implement propagate!(grid::CPGrid) - apply constraint propagation until quiescence
- Implement find_mrv_cell(grid::CPGrid) - find cell with Minimum Remaining Values (returns (row, col) or nothing)
- Implement cp_search(grid::CPGrid) - recursive search with propagation (returns grid or nothing)
- Implement parse_matrix(filename::String) and main execution with global cp_iterations::Ref{Int}
- Add shebang: #!/usr/bin/env julia
- Julia arrays are 1-indexed - adjust all indexing accordingly
- Use ! suffix for mutating functions

**Critical requirements**:
- Use Julia Int for bitsets (64-bit integers)
- Bitset operations: use << for shift left, & for bitwise AND, | for bitwise OR
- Use count_ones() for popcount (built-in Julia function)
- Print output format: puzzle state using println(), then "Solved in Iterations=67"
- Increment cp_iterations at start of cp_search using Ref
- Use mutable struct for CPGrid to allow in-place modifications
- Use deepcopy() for grid copying in backtracking

**runMe.sh**:
- Set LANGUAGE="Julia", SOLVER_BINARY="julia cp.jl", METRICS_FILE="metrics.json"
- Source ../../common.sh
- compile() function should check_toolchain julia
- Call main "$@"

**What to avoid and WHY**:
- Do NOT use Julia arrays for candidates - must use bitsets (integers)
- Do NOT add extra constraint propagation techniques
- Do NOT change MRV selection order
- Do NOT use Julia packages - keep implementation self-contained using only Base
- Do NOT forget Julia uses 1-based indexing for matrices
- Do NOT use bare integers for mutable globals - wrap in Ref{Int}
</action>
  <verify>cd Algorithms/CP/Julia && ./runMe.sh ../../../Matrices/1.matrix shows "Solved in Iterations=67"</verify>
  <done>CP implementation runs cleanly, produces exactly 67 iterations for Matrix 1, metrics.json created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] DLX Julia shows exactly 43 iterations for Matrix 1
- [ ] CP Julia shows exactly 67 iterations for Matrix 1
- [ ] Both produce correctly solved puzzles
- [ ] metrics.json files exist for both
- [ ] No Julia syntax errors or warnings
- [ ] 1-based indexing handled correctly
- [ ] Mutable globals wrapped in Ref{Int}
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Iteration counts match C reference exactly
- Both implementations integrated into benchmark system
</success_criteria>

<output>
After completion, create `.planning/phases/10-scripting-languages-part-2/10-04-SUMMARY.md`:

# Phase 10 Plan 4: Julia Algorithms Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.jl` - Description
- `path/to/another.jl` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for Plan 10-05: Octave Algorithms
</output>
