description = "Execute all plans in a phase with intelligent parallelization"
prompt = "<objective>\nExecute all unexecuted plans in a phase with parallel agent spawning.\n\nAnalyzes plan dependencies to identify independent plans that can run concurrently.\nSpawns background agents for parallel execution, each agent commits its own tasks atomically.\n\n**Critical constraint:** One subagent per plan, always. This is for context isolation, not parallelization. Even strictly sequential plans spawn separate subagents so each starts with fresh 200k context at 0%.\n\nUse this command when:\n- Phase has 2+ unexecuted plans\n- Want \"walk away, come back to completed work\" execution\n- Plans have clear dependency boundaries\n</objective>\n\n<execution_context>\n@./.gemini/get-shit-done/workflows/execute-plan.md\n@./.gemini/get-shit-done/workflows/execute-phase.md\n@./.gemini/get-shit-done/templates/summary.md\n@./.gemini/get-shit-done/references/checkpoints.md\n@./.gemini/get-shit-done/references/tdd.md\n</execution_context>\n\n<context>\nPhase number: $ARGUMENTS (required)\n\n@.planning/STATE.md\n@.planning/config.json\n</context>\n\n<process>\n1. Validate phase exists in roadmap\n2. Find all PLAN.md files without matching SUMMARY.md\n3. If 0 or 1 plans: suggest /gsd:execute-plan instead\n4. If 2+ plans: follow execute-phase.md workflow\n5. Monitor parallel agents until completion\n6. Present results and next steps\n</process>\n\n<execution_strategies>\n**Strategy A: Fully Autonomous** (no checkpoints)\n\n- Spawn subagent to execute entire plan\n- Subagent creates SUMMARY.md and commits\n- Main context: orchestration only (~5% usage)\n\n**Strategy B: Segmented** (has verify-only checkpoints)\n\n- Execute in segments between checkpoints\n- Subagent for autonomous segments\n- Main context for checkpoints\n- Aggregate results → SUMMARY → commit\n\n**Strategy C: Decision-Dependent** (has decision checkpoints)\n\n- Execute in main context\n- Decision outcomes affect subsequent tasks\n- Quality maintained through small scope (2-3 tasks per plan)\n</execution_strategies>\n\n<deviation_rules>\nDuring execution, handle discoveries automatically:\n\n1. **Auto-fix bugs** - Fix immediately, document in Summary\n2. **Auto-add critical** - Security/correctness gaps, add and document\n3. **Auto-fix blockers** - Can't proceed without fix, do it and document\n4. **Ask about architectural** - Major structural changes, stop and ask user\n5. **Log enhancements** - Nice-to-haves, log to ISSUES.md, continue\n\nOnly rule 4 requires user intervention.\n</deviation_rules>\n\n<commit_rules>\n**Per-Task Commits:**\n\nAfter each task completes:\n1. Stage only files modified by that task\n2. Commit with format: `{type}({phase}-{plan}): {task-name}`\n3. Types: feat, fix, test, refactor, perf, chore\n4. Record commit hash for SUMMARY.md\n\n**Plan Metadata Commit:**\n\nAfter all tasks complete:\n1. Stage planning artifacts only: PLAN.md, SUMMARY.md, STATE.md, ROADMAP.md\n2. Commit with format: `docs({phase}-{plan}): complete [plan-name] plan`\n3. NO code files (already committed per-task)\n\n**NEVER use:**\n- `git add .`\n- `git add -A`\n- `git add src/` or any broad directory\n\n**Always stage files individually.**\n</commit_rules>\n\n<success_criteria>\n- [ ] All independent plans executed in parallel\n- [ ] Dependent plans executed after dependencies complete\n- [ ] Each task committed individually (feat/fix/test/refactor)\n- [ ] All SUMMARY.md files created\n- [ ] Metadata committed by orchestrator\n- [ ] Phase progress updated\n</success_criteria>"
